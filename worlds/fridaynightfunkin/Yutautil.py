# Generated by Haxe 4.3.4
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
import sys as python_lib_Sys
from threading import RLock as python_lib_threading_RLock
import threading as python_lib_Threading
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import json as python_lib_Json
import os as python_lib_Os
import random as python_lib_Random
import re as python_lib_Re
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO
from threading import Semaphore as python_lib_threading_Semaphore
from threading import Thread as python_lib_threading_Thread


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes["Enum"] = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes["EReg"] = EReg


class IntIterator:
    _hx_class_name = "IntIterator"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]

    def __init__(self,_hx_min,_hx_max):
        self.min = _hx_min
        self.max = _hx_max

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.min = None
        _hx_o.max = None
IntIterator._hx_class = IntIterator
_hx_classes["IntIterator"] = IntIterator


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["has"]

    @staticmethod
    def has(it,elt):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if HxOverrides.eq(x1,elt):
                return True
        return False
Lambda._hx_class = Lambda
_hx_classes["Lambda"] = Lambda


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "getProperty", "setProperty", "callMethod", "isFunction", "compare", "isObject", "isEnumValue", "makeVarArgs"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def getProperty(o,field):
        if (o is None):
            return None
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if isinstance(o,_hx_AnonObject):
            return Reflect.field(o,field)
        tmp = Reflect.field(o,("get_" + ("null" if field is None else field)))
        if ((tmp is not None) and callable(tmp)):
            return tmp()
        else:
            return Reflect.field(o,field)

    @staticmethod
    def setProperty(o,field,value):
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if isinstance(o,_hx_AnonObject):
            setattr(o,field1,value)
        elif hasattr(o,("set_" + ("null" if field1 is None else field1))):
            getattr(o,("set_" + ("null" if field1 is None else field1)))(value)
        else:
            setattr(o,field1,value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def makeVarArgs(f):
        def _hx_local_0(*v):
            this1 = v
            return f((list(this1) if ((not Std.isOfType(this1,list))) else this1))
        return _hx_local_0
Reflect._hx_class = Reflect
_hx_classes["Reflect"] = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        _hx_len = len(x)
        index = 0
        while (index < _hx_len):
            if (not (x[index] in " \n\r\t\x0B\x0C")):
                break
            index = (index + 1)
        isNegative = None
        if (index < _hx_len):
            sign = x[index]
            if ((sign == "-") or ((sign == "+"))):
                index = (index + 1)
            isNegative = (sign == "-")
        else:
            isNegative = False
        isHexadecimal = None
        if ((index + 1) < _hx_len):
            cur = x[index]
            next = x[(index + 1)]
            isHexadecimal = ((cur == "0") and (((next == "x") or ((next == "X")))))
        else:
            isHexadecimal = False
        if isHexadecimal:
            index = (index + 2)
        cur = index
        if isHexadecimal:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789abcdefABCDEF")):
                    break
                cur = (cur + 1)
        else:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789")):
                    break
                cur = (cur + 1)
        firstInvalidIndex = cur
        if (index == firstInvalidIndex):
            return None
        result = int(HxString.substring(x,index,firstInvalidIndex),(16 if isHexadecimal else 10))
        if isNegative:
            return -result
        else:
            return result

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std
_hx_classes["Std"] = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf
_hx_classes["StringBuf"] = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim", "lpad", "replace"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])
StringTools._hx_class = StringTools
_hx_classes["StringTools"] = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "createDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)
sys_FileSystem._hx_class = sys_FileSystem
_hx_classes["sys.FileSystem"] = sys_FileSystem


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["systemName"]

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys
_hx_classes["Sys"] = Sys


class DTable:
    _hx_class_name = "DTable"
    __slots__ = ("table", "rows", "cols")
    _hx_fields = ["table", "rows", "cols"]
    _hx_methods = ["getCell", "setCell", "getByLinearIndex", "getRow", "getColumn", "formatCell", "toString", "createShape", "toArray", "toMap", "toObject"]
    _hx_statics = ["fromArray", "fromShapedArray", "fromString", "fromMap"]

    def __init__(self,rows,cols):
        self.rows = rows
        self.cols = cols
        self.table = []
        _g = 0
        _g1 = rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _g2 = 0
            _g3 = cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                row.append(None)
            _this = self.table
            _this.append(row)

    def getCell(self,row,col):
        return python_internal_ArrayImpl._get((self.table[row] if row >= 0 and row < len(self.table) else None), col)

    def setCell(self,row,col,value):
        python_internal_ArrayImpl._set((self.table[row] if row >= 0 and row < len(self.table) else None), col, value)

    def getByLinearIndex(self,index):
        row = (index / self.cols)
        col = HxOverrides.mod(index, self.cols)
        tmp = self.table
        tmp1 = None
        try:
            tmp1 = int(row)
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = python_internal_ArrayImpl._get(tmp, tmp1)
        tmp = None
        try:
            tmp = int(col)
        except BaseException as _g:
            None
            tmp = None
        return python_internal_ArrayImpl._get(tmp2, tmp)

    def getRow(self,row):
        return (self.table[row] if row >= 0 and row < len(self.table) else None)

    def getColumn(self,col):
        column = []
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = python_internal_ArrayImpl._get((self.table[i] if i >= 0 and i < len(self.table) else None), col)
            column.append(x)
        return column

    def formatCell(self,value):
        _hx_str = Std.string(value)
        if (len(_hx_str) > 5):
            _hx_str = ((HxOverrides.stringOrNull(HxString.substr(_hx_str,0,2)) + "...") + HxOverrides.stringOrNull(HxString.substr(_hx_str,(len(_hx_str) - 1),1)))
        return StringTools.lpad(_hx_str," ",5)

    def toString(self):
        result = ""
        result = (((((("[" + "Rows: ") + Std.string(self.rows)) + ", Cols: ") + Std.string(self.cols)) + "]") + "\n")
        _g = 0
        _g1 = self.table
        while (_g < len(_g1)):
            row = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            while (_g2 < len(row)):
                cell = (row[_g2] if _g2 >= 0 and _g2 < len(row) else None)
                _g2 = (_g2 + 1)
                result = (("null" if result is None else result) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(self.formatCell(cell)) + " "))))
            result = (HxOverrides.stringOrNull(HxString.substr(result,0,(len(result) - 1))) + "\n")
        return StringTools.replace(result,"null","-")

    def createShape(self,shape,mania,offset = None):
        if (offset is None):
            offset = 0
        shapeRows = len(shape)
        shapeCols = len((shape[0] if 0 < len(shape) else None))
        laneOffset = ((((mania - shapeCols)) / 2) + offset)
        _g = 0
        _g1 = shapeRows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = shapeCols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                col = None
                try:
                    col = int(HxOverrides.modf(((j + laneOffset)), mania))
                except BaseException as _g4:
                    None
                    col = None
                col1 = col
                self.setCell(i,col1,python_internal_ArrayImpl._get((shape[i] if i >= 0 and i < len(shape) else None), j))

    def toArray(self):
        return self.table

    def toMap(self):
        _hx_map = haxe_ds_StringMap()
        _hx_map.h["rows"] = self.rows
        _hx_map.h["cols"] = self.cols
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_map.h[("row_" + Std.string(i))] = (self.table[i] if i >= 0 and i < len(self.table) else None)
        return _hx_map

    def toObject(self):
        obj = _hx_AnonObject({'rows': self.rows, 'cols': self.cols})
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            HxOverrides.arraySet(obj,Std.parseInt(("row_" + Std.string(i))),(self.table[i] if i >= 0 and i < len(self.table) else None))
        return obj

    @staticmethod
    def fromArray(array):
        table = DTable(len(array),len((array[0] if 0 < len(array) else None)))
        _g = 0
        _g1 = table.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = table.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                table.setCell(i,j,python_internal_ArrayImpl._get((array[i] if i >= 0 and i < len(array) else None), j))
        return table

    @staticmethod
    def fromShapedArray(shape,mania,offset = None):
        if (offset is None):
            offset = 0
        shapeRows = len(shape)
        shapeCols = len((shape[0] if 0 < len(shape) else None))
        laneOffset = ((((mania - shapeCols)) / 2) + offset)
        table = DTable(shapeRows,mania)
        _g = 0
        _g1 = shapeRows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = shapeCols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                col = None
                try:
                    col = int(HxOverrides.modf(((j + laneOffset)), mania))
                except BaseException as _g4:
                    None
                    col = None
                col1 = col
                table.setCell(i,col1,python_internal_ArrayImpl._get((shape[i] if i >= 0 and i < len(shape) else None), j))
        return table

    @staticmethod
    def fromString(_hx_str):
        rows = _hx_str.split("\n")
        rowCount = len(rows)
        _this = (rows[0] if 0 < len(rows) else None)
        colCount = len(_this.split(", "))
        table = DTable(rowCount,colCount)
        _g = 0
        _g1 = rowCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = (rows[i] if i >= 0 and i < len(rows) else None)
            def _hx_local_0(item):
                return item
            row = list(map(_hx_local_0,_this.split(", ")))
            _this1 = table.table
            _this1.append(row)
        return table

    @staticmethod
    def fromMap(_hx_map):
        rows = _hx_map.h.get("rows",None)
        cols = _hx_map.h.get("cols",None)
        table = DTable(rows,cols)
        _g = 0
        _g1 = rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = _hx_map.h.get(("row_" + Std.string(i)),None)
            _g2 = 0
            _g3 = cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                table.setCell(i,j,(row[j] if j >= 0 and j < len(row) else None))
        return table

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.table = None
        _hx_o.rows = None
        _hx_o.cols = None
DTable._hx_class = DTable
_hx_classes["DTable"] = DTable


class Cell:
    _hx_class_name = "Cell"
    __slots__ = ("data", "type", "rawInfo", "byteData", "addressInfo", "internalVars")
    _hx_fields = ["data", "type", "rawInfo", "byteData", "addressInfo", "internalVars"]
    _hx_methods = ["getValue", "setValue"]

    def __init__(self,value):
        self.internalVars = None
        self.addressInfo = None
        self.data = [value]
        self.type = Type.getClassName(Type.getClass(value))
        self.rawInfo = Std.string(value)
        self.byteData = haxe_crypto_Base64.encode(haxe_io_Bytes.ofString(Std.string(value)))
        self.addressInfo = ("Address: " + Std.string(self))
        self.internalVars = _hx_AnonObject({})

    def getValue(self):
        return (self.data[0] if 0 < len(self.data) else None)

    def setValue(self,value):
        python_internal_ArrayImpl._set(self.data, 0, value)
        self.rawInfo = Std.string(value)
        self.byteData = haxe_crypto_Base64.encode(haxe_io_Bytes.ofString(Std.string(value)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.type = None
        _hx_o.rawInfo = None
        _hx_o.byteData = None
        _hx_o.addressInfo = None
        _hx_o.internalVars = None
Cell._hx_class = Cell
_hx_classes["Cell"] = Cell


class HTable:
    _hx_class_name = "HTable"
    __slots__ = ("table", "rows", "cols")
    _hx_fields = ["table", "rows", "cols"]
    _hx_methods = ["fromArray", "getCell", "getCellValue", "setCell", "getByLinearIndex", "getRow", "getColumn", "toString", "fromString", "toArray", "fromMap", "toMap", "fromObject", "toObject", "arrayStack", "getIndexFromString", "indexToArrayStack", "getValueFromStringIndex", "getValueFromSecondaryArray"]

    def __init__(self,rows,cols):
        self.rows = rows
        self.cols = cols
        self.table = []
        _g = 0
        _g1 = rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _g2 = 0
            _g3 = cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = Cell(None)
                row.append(x)
            _this = self.table
            _this.append(row)

    def fromArray(self,array):
        self.rows = len(array)
        self.cols = len((array[0] if 0 < len(array) else None))
        self.table = []
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _g2 = 0
            _g3 = self.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = Cell(python_internal_ArrayImpl._get((array[i] if i >= 0 and i < len(array) else None), j))
                row.append(x)
            _this = self.table
            _this.append(row)

    def getCell(self,row,col):
        return python_internal_ArrayImpl._get((self.table[row] if row >= 0 and row < len(self.table) else None), col)

    def getCellValue(self,row,col):
        return python_internal_ArrayImpl._get((self.table[row] if row >= 0 and row < len(self.table) else None), col).getValue()

    def setCell(self,row,col,value):
        python_internal_ArrayImpl._get((self.table[row] if row >= 0 and row < len(self.table) else None), col).setValue(value)

    def getByLinearIndex(self,index):
        row = (index / self.cols)
        col = HxOverrides.mod(index, self.cols)
        tmp = self.table
        tmp1 = None
        try:
            tmp1 = int(row)
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = python_internal_ArrayImpl._get(tmp, tmp1)
        tmp = None
        try:
            tmp = int(col)
        except BaseException as _g:
            None
            tmp = None
        return python_internal_ArrayImpl._get(tmp2, tmp)

    def getRow(self,row):
        return (self.table[row] if row >= 0 and row < len(self.table) else None)

    def getColumn(self,col):
        column = []
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = python_internal_ArrayImpl._get((self.table[i] if i >= 0 and i < len(self.table) else None), col)
            column.append(x)
        return column

    def toString(self):
        result = ""
        result = (((((("[" + "Rows: ") + Std.string(self.rows)) + ", Cols: ") + Std.string(self.cols)) + "]") + "\n")
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("Type: " + HxOverrides.stringOrNull(Type.getClassName(Type.getClass(python_internal_ArrayImpl._get((self.table[0] if 0 < len(self.table) else None), 0).getValue())))) + "\n"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("Raw Info: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((self.table[0] if 0 < len(self.table) else None), 0).rawInfo)) + "\n"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("Byte Data: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((self.table[0] if 0 < len(self.table) else None), 0).byteData)) + "\n"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("Address Info: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((self.table[0] if 0 < len(self.table) else None), 0).addressInfo)) + "\n"))))
        result = (("null" if result is None else result) + ((("Internal Vars: " + Std.string(python_internal_ArrayImpl._get((self.table[0] if 0 < len(self.table) else None), 0).internalVars)) + "\n")))
        result = (("null" if result is None else result) + (("[" + "\n")))
        _g = 0
        _g1 = self.table
        while (_g < len(_g1)):
            row = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            while (_g2 < len(row)):
                cell = (row[_g2] if _g2 >= 0 and _g2 < len(row) else None)
                _g2 = (_g2 + 1)
                result = (("null" if result is None else result) + ((Std.string(cell.getValue()) + ", ")))
            result = (HxOverrides.stringOrNull(HxString.substr(result,0,(len(result) - 2))) + "\n")
        return StringTools.replace(result,"null","-")

    def fromString(self,_hx_str):
        rows = _hx_str.split("\n")
        self.rows = len(rows)
        _this = (rows[0] if 0 < len(rows) else None)
        self.cols = len(_this.split(", "))
        self.table = []
        _g = 0
        _g1 = len(rows)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _this = (rows[i] if i >= 0 and i < len(rows) else None)
            values = _this.split(", ")
            _g2 = 0
            _g3 = len(values)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = Cell((values[j] if j >= 0 and j < len(values) else None))
                row.append(x)
            _this1 = self.table
            _this1.append(row)

    def toArray(self):
        array = []
        _g = 0
        _g1 = self.table
        while (_g < len(_g1)):
            row = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            arrRow = []
            _g2 = 0
            while (_g2 < len(row)):
                cell = (row[_g2] if _g2 >= 0 and _g2 < len(row) else None)
                _g2 = (_g2 + 1)
                x = cell.getValue()
                arrRow.append(x)
            array.append(arrRow)
        return array

    def fromMap(self,_hx_map):
        self.rows = _hx_map.h.get("rows",None)
        self.cols = _hx_map.h.get("cols",None)
        self.table = []
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _g2 = 0
            _g3 = self.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = Cell(_hx_map.h.get(((("row_" + Std.string(i)) + "_col_") + Std.string(j)),None))
                row.append(x)
            _this = self.table
            _this.append(row)

    def toMap(self):
        _hx_map = haxe_ds_StringMap()
        _hx_map.h["rows"] = self.rows
        _hx_map.h["cols"] = self.cols
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = self.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                value = python_internal_ArrayImpl._get((self.table[i] if i >= 0 and i < len(self.table) else None), j).getValue()
                _hx_map.h[((("row_" + Std.string(i)) + "_col_") + Std.string(j))] = value
        return _hx_map

    def fromObject(self,obj):
        self.rows = Reflect.field(obj,"rows")
        self.cols = Reflect.field(obj,"cols")
        self.table = []
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            row = []
            _g2 = 0
            _g3 = self.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = Cell(HxOverrides.arrayGet(obj, self.arrayStack(((("row_" + Std.string(i)) + "_col_") + Std.string(j)))))
                row.append(x)
            _this = self.table
            _this.append(row)

    def toObject(self):
        obj = _hx_AnonObject({'rows': self.rows, 'cols': self.cols})
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = self.cols
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                HxOverrides.arraySet(obj,self.arrayStack(((("row_" + Std.string(i)) + "_col_") + Std.string(j))),python_internal_ArrayImpl._get((self.table[i] if i >= 0 and i < len(self.table) else None), j).getValue())
        return obj

    def arrayStack(self,index):
        return self.indexToArrayStack(self.getIndexFromString(index))

    def getIndexFromString(self,index):
        parts = index.split(",")
        return _hx_AnonObject({'row': Std.parseInt((parts[0] if 0 < len(parts) else None)), 'col': Std.parseInt((parts[1] if 1 < len(parts) else None))})

    def indexToArrayStack(self,ind):
        return python_internal_ArrayImpl._get([Std.parseInt(Reflect.field(ind,"row"))], Std.parseInt(Reflect.field(ind,"col")))

    def getValueFromStringIndex(self,index):
        parts = index.split("_")
        row = Std.parseInt((parts[1] if 1 < len(parts) else None))
        col = Std.parseInt((parts[3] if 3 < len(parts) else None))
        return python_internal_ArrayImpl._get((self.table[row] if row >= 0 and row < len(self.table) else None), col).getValue()

    def getValueFromSecondaryArray(self,index,secondaryArray):
        parts = index.split("_")
        row = Std.parseInt((parts[1] if 1 < len(parts) else None))
        col = Std.parseInt((parts[3] if 3 < len(parts) else None))
        return python_internal_ArrayImpl._get((secondaryArray[row] if row >= 0 and row < len(secondaryArray) else None), col)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.table = None
        _hx_o.rows = None
        _hx_o.cols = None
HTable._hx_class = HTable
_hx_classes["HTable"] = HTable


class Table:
    _hx_class_name = "Table"
    __slots__ = ()
    _hx_statics = ["create", "createH", "createCell", "createCellArray", "createCellArrayFromStrings", "createCellArrayFromObjects", "createCellArrayFromMaps", "createCellArrayFromArrays", "createCellArrayFromCells", "modifyCell"]

    @staticmethod
    def create(rows,cols):
        return DTable(rows,cols)

    @staticmethod
    def createH(rows,cols):
        return HTable(rows,cols)

    @staticmethod
    def createCell(value):
        return Cell(value)

    @staticmethod
    def createCellArray(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value)
            cells.append(x)
        return cells

    @staticmethod
    def createCellArrayFromStrings(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value)
            cells.append(x)
        return cells

    @staticmethod
    def createCellArrayFromObjects(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value)
            cells.append(x)
        return cells

    @staticmethod
    def createCellArrayFromMaps(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value)
            cells.append(x)
        return cells

    @staticmethod
    def createCellArrayFromArrays(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value)
            cells.append(x)
        return cells

    @staticmethod
    def createCellArrayFromCells(values):
        cells = []
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            x = Cell(value.getValue())
            cells.append(x)
        return cells

    @staticmethod
    def modifyCell(cell,value):
        cell.setValue(value)
Table._hx_class = Table
_hx_classes["Table"] = Table

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getEnum", "getSuperClass", "getClassName", "resolveClass", "createEmptyInstance", "createEnum", "getEnumConstructs", "typeof", "enumEq"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getEnum(o):
        if (o is None):
            return None
        return o.__class__

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise haxe_Exception.thrown(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True
Type._hx_class = Type
_hx_classes["Type"] = Type


class yutautil_ExtendedDate:
    _hx_class_name = "yutautil.ExtendedDate"
    __slots__ = ("dateAccess",)
    _hx_fields = ["dateAccess"]
    _hx_methods = ["getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes", "getSeconds", "getTime", "isMonth", "isDay", "isWeekend", "isWeekday", "asString", "getDaysInMonth", "getDaysInYear", "getDaysLeftInMonth", "getDaysLeftInYear", "getDayOfYear", "getWeekOfYear", "getWeekOfMonth", "getWeeksLeftInYear", "getWeeksLeftInMonth", "today", "tomorrow", "yesterday", "time", "formatDate", "isLeapYear"]
    _hx_statics = ["date", "createDate", "newDate", "fromDate", "fromDateType", "getMonthByName", "getDayByName", "getMonthNumber", "getDayNumber", "getMonthByNumber", "getDayByNumber", "exactTimeNow", "calcImpossibleDate", "fromString", "formatDateObject"]

    def __init__(self,year,month,day,hour = None,minute = None,second = None):
        if (hour is None):
            hour = 0
        if (minute is None):
            minute = 0
        if (second is None):
            second = 0
        if (yutautil_ExtendedDate.date is None):
            yutautil_ExtendedDate.date = Date.now()
            haxe_Log.trace("Initializing date...",_hx_AnonObject({'fileName': "src/yutautil/ExtendedDate.hx", 'lineNumber': 43, 'className': "yutautil.ExtendedDate", 'methodName': "new"}))
        self.dateAccess = yutautil_ExtendedDate.date
        haxe_Log.trace(("It is currently " + Std.string(self.dateAccess)),_hx_AnonObject({'fileName': "src/yutautil/ExtendedDate.hx", 'lineNumber': 47, 'className': "yutautil.ExtendedDate", 'methodName': "new"}))

    def getFullYear(self):
        return Reflect.field(self.dateAccess,"getFullYear")()

    def getMonth(self):
        return Reflect.field(self.dateAccess,"getMonth")()

    def getDate(self):
        return Reflect.field(self.dateAccess,"getDate")()

    def getDay(self):
        return Reflect.field(self.dateAccess,"getDay")()

    def getHours(self):
        return Reflect.field(self.dateAccess,"getHours")()

    def getMinutes(self):
        return Reflect.field(self.dateAccess,"getMinutes")()

    def getSeconds(self):
        return Reflect.field(self.dateAccess,"getSeconds")()

    def getTime(self):
        return Reflect.field(self.dateAccess,"getTime")()

    def isMonth(self,month):
        return (self.getMonth() == month.index)

    def isDay(self,day):
        return (self.getDay() == day.index)

    def isWeekend(self):
        if (not self.isDay(yutautil_Day.Saturday)):
            return self.isDay(yutautil_Day.Sunday)
        else:
            return True

    def isWeekday(self):
        return (not self.isWeekend())

    def asString(self):
        return self.formatDate("%Y-%m-%d %H:%M:%S")

    def getDaysInMonth(self):
        month = self.getMonth()
        if (month == 1):
            if self.isLeapYear():
                return 29
            else:
                return 28
        elif ((((month == 3) or ((month == 5))) or ((month == 8))) or ((month == 10))):
            return 30
        else:
            return 31

    def getDaysInYear(self):
        if self.isLeapYear():
            return 366
        else:
            return 365

    def getDaysLeftInMonth(self):
        return (self.getDaysInMonth() - self.getDate())

    def getDaysLeftInYear(self):
        return (self.getDaysInYear() - self.getDayOfYear())

    def getDayOfYear(self):
        dayOfYear = 0
        _g = 0
        _g1 = self.getMonth()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            dayOfYear = (dayOfYear + yutautil_ExtendedDate(self.getFullYear(),i,1).getDaysInMonth())
        return (dayOfYear + self.getDate())

    def getWeekOfYear(self):
        firstDay = yutautil_ExtendedDate(self.getFullYear(),0,1)
        diff = (self.getTime() - firstDay.getTime())
        return Math.ceil((diff / 604800000))

    def getWeekOfMonth(self):
        return Math.ceil((self.getDate() / 7))

    def getWeeksLeftInYear(self):
        return (52 - self.getWeekOfYear())

    def getWeeksLeftInMonth(self):
        return Math.ceil((self.getDaysLeftInMonth() / 7))

    def today(self):
        return yutautil_ExtendedDate(self.getFullYear(),self.getMonth(),self.getDate())

    def tomorrow(self):
        return yutautil_ExtendedDate(self.getFullYear(),self.getMonth(),(self.getDate() + 1))

    def yesterday(self):
        return yutautil_ExtendedDate(self.getFullYear(),self.getMonth(),(self.getDate() - 1))

    def time(self):
        return self.formatDate("%H:%M:%S")

    def formatDate(self,format):
        formatted = format
        formatted = StringTools.replace(formatted,"%Y",("" + Std.string(self.getFullYear())))
        formatted = StringTools.replace(formatted,"%m",StringTools.lpad(("" + Std.string(((self.getMonth() + 1)))),"0",2))
        formatted = StringTools.replace(formatted,"%d",StringTools.lpad(("" + Std.string(self.getDate())),"0",2))
        formatted = StringTools.replace(formatted,"%H",StringTools.lpad(("" + Std.string(self.getHours())),"0",2))
        formatted = StringTools.replace(formatted,"%M",StringTools.lpad(("" + Std.string(self.getMinutes())),"0",2))
        formatted = StringTools.replace(formatted,"%S",StringTools.lpad(("" + Std.string(self.getSeconds())),"0",2))
        return formatted

    def isLeapYear(self):
        year = self.getFullYear()
        if (not (((HxOverrides.mod(year, 4) == 0) and ((HxOverrides.mod(year, 100) != 0))))):
            return (HxOverrides.mod(year, 400) == 0)
        else:
            return True
    date = None

    @staticmethod
    def createDate(_hx_type,now,_construct):
        if now:
            if (_hx_type == Date):
                return Date.now()
            else:
                return yutautil_ExtendedDate.newDate()
        elif ((((_construct is not None) and ((_construct.year is not None))) and ((_construct.month is not None))) and ((_construct.day is not None))):
            if (_hx_type == Date):
                return Date(_construct.year,_construct.month,_construct.day,Reflect.field(_construct,"hour"),Reflect.field(_construct,"minute"),Reflect.field(_construct,"second"))
            else:
                return yutautil_ExtendedDate(_construct.year,_construct.month,_construct.day,Reflect.field(_construct,"hour"),Reflect.field(_construct,"minute"),Reflect.field(_construct,"second"))
        elif (_hx_type == Date):
            return Date.now()
        else:
            return yutautil_ExtendedDate.newDate()

    @staticmethod
    def newDate():
        return yutautil_ExtendedDate.fromDate(Date.now())

    @staticmethod
    def fromDate(date):
        return yutautil_ExtendedDate(date.date.year,(date.date.month - 1),date.date.day,date.date.hour,date.date.minute,date.date.second)

    @staticmethod
    def fromDateType(date):
        date1 = date
        return yutautil_ExtendedDate(Reflect.field(date1,"getFullYear")(),Reflect.field(date1,"getMonth")(),Reflect.field(date1,"getDate")(),Reflect.field(date1,"getHours")(),Reflect.field(date1,"getMinutes")(),Reflect.field(date1,"getSeconds")())

    @staticmethod
    def getMonthByName(name):
        _g = name.lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 9):
            if (_g == "september"):
                return yutautil_Month.September
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 5):
            if (_g == "april"):
                return yutautil_Month.April
            elif (_g == "march"):
                return yutautil_Month.March
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 4):
            if (_g == "july"):
                return yutautil_Month.July
            elif (_g == "june"):
                return yutautil_Month.June
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 7):
            if (_g == "january"):
                return yutautil_Month.January
            elif (_g == "october"):
                return yutautil_Month.October
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 3):
            if (_g == "may"):
                return yutautil_Month.May
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 8):
            if (_g == "december"):
                return yutautil_Month.December
            elif (_g == "february"):
                return yutautil_Month.February
            elif (_g == "november"):
                return yutautil_Month.November
            else:
                raise haxe_Exception.thrown("Invalid month name")
        elif (_hx_local_0 == 6):
            if (_g == "august"):
                return yutautil_Month.August
            else:
                raise haxe_Exception.thrown("Invalid month name")
        else:
            raise haxe_Exception.thrown("Invalid month name")

    @staticmethod
    def getDayByName(name):
        _g = name.lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 9):
            if (_g == "wednesday"):
                return yutautil_Day.Wednesday
            else:
                raise haxe_Exception.thrown("Invalid day name")
        elif (_hx_local_0 == 7):
            if (_g == "tuesday"):
                return yutautil_Day.Tuesday
            else:
                raise haxe_Exception.thrown("Invalid day name")
        elif (_hx_local_0 == 8):
            if (_g == "saturday"):
                return yutautil_Day.Saturday
            elif (_g == "thursday"):
                return yutautil_Day.Thursday
            else:
                raise haxe_Exception.thrown("Invalid day name")
        elif (_hx_local_0 == 6):
            if (_g == "friday"):
                return yutautil_Day.Friday
            elif (_g == "monday"):
                return yutautil_Day.Monday
            elif (_g == "sunday"):
                return yutautil_Day.Sunday
            else:
                raise haxe_Exception.thrown("Invalid day name")
        else:
            raise haxe_Exception.thrown("Invalid day name")

    @staticmethod
    def getMonthNumber(month):
        return month.index

    @staticmethod
    def getDayNumber(day):
        return day.index

    @staticmethod
    def getMonthByNumber(number):
        _g = (number - 1)
        if (_g == 0):
            return yutautil_Month.January
        elif (_g == 1):
            return yutautil_Month.February
        elif (_g == 2):
            return yutautil_Month.March
        elif (_g == 3):
            return yutautil_Month.April
        elif (_g == 4):
            return yutautil_Month.May
        elif (_g == 5):
            return yutautil_Month.June
        elif (_g == 6):
            return yutautil_Month.July
        elif (_g == 7):
            return yutautil_Month.August
        elif (_g == 8):
            return yutautil_Month.September
        elif (_g == 9):
            return yutautil_Month.October
        elif (_g == 10):
            return yutautil_Month.November
        elif (_g == 11):
            return yutautil_Month.December
        else:
            raise haxe_Exception.thrown("Invalid month number")

    @staticmethod
    def getDayByNumber(number):
        _g = (number - 1)
        if (_g == 0):
            return yutautil_Day.Sunday
        elif (_g == 1):
            return yutautil_Day.Monday
        elif (_g == 2):
            return yutautil_Day.Tuesday
        elif (_g == 3):
            return yutautil_Day.Wednesday
        elif (_g == 4):
            return yutautil_Day.Thursday
        elif (_g == 5):
            return yutautil_Day.Friday
        elif (_g == 6):
            return yutautil_Day.Saturday
        else:
            raise haxe_Exception.thrown("Invalid day number")

    @staticmethod
    def exactTimeNow():
        return yutautil_ExtendedDate.fromDate(Date.now()).formatDate("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def calcImpossibleDate():
        return yutautil_ExtendedDate(0,0,0,0,0,0)

    @staticmethod
    def fromString(date,format):
        year = 0
        month = 0
        day = 0
        hour = 0
        minute = 0
        second = 0
        parts = list(format)
        values = list(date)
        _g = 0
        _g1 = len(parts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (parts[i] if i >= 0 and i < len(parts) else None)
            if (_g2 == "%H"):
                hour = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            elif (_g2 == "%M"):
                minute = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            elif (_g2 == "%S"):
                second = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            elif (_g2 == "%Y"):
                year = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            elif (_g2 == "%d"):
                day = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            elif (_g2 == "%m"):
                month = Std.parseInt((values[i] if i >= 0 and i < len(values) else None))
            else:
                pass
        return yutautil_ExtendedDate(year,month,day,hour,minute,second)

    @staticmethod
    def formatDateObject(date,format):
        date1 = date
        formatted = format
        formatted = StringTools.replace(formatted,"%Y",("" + Std.string(Reflect.field(date1,"getFullYear")())))
        formatted = StringTools.replace(formatted,"%m",StringTools.lpad(("" + Std.string(python_Boot._add_dynamic(Reflect.field(date1,"getMonth")(),1))),"0",2))
        formatted = StringTools.replace(formatted,"%d",StringTools.lpad(("" + Std.string(Reflect.field(date1,"getDate")())),"0",2))
        formatted = StringTools.replace(formatted,"%H",StringTools.lpad(("" + Std.string(Reflect.field(date1,"getHours")())),"0",2))
        formatted = StringTools.replace(formatted,"%M",StringTools.lpad(("" + Std.string(Reflect.field(date1,"getMinutes")())),"0",2))
        formatted = StringTools.replace(formatted,"%S",StringTools.lpad(("" + Std.string(Reflect.field(date1,"getSeconds")())),"0",2))
        return formatted

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dateAccess = None
yutautil_ExtendedDate._hx_class = yutautil_ExtendedDate
_hx_classes["yutautil.ExtendedDate"] = yutautil_ExtendedDate


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib
_hx_classes["python.Lib"] = python_Lib


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "_add_dynamic", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field1) if (hasattr(o,field1)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes["python.Boot"] = python_Boot


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "get_length", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes["HxString"] = HxString


class yutautil_CatagorizedMap:
    _hx_class_name = "yutautil.CatagorizedMap"
    __slots__ = ("map", "stuck", "allowDuplicates")
    _hx_fields = ["map", "stuck", "allowDuplicates"]
    _hx_methods = ["add", "remove", "get", "exists", "clear", "clearCategory", "removeCategory", "keys", "iterator", "next", "hasNext", "toString", "get_length", "set"]

    def __init__(self,cat = None,stuck = None):
        self.allowDuplicates = True
        self.stuck = False
        self.map = haxe_ds_StringMap()
        if (cat is not None):
            _g = 0
            while (_g < len(cat)):
                c = (cat[_g] if _g >= 0 and _g < len(cat) else None)
                _g = (_g + 1)
                self.map.h[c] = []
        tmp = None
        if ((stuck is not None) and ((self.map is not None))):
            input = self.map
            tmp1 = None
            if Std.isOfType(input,list):
                tmp1 = len(input)
            elif Std.isOfType(input,haxe_IMap):
                input1 = input
                tmp2 = None
                if Std.isOfType(input1,list):
                    tmp2 = input1
                elif Std.isOfType(input1,haxe_IMap):
                    result = []
                    key = input1.keys()
                    while key.hasNext():
                        key1 = key.next()
                        x = _hx_AnonObject({'key': key1, 'value': Reflect.field(input1,"get")(key1)})
                        result.append(x)
                    tmp2 = result
                elif (python_Boot.hasField(input1,"iterator") or ((python_Boot.hasField(input1,"hasNext") and python_Boot.hasField(input1,"next")))):
                    result = []
                    item = HxOverrides.iterator(input1)
                    while item.hasNext():
                        item1 = item.next()
                        result.append(item1)
                    tmp2 = result
                else:
                    tmp2 = [input1]
                tmp1 = len(tmp2)
            elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
                length = 0
                item = HxOverrides.iterator(input)
                while item.hasNext():
                    item1 = item.next()
                    length = (length + 1)
                tmp1 = length
            else:
                tmp1 = (Reflect.field(input,"length") if (Std.isOfType(input,str)) else 1)
            tmp = (tmp1 != 0)
        else:
            tmp = False
        if tmp:
            self.stuck = stuck

    def add(self,key,value):
        if (not (key in self.map.h)):
            self.map.h[key] = []
        _this = self.map.h.get(key,None)
        _this.append(value)

    def remove(self,key,value):
        if (not (key in self.map.h)):
            return False
        arr = self.map.h.get(key,None)
        index = python_internal_ArrayImpl.indexOf(arr,value,None)
        if (index == -1):
            return False
        pos = index
        if (pos < 0):
            pos = (len(arr) + pos)
        if (pos < 0):
            pos = 0
        res = arr[pos:(pos + 1)]
        del arr[pos:(pos + 1)]
        return True

    def get(self,key):
        if (not (key in self.map.h)):
            return []
        return self.map.h.get(key,None)

    def exists(self,key):
        return (key in self.map.h)

    def clear(self):
        self.map = haxe_ds_StringMap()

    def clearCategory(self,key):
        if (key in self.map.h):
            self.map.h[key] = []

    def removeCategory(self,key):
        return self.map.remove(key)

    def keys(self):
        return self.map.keys()

    def iterator(self):
        return haxe_iterators_MapKeyValueIterator(self.map)

    def next(self):
        _hx_map = self.map
        inlMapKeyValueIterator_map = _hx_map
        inlMapKeyValueIterator_keys = _hx_map.keys()
        key = inlMapKeyValueIterator_keys.next()
        return _hx_AnonObject({'value': inlMapKeyValueIterator_map.get(key), 'key': key})

    def hasNext(self):
        _hx_map = self.map
        inlMapKeyValueIterator_map = _hx_map
        inlMapKeyValueIterator_keys = _hx_map.keys()
        return inlMapKeyValueIterator_keys.hasNext()

    def toString(self):
        result_b = python_lib_io_StringIO()
        key = self.map.keys()
        while key.hasNext():
            key1 = key.next()
            _this = self.map.h.get(key1,None)
            result_b.write(Std.string((((("null" if key1 is None else key1) + ": ") + HxOverrides.stringOrNull(((("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + "]")))) + "\n")))
        return result_b.getvalue()

    def get_length(self):
        input = self.map
        if Std.isOfType(input,list):
            return len(input)
        elif Std.isOfType(input,haxe_IMap):
            input1 = input
            tmp = None
            if Std.isOfType(input1,list):
                tmp = input1
            elif Std.isOfType(input1,haxe_IMap):
                result = []
                key = input1.keys()
                while key.hasNext():
                    key1 = key.next()
                    x = _hx_AnonObject({'key': key1, 'value': Reflect.field(input1,"get")(key1)})
                    result.append(x)
                tmp = result
            elif (python_Boot.hasField(input1,"iterator") or ((python_Boot.hasField(input1,"hasNext") and python_Boot.hasField(input1,"next")))):
                result = []
                item = HxOverrides.iterator(input1)
                while item.hasNext():
                    item1 = item.next()
                    result.append(item1)
                tmp = result
            else:
                tmp = [input1]
            return len(tmp)
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            length = 0
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                length = (length + 1)
            return length
        elif Std.isOfType(input,str):
            return Reflect.field(input,"length")
        else:
            return 1

    def set(self,key,value):
        self.map.h[key] = value
        return value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.stuck = None
        _hx_o.allowDuplicates = None
yutautil_CatagorizedMap._hx_class = yutautil_CatagorizedMap
_hx_classes["yutautil.CatagorizedMap"] = yutautil_CatagorizedMap


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "set", "keys"]
haxe_IMap._hx_class = haxe_IMap
_hx_classes["haxe.IMap"] = haxe_IMap


class YutaUtil:
    _hx_class_name = "YutaUtil"
    __slots__ = ()
    _hx_statics = ["date", "services", "main", "getServices", "getVariable", "runHaxeFunction", "makeServiceInstance"]

    @staticmethod
    def main():
        haxe_Log.trace("Hello, world!",_hx_AnonObject({'fileName': "src/YutaUtil.hx", 'lineNumber': 24, 'className': "YutaUtil", 'methodName': "main"}))
        chance = yutautil_CatagorizedMap(["a", "b", "c"],True)
        SomeWeirdShit = yutautil_save_MixSaveWrapper.newMix()
        code = "function() {\n\treturn 1 + 2;\n}"
        haxe_Log.trace(code,_hx_AnonObject({'fileName': "src/YutaUtil.hx", 'lineNumber': 31, 'className': "YutaUtil", 'methodName': "main"}))
        YutaUtil.services.add("Var",backend_modules_Variable)
        YutaUtil.services.add("HaxeFunc",yutautil_save_FuncEmbed)
        YutaUtil.services.add("Class",Type.getClass(Dynamic))
        YutaUtil.services.add("Thread",backend_Threader)
        YutaUtil.services.add("Date",yutautil_ExtendedDate)
        YutaUtil.services.add("Map",yutautil_CatagorizedMap)
        YutaUtil.services.add("Save",yutautil_save_MixSaveWrapper)
        YutaUtil.services.add("Chance",yutautil_ChanceSelector)
        YutaUtil.services.add("Math",backend_modules_MathSolver2)
        YutaUtil.services.add("Event",backend_modules_EventFunc)
        YutaUtil.services.add("Table",Table)
        YutaUtil.services.add("Table",DTable)
        YutaUtil.services.add("Table",HTable)
        haxe_Log.trace(yutautil_save_FuncEmbed.runFunctionFromString(code,_hx_AnonObject({}),True),_hx_AnonObject({'fileName': "src/YutaUtil.hx", 'lineNumber': 60, 'className': "YutaUtil", 'methodName': "main"}))

    @staticmethod
    def getServices():
        return YutaUtil.services

    @staticmethod
    def getVariable(value):
        def _hx_local_1():
            def _hx_local_0():
                return value
            return backend_modules_Variable(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def runHaxeFunction(func,context):
        return yutautil_save_FuncEmbed.runFunctionFromString(func,_hx_AnonObject({'context': context}),True)

    @staticmethod
    def makeServiceInstance(serviceName,args = None):
        service = python_internal_ArrayImpl._get(YutaUtil.services.get(serviceName), 0)
        return service(*([] if ((args is None)) else args))
YutaUtil._hx_class = YutaUtil
_hx_classes["YutaUtil"] = YutaUtil


class backend_Threader:
    _hx_class_name = "backend.Threader"
    __slots__ = ()
    _hx_statics = ["threadQueue", "specialThreads", "quietThreads", "baked", "usedthreads", "generatedThreads", "bakedThreads", "stringRandomizer", "waitForThreads", "waitForThread"]
    threadQueue = None
    baked = None

    @staticmethod
    def stringRandomizer(length):
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        _hx_str = ""
        _g = 0
        _g1 = length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = Math.floor((python_lib_Random.random() * len(chars)))
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(("" if (((index < 0) or ((index >= len(chars))))) else chars[index])))
        return _hx_str

    @staticmethod
    def waitForThreads():
        while (len(backend_Threader.quietThreads) > 0):
            pass

    @staticmethod
    def waitForThread(name):
        if (python_internal_ArrayImpl.indexOf(backend_Threader.quietThreads,name,None) == -1):
            haxe_Log.trace((("Thread " + ("null" if name is None else name)) + " does not exist."),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 175, 'className': "backend.Threader", 'methodName': "waitForThread"}))
            return
        haxe_Log.trace(("Waiting for thread: " + ("null" if name is None else name)),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 178, 'className': "backend.Threader", 'methodName': "waitForThread"}))
        while (python_internal_ArrayImpl.indexOf(backend_Threader.quietThreads,name,None) != -1):
            pass
        haxe_Log.trace((("Freedom! Thread " + ("null" if name is None else name)) + " has finished, or ceased to exist."),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 182, 'className': "backend.Threader", 'methodName': "waitForThread"}))
backend_Threader._hx_class = backend_Threader
_hx_classes["backend.Threader"] = backend_Threader


class backend_ThreadQueue:
    _hx_class_name = "backend.ThreadQueue"
    __slots__ = ("queue", "maxConcurrent", "running", "blockUntilFinished", "done")
    _hx_fields = ["queue", "maxConcurrent", "running", "blockUntilFinished", "done"]
    _hx_methods = ["get_length", "run", "toString", "add", "softAdd", "preloadMulti", "preload", "addFunction", "addFunctions", "processQueue", "waitUntilFinished", "kill", "reset"]
    _hx_statics = ["create"]

    def __init__(self,maxConcurrent = None,blockUntilFinished = None):
        if (maxConcurrent is None):
            maxConcurrent = 1
        if (blockUntilFinished is None):
            blockUntilFinished = False
        self.done = True
        self.queue = []
        self.maxConcurrent = maxConcurrent
        self.running = 0
        self.blockUntilFinished = blockUntilFinished

    def get_length(self):
        return len(self.queue)

    def run(self):
        if (not self.done):
            haxe_Log.trace(("Attempted a thread queue run while already running a queue in " + Std.string(self)),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 227, 'className': "backend.ThreadQueue", 'methodName': "run"}))
            return
        if (len(self.queue) == 0):
            haxe_Log.trace("Attempted a thread queue run with no threads available.",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 231, 'className': "backend.ThreadQueue", 'methodName': "run"}))
        self.processQueue()

    def toString(self):
        return ((((((("ThreadQueue: " + Std.string(len(self.queue))) + " functions in queue, ") + Std.string(self.running)) + " functions running, maxConcurrent: ") + Std.string(self.maxConcurrent)) + ", blockUntilFinished: ") + Std.string(self.blockUntilFinished))

    def add(self,func):
        self.addFunction(func)

    def softAdd(self,func):
        _gthis = self
        if (self.running < self.maxConcurrent):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.running
            _hx_local_0.running = (_hx_local_1 + 1)
            _hx_local_1
            def _hx_local_3():
                func()
                _gthis.running = (_gthis.running - 1)
                _gthis.processQueue()
            sys_thread__Thread_HxThread.create(_hx_local_3,False)
        else:
            _this = self.queue
            _this.append(func)

    def preloadMulti(self,funcs):
        _g = 0
        while (_g < len(funcs)):
            func = (funcs[_g] if _g >= 0 and _g < len(funcs) else None)
            _g = (_g + 1)
            _this = self.queue
            _this.append(func)

    def preload(self,func):
        _this = self.queue
        _this.append(func)

    def addFunction(self,func):
        _this = self.queue
        _this.append(func)
        self.processQueue()

    def addFunctions(self,funcs):
        _g = 0
        while (_g < len(funcs)):
            func = (funcs[_g] if _g >= 0 and _g < len(funcs) else None)
            _g = (_g + 1)
            _this = self.queue
            _this.append(func)
        self.processQueue()

    def processQueue(self):
        _gthis = self
        if (self.done and ((len(self.queue) > 0))):
            self.done = False
            haxe_Log.trace("Processing queue...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 330, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
        while ((self.running < self.maxConcurrent) and ((len(self.queue) > 0))):
            _this = self.queue
            func = [(None if ((len(_this) == 0)) else _this.pop(0))]
            if ((func[0] if 0 < len(func) else None) is None):
                haxe_Log.trace("Encountered a null function in the queue. Skipping...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 335, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
                continue
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.running
            _hx_local_0.running = (_hx_local_1 + 1)
            _hx_local_1
            def _hx_local_4(func):
                def _hx_local_2():
                    try:
                        (func[0] if 0 < len(func) else None)()
                    except BaseException as _g:
                        None
                        e = haxe_Exception.caught(_g).unwrap()
                        haxe_Log.trace(((("Exception in thread function: " + Std.string(e)) + " ... ") + HxOverrides.stringOrNull(haxe__CallStack_CallStack_Impl_.toString(haxe__CallStack_CallStack_Impl_.exceptionStack()))),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 346, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
                    _gthis.running = (_gthis.running - 1)
                    _gthis.processQueue()
                return _hx_local_2
            try:
                sys_thread__Thread_HxThread.create(_hx_local_4(func),False)
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                haxe_Log.trace(("Failed to create thread: " + Std.string(e)),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 352, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.running
                _hx_local_5.running = (_hx_local_6 - 1)
                _hx_local_6
        while (((self.blockUntilFinished and ((len(self.queue) == 0))) and ((self.running == 0))) and (not self.done)):
            haxe_Log.trace("All functions are finished.",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 359, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
            self.done = True
        if ((len(self.queue) == 0) and ((self.running == 0))):
            haxe_Log.trace("Queue is empty.",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 363, 'className': "backend.ThreadQueue", 'methodName': "processQueue"}))
            self.done = True

    def waitUntilFinished(self):
        while (((len(self.queue) == 0) or ((self.running == 0))) or (not self.done)):
            pass

    def kill(self):
        self.queue = []
        self.running = 0
        self.done = True

    def reset(self,autoStart = None):
        newQ = list(self.queue)
        self.kill()
        self.queue = newQ
        if autoStart:
            self.run()
        self.processQueue()

    @staticmethod
    def create(maxConcurrent = None,blockUntilFinished = None):
        if (maxConcurrent is None):
            maxConcurrent = 1
        if (blockUntilFinished is None):
            blockUntilFinished = False
        return backend_ThreadQueue(maxConcurrent,blockUntilFinished)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.queue = None
        _hx_o.maxConcurrent = None
        _hx_o.running = None
        _hx_o.blockUntilFinished = None
        _hx_o.done = None
backend_ThreadQueue._hx_class = backend_ThreadQueue
_hx_classes["backend.ThreadQueue"] = backend_ThreadQueue


class backend_MemLimitThreadQ:
    _hx_class_name = "backend.MemLimitThreadQ"
    __slots__ = ("queue", "items", "action", "limit", "hasty")
    _hx_fields = ["queue", "items", "action", "limit", "hasty"]
    _hx_methods = ["get_running", "get_length", "get_queueLength", "preloadItems", "run", "autoAddMoreItems", "addMoreItems"]
    _hx_statics = ["create"]

    def __init__(self,items,action,limit,hasty = None,hijackQueue = None):
        self.queue = (hijackQueue if ((hijackQueue is not None)) else backend_ThreadQueue(limit,False))
        self.items = items
        self.action = action
        self.limit = limit
        self.hasty = ((hasty is not None) and hasty)
        haxe_Log.trace(((((("Creating MemLimitThreadQ with " + Std.string(len(items))) + " items, limit: ") + Std.string(limit)) + ", hasty: ") + Std.string(hasty)),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 450, 'className': "backend.MemLimitThreadQ", 'methodName': "new"}))
        self.preloadItems()
        if ((hijackQueue is not None) and ((((not hijackQueue.done) or ((hijackQueue.get_length() != 0))) or ((hijackQueue.running != 0))))):
            haxe_Log.trace("Queue is already processing. Hooking into it...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 453, 'className': "backend.MemLimitThreadQ", 'methodName': "new"}))
            self.run()

    def get_running(self):
        return self.queue.running

    def get_length(self):
        return len(self.items)

    def get_queueLength(self):
        return self.queue.get_length()

    def preloadItems(self):
        _gthis = self
        while ((len(self.items) > 0) and ((self.queue.get_length() < self.limit))):
            _this = self.items
            item = [(None if ((len(_this) == 0)) else _this.pop(0))]
            if self.hasty:
                def _hx_local_1(item):
                    def _hx_local_0():
                        _gthis.action((item[0] if 0 < len(item) else None))
                    return _hx_local_0
                self.queue.softAdd(_hx_local_1(item))
            else:
                def _hx_local_3(item):
                    def _hx_local_2():
                        _gthis.action((item[0] if 0 < len(item) else None))
                    return _hx_local_2
                self.queue.add(_hx_local_3(item))

    def run(self):
        if self.queue.done:
            self.queue.run()
        self.autoAddMoreItems()

    def autoAddMoreItems(self):
        _gthis = self
        haxe_Log.trace("Auto-Allocation started...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 490, 'className': "backend.MemLimitThreadQ", 'methodName': "autoAddMoreItems"}))
        def _hx_local_4():
            while (len(_gthis.items) > 0):
                if ((_gthis.queue.get_length() < _gthis.limit) and ((len(_gthis.items) > 0))):
                    _this = _gthis.items
                    item = [(None if ((len(_this) == 0)) else _this.pop(0))]
                    if _gthis.hasty:
                        def _hx_local_1(item):
                            def _hx_local_0():
                                _gthis.action((item[0] if 0 < len(item) else None))
                            return _hx_local_0
                        _gthis.queue.softAdd(_hx_local_1(item))
                    else:
                        def _hx_local_3(item):
                            def _hx_local_2():
                                _gthis.action((item[0] if 0 < len(item) else None))
                            return _hx_local_2
                        _gthis.queue.add(_hx_local_3(item))
                    if (_gthis.queue.done and ((_gthis.queue.get_length() != 0))):
                        haxe_Log.trace("Queue has emptied... Running...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 501, 'className': "backend.MemLimitThreadQ", 'methodName': "autoAddMoreItems"}))
                        _gthis.queue.run()
            haxe_Log.trace("Ended allocation of items.",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 507, 'className': "backend.MemLimitThreadQ", 'methodName': "autoAddMoreItems"}))
            if (_gthis.queue.done and ((_gthis.queue.get_length() != 0))):
                haxe_Log.trace("Queue has emptied... Running...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 509, 'className': "backend.MemLimitThreadQ", 'methodName': "autoAddMoreItems"}))
                _gthis.queue.run()
        sys_thread__Thread_HxThread.create(_hx_local_4,False)

    def addMoreItems(self,newItems):
        self.items = (self.items + newItems)
        self.autoAddMoreItems()

    @staticmethod
    def create(items,action,limit,hasty = None):
        return backend_MemLimitThreadQ(items,action,limit,hasty)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.queue = None
        _hx_o.items = None
        _hx_o.action = None
        _hx_o.limit = None
        _hx_o.hasty = None
backend_MemLimitThreadQ._hx_class = backend_MemLimitThreadQ
_hx_classes["backend.MemLimitThreadQ"] = backend_MemLimitThreadQ


class backend_ThreadChecker:
    _hx_class_name = "backend.ThreadChecker"
    __slots__ = ()
    _hx_statics = ["containsWaitForThreads"]

    @staticmethod
    def containsWaitForThreads(expr):
        _g = expr.expr
        tmp = _g.index
        if (tmp == 7):
            _g1 = _g.params[1]
            e = _g.params[0]
            _g1 = e.expr
            if (_g1.index == 3):
                _g2 = _g1.params[0]
                _g2 = _g1.params[2]
                if (_g1.params[1] == "waitForThreads"):
                    return True
                else:
                    return False
            else:
                return False
        elif (tmp == 12):
            exprs = _g.params[0]
            _g = 0
            while (_g < len(exprs)):
                e = (exprs[_g] if _g >= 0 and _g < len(exprs) else None)
                _g = (_g + 1)
                if backend_ThreadChecker.containsWaitForThreads(e):
                    return True
            return False
        else:
            return False
backend_ThreadChecker._hx_class = backend_ThreadChecker
_hx_classes["backend.ThreadChecker"] = backend_ThreadChecker


class backend_PatientThreadQueue(backend_ThreadQueue):
    _hx_class_name = "backend.PatientThreadQueue"
    __slots__ = ("waiting", "curQueue")
    _hx_fields = ["waiting", "curQueue"]
    _hx_methods = ["processQueue"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = backend_ThreadQueue


    def __init__(self,maxConcurrent = None,blockUntilFinished = None):
        if (maxConcurrent is None):
            maxConcurrent = 1
        if (blockUntilFinished is None):
            blockUntilFinished = False
        self.curQueue = []
        self.waiting = False
        super().__init__(maxConcurrent,blockUntilFinished)

    def processQueue(self):
        _gthis = self
        if (self.done and ((len(self.queue) > 0))):
            self.done = False
            haxe_Log.trace("Processing queue...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 589, 'className': "backend.PatientThreadQueue", 'methodName': "processQueue"}))
        while ((len(self.queue) > 0) or ((len(self.curQueue) > 0))):
            if (len(self.curQueue) == 0):
                _g = 0
                _g1 = self.maxConcurrent
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    if (len(self.queue) > 0):
                        _this = self.queue
                        func = (None if ((len(_this) == 0)) else _this.pop(0))
                        if (func is not None):
                            _this1 = self.curQueue
                            _this1.append(func)
            while (len(self.curQueue) > 0):
                _this2 = self.curQueue
                func1 = [(None if ((len(_this2) == 0)) else _this2.pop(0))]
                if ((func1[0] if 0 < len(func1) else None) is None):
                    haxe_Log.trace("Encountered a null function in the curQueue. Skipping...",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 606, 'className': "backend.PatientThreadQueue", 'methodName': "processQueue"}))
                    continue
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.running
                _hx_local_0.running = (_hx_local_1 + 1)
                _hx_local_1
                def _hx_local_4(func):
                    def _hx_local_2():
                        try:
                            (func[0] if 0 < len(func) else None)()
                        except BaseException as _g:
                            None
                            e = haxe_Exception.caught(_g).unwrap()
                            haxe_Log.trace(((("Exception in thread function: " + Std.string(e)) + " ... ") + HxOverrides.stringOrNull(haxe__CallStack_CallStack_Impl_.toString(haxe__CallStack_CallStack_Impl_.exceptionStack()))),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 615, 'className': "backend.PatientThreadQueue", 'methodName': "processQueue"}))
                        _gthis.running = (_gthis.running - 1)
                        _gthis.processQueue()
                    return _hx_local_2
                try:
                    sys_thread__Thread_HxThread.create(_hx_local_4(func1),False)
                except BaseException as _g2:
                    None
                    e = haxe_Exception.caught(_g2).unwrap()
                    haxe_Log.trace(("Failed to create thread: " + Std.string(e)),_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 621, 'className': "backend.PatientThreadQueue", 'methodName': "processQueue"}))
                    _hx_local_5 = self
                    _hx_local_6 = _hx_local_5.running
                    _hx_local_5.running = (_hx_local_6 - 1)
                    _hx_local_6
            if (((len(self.queue) == 0) and ((len(self.curQueue) == 0))) and ((self.running == 0))):
                haxe_Log.trace("Queue is empty.",_hx_AnonObject({'fileName': "src/backend/Threader.hx", 'lineNumber': 627, 'className': "backend.PatientThreadQueue", 'methodName': "processQueue"}))
                self.done = True
                self.waiting = False
                break

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.waiting = None
        _hx_o.curQueue = None
backend_PatientThreadQueue._hx_class = backend_PatientThreadQueue
_hx_classes["backend.PatientThreadQueue"] = backend_PatientThreadQueue

class backend_modules_EventType(Enum):
    __slots__ = ()
    _hx_class_name = "backend.modules.EventType"
    _hx_constructs = ["GreaterThan", "LessThan", "EqualTo", "Change"]

    @staticmethod
    def GreaterThan(value):
        return backend_modules_EventType("GreaterThan", 0, (value,))

    @staticmethod
    def LessThan(value):
        return backend_modules_EventType("LessThan", 1, (value,))

    @staticmethod
    def EqualTo(value):
        return backend_modules_EventType("EqualTo", 2, (value,))
backend_modules_EventType.Change = backend_modules_EventType("Change", 3, ())
backend_modules_EventType._hx_class = backend_modules_EventType
_hx_classes["backend.modules.EventType"] = backend_modules_EventType


class backend_modules_EventFunc:
    _hx_class_name = "backend.modules.EventFunc"
    __slots__ = ("eventName", "eventType", "watchedVariable", "func", "lastValue", "destroyOnTrigger")
    _hx_fields = ["eventName", "eventType", "watchedVariable", "func", "lastValue", "destroyOnTrigger"]
    _hx_methods = ["check", "execute", "update"]
    _hx_statics = ["instances", "updateAll", "destroyAll", "tracker", "objectToString"]

    def __init__(self,eventName,eventType,watchedVariable,func,destroyOnTrigger = None):
        if (destroyOnTrigger is None):
            destroyOnTrigger = True
        self.eventName = eventName
        self.eventType = eventType
        self.watchedVariable = watchedVariable
        self.func = func
        self.lastValue = Reflect.field(watchedVariable,"evaluate")()
        self.destroyOnTrigger = destroyOnTrigger
        haxe_Log.trace(("EventFunc created: " + ("null" if eventName is None else eventName)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 26, 'className': "backend.modules.EventFunc", 'methodName': "new"}))
        haxe_Log.trace(((((((((("Arguments: " + ("null" if eventName is None else eventName)) + ", ") + Std.string(eventType)) + ", ") + HxOverrides.stringOrNull(backend_modules_EventFunc.objectToString(watchedVariable))) + ", ") + Std.string(func)) + ", ") + Std.string(destroyOnTrigger)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 27, 'className': "backend.modules.EventFunc", 'methodName': "new"}))
        _this = backend_modules_EventFunc.instances
        _this.append(self)
        haxe_Log.trace(self.lastValue,_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 29, 'className': "backend.modules.EventFunc", 'methodName': "new"}))

    def check(self):
        currentValue = self.watchedVariable.evaluate()
        triggered = False
        _g = self.eventType
        tmp = _g.index
        if (tmp == 0):
            value = _g.params[0]
            if (Std.isOfType(currentValue,Float) and ((currentValue > value))):
                triggered = True
        elif (tmp == 1):
            value = _g.params[0]
            if (Std.isOfType(currentValue,Float) and ((currentValue < value))):
                triggered = True
        elif (tmp == 2):
            value = _g.params[0]
            if HxOverrides.eq(currentValue,value):
                triggered = True
        elif (tmp == 3):
            if not HxOverrides.eq(currentValue,self.lastValue):
                triggered = True
        else:
            pass
        if triggered:
            _gthis = self
            haxe_Log.trace(("Event triggered: " + HxOverrides.stringOrNull(self.eventName)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 66, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            haxe_Log.trace(("Event type: " + Std.string(self.eventType)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 67, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            haxe_Log.trace(("Executing function: " + HxOverrides.stringOrNull(backend_modules_EventFunc.objectToString(self.func))),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 68, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            self.func()
            if self.destroyOnTrigger:
                def _hx_local_0(e):
                    return (e != _gthis)
                backend_modules_EventFunc.instances = list(filter(_hx_local_0,backend_modules_EventFunc.instances))
                self.eventName = None
                self.eventType = None
                self.watchedVariable = None
                self.func = None
                self.lastValue = None
                self.destroyOnTrigger = None
            self.lastValue = currentValue
            return True
        self.lastValue = currentValue
        return False

    def execute(self):
        _gthis = self
        haxe_Log.trace(("Event triggered: " + HxOverrides.stringOrNull(self.eventName)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 66, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
        haxe_Log.trace(("Event type: " + Std.string(self.eventType)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 67, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
        haxe_Log.trace(("Executing function: " + HxOverrides.stringOrNull(backend_modules_EventFunc.objectToString(self.func))),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 68, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
        self.func()
        if self.destroyOnTrigger:
            def _hx_local_0(e):
                return (e != _gthis)
            backend_modules_EventFunc.instances = list(filter(_hx_local_0,backend_modules_EventFunc.instances))
            self.eventName = None
            self.eventType = None
            self.watchedVariable = None
            self.func = None
            self.lastValue = None
            self.destroyOnTrigger = None

    def update(self):
        currentValue = self.watchedVariable.evaluate()
        triggered = False
        _g = self.eventType
        tmp = _g.index
        if (tmp == 0):
            value = _g.params[0]
            if (Std.isOfType(currentValue,Float) and ((currentValue > value))):
                triggered = True
        elif (tmp == 1):
            value = _g.params[0]
            if (Std.isOfType(currentValue,Float) and ((currentValue < value))):
                triggered = True
        elif (tmp == 2):
            value = _g.params[0]
            if HxOverrides.eq(currentValue,value):
                triggered = True
        elif (tmp == 3):
            if not HxOverrides.eq(currentValue,self.lastValue):
                triggered = True
        else:
            pass
        if triggered:
            _gthis = self
            haxe_Log.trace(("Event triggered: " + HxOverrides.stringOrNull(self.eventName)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 66, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            haxe_Log.trace(("Event type: " + Std.string(self.eventType)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 67, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            haxe_Log.trace(("Executing function: " + HxOverrides.stringOrNull(backend_modules_EventFunc.objectToString(self.func))),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 68, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
            self.func()
            if self.destroyOnTrigger:
                def _hx_local_0(e):
                    return (e != _gthis)
                backend_modules_EventFunc.instances = list(filter(_hx_local_0,backend_modules_EventFunc.instances))
                self.eventName = None
                self.eventType = None
                self.watchedVariable = None
                self.func = None
                self.lastValue = None
                self.destroyOnTrigger = None
            self.lastValue = currentValue
        else:
            self.lastValue = currentValue

    @staticmethod
    def updateAll():
        _g = 0
        _g1 = backend_modules_EventFunc.instances
        while (_g < len(_g1)):
            instance = [(_g1[_g] if _g >= 0 and _g < len(_g1) else None)]
            _g = (_g + 1)
            try:
                currentValue = (instance[0] if 0 < len(instance) else None).watchedVariable.evaluate()
                triggered = False
                _g2 = (instance[0] if 0 < len(instance) else None).eventType
                tmp = _g2.index
                if (tmp == 0):
                    value = _g2.params[0]
                    if (Std.isOfType(currentValue,Float) and ((currentValue > value))):
                        triggered = True
                elif (tmp == 1):
                    value1 = _g2.params[0]
                    if (Std.isOfType(currentValue,Float) and ((currentValue < value1))):
                        triggered = True
                elif (tmp == 2):
                    value2 = _g2.params[0]
                    if HxOverrides.eq(currentValue,value2):
                        triggered = True
                elif (tmp == 3):
                    if not HxOverrides.eq(currentValue,(instance[0] if 0 < len(instance) else None).lastValue):
                        triggered = True
                else:
                    pass
                if triggered:
                    _gthis = [(instance[0] if 0 < len(instance) else None)]
                    haxe_Log.trace(("Event triggered: " + HxOverrides.stringOrNull((instance[0] if 0 < len(instance) else None).eventName)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 66, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
                    haxe_Log.trace(("Event type: " + Std.string((instance[0] if 0 < len(instance) else None).eventType)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 67, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
                    haxe_Log.trace(("Executing function: " + HxOverrides.stringOrNull(backend_modules_EventFunc.objectToString((instance[0] if 0 < len(instance) else None).func))),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 68, 'className': "backend.modules.EventFunc", 'methodName': "execute"}))
                    (instance[0] if 0 < len(instance) else None).func()
                    if (instance[0] if 0 < len(instance) else None).destroyOnTrigger:
                        _this = backend_modules_EventFunc.instances
                        def _hx_local_2(_gthis):
                            def _hx_local_1(e):
                                return (e != (_gthis[0] if 0 < len(_gthis) else None))
                            return _hx_local_1
                        backend_modules_EventFunc.instances = list(filter(_hx_local_2(_gthis),_this))
                        (instance[0] if 0 < len(instance) else None).eventName = None
                        (instance[0] if 0 < len(instance) else None).eventType = None
                        (instance[0] if 0 < len(instance) else None).watchedVariable = None
                        (instance[0] if 0 < len(instance) else None).func = None
                        (instance[0] if 0 < len(instance) else None).lastValue = None
                        (instance[0] if 0 < len(instance) else None).destroyOnTrigger = None
                    (instance[0] if 0 < len(instance) else None).lastValue = currentValue
                else:
                    (instance[0] if 0 < len(instance) else None).lastValue = currentValue
            except BaseException as _g3:
                None
                haxe_Log.trace((("Could not track variable for " + HxOverrides.stringOrNull((instance[0] if 0 < len(instance) else None).eventName)) + ". Could it be removed, or invalid?"),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 94, 'className': "backend.modules.EventFunc", 'methodName': "updateAll"}))
                haxe_Log.trace("Removing instance due to error",_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 95, 'className': "backend.modules.EventFunc", 'methodName': "updateAll"}))
                _this1 = backend_modules_EventFunc.instances
                def _hx_local_4(instance):
                    def _hx_local_3(e):
                        return (e != (instance[0] if 0 < len(instance) else None))
                    return _hx_local_3
                backend_modules_EventFunc.instances = list(filter(_hx_local_4(instance),_this1))
                (instance[0] if 0 < len(instance) else None).eventName = None
                (instance[0] if 0 < len(instance) else None).eventType = None
                (instance[0] if 0 < len(instance) else None).watchedVariable = None
                (instance[0] if 0 < len(instance) else None).func = None
                (instance[0] if 0 < len(instance) else None).lastValue = None
                (instance[0] if 0 < len(instance) else None).destroyOnTrigger = None

    @staticmethod
    def destroyAll():
        _g = 0
        _g1 = backend_modules_EventFunc.instances
        while (_g < len(_g1)):
            instance = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            instance = None
        backend_modules_EventFunc.instances = []
        haxe_Log.trace("All events destroyed",_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 115, 'className': "backend.modules.EventFunc", 'methodName': "destroyAll"}))

    @staticmethod
    def tracker(v):
        haxe_Log.trace(("Tracker called with value: " + Std.string(v)),_hx_AnonObject({'fileName': "src/backend/modules/EventFunc.hx", 'lineNumber': 119, 'className': "backend.modules.EventFunc", 'methodName': "tracker"}))
        return v

    @staticmethod
    def objectToString(funcVar):
        if Reflect.isFunction(funcVar):
            properties = []
            _g = 0
            _g1 = python_Boot.fields(funcVar)
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                value = Reflect.field(funcVar,field)
                x = ((("" + ("null" if field is None else field)) + ": ") + Std.string(value))
                properties.append(x)
            propertiesString = ", ".join([python_Boot.toString1(x1,'') for x1 in properties])
            return ("Function Variable" + HxOverrides.stringOrNull(((((" with properties { " + ("null" if propertiesString is None else propertiesString)) + " }") if ((len(properties) > 0)) else ""))))
        else:
            return "Not a Function Variable"

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.eventName = None
        _hx_o.eventType = None
        _hx_o.watchedVariable = None
        _hx_o.func = None
        _hx_o.lastValue = None
        _hx_o.destroyOnTrigger = None
backend_modules_EventFunc._hx_class = backend_modules_EventFunc
_hx_classes["backend.modules.EventFunc"] = backend_modules_EventFunc


class backend_modules_MathSolver2:
    _hx_class_name = "backend.modules.MathSolver2"
    __slots__ = ("variables",)
    _hx_fields = ["variables"]
    _hx_methods = ["evaluate", "setVariable", "replaceCustomOperators", "parse", "eval", "solveEquation"]

    def __init__(self):
        self.variables = haxe_ds_StringMap()

    def evaluate(self,expression):
        startIndex = None
        if (((expression.find("=") if ((startIndex is None)) else HxString.indexOfImpl(expression,"=",startIndex))) > -1):
            return self.solveEquation(expression)
        variable = self.variables.keys()
        while variable.hasNext():
            variable1 = variable.next()
            expression = StringTools.replace(expression,variable1,Std.string(self.variables.h.get(variable1,None)))
        expression = self.replaceCustomOperators(expression)
        return self.eval(self.parse(expression))

    def setVariable(self,name,value):
        self.variables.h[name] = value

    def replaceCustomOperators(self,expression):
        customPattern = EReg("(\\d+)\\s*&\\s*(\\d+)","")
        while True:
            customPattern.matchObj = python_lib_Re.search(customPattern.pattern,expression)
            if (not ((customPattern.matchObj is not None))):
                break
            matched = customPattern.matchObj.group(0)
            def _hx_local_0(s):
                return Std.parseInt(StringTools.trim(s))
            parts = list(map(_hx_local_0,matched.split("&")))
            result = (Std.string((parts[0] if 0 < len(parts) else None)) + Std.string((parts[1] if 1 < len(parts) else None)))
            expression = StringTools.replace(expression,matched,result)
        return expression

    def parse(self,expression):
        return backend_modules_Parser.parseString(expression)

    def eval(self,node):
        _g = Reflect.field(node,"expr")
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            return Std.parseFloat(c)
        elif (tmp == 1):
            op = _g.params[0]
            left = _g.params[1]
            right = _g.params[2]
            l = self.eval(left)
            r = self.eval(right)
            tmp = op.index
            if (tmp == 0):
                return (l + r)
            elif (tmp == 1):
                return (l - r)
            elif (tmp == 2):
                return (l * r)
            elif (tmp == 3):
                return (l / r)
            elif (tmp == 4):
                return Math.pow(l,r)
            else:
                pass
        else:
            raise haxe_Exception.thrown("Unsupported expression")

    def solveEquation(self,expression):
        parts = expression.split("=")
        if (len(parts) != 2):
            raise haxe_Exception.thrown("Invalid equation")
        left = StringTools.trim((parts[0] if 0 < len(parts) else None))
        right = StringTools.trim((parts[1] if 1 < len(parts) else None))
        rhsValue = self.evaluate(right)
        variablePattern = EReg("([a-zA-Z]+)","")
        variablePattern.matchObj = python_lib_Re.search(variablePattern.pattern,left)
        if (variablePattern.matchObj is None):
            raise haxe_Exception.thrown("No variable found to solve for")
        variable = variablePattern.matchObj.group(1)
        equationWithoutVariable = StringTools.replace(left,variable,"0")
        lhsWithoutVariableValue = self.evaluate(equationWithoutVariable)
        variableValue = (rhsValue - lhsWithoutVariableValue)
        return ((("null" if variable is None else variable) + " = ") + Std.string(variableValue))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.variables = None
backend_modules_MathSolver2._hx_class = backend_modules_MathSolver2
_hx_classes["backend.modules.MathSolver2"] = backend_modules_MathSolver2


class backend_modules_Parser:
    _hx_class_name = "backend.modules.Parser"
    __slots__ = ()
    _hx_statics = ["parseString", "parseToken"]

    @staticmethod
    def parseString(expression):
        tokens = expression.split(" ")
        stack = []
        _g = 0
        while (_g < len(tokens)):
            token = (tokens[_g] if _g >= 0 and _g < len(tokens) else None)
            _g = (_g + 1)
            token1 = token
            if (token1 == "*"):
                x = _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Mul,(None if ((len(stack) == 0)) else stack.pop()),backend_modules_Parser.parseToken((None if ((len(tokens) == 0)) else tokens.pop(0))))})
                stack.append(x)
            elif (token1 == "+"):
                x1 = _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Add,(None if ((len(stack) == 0)) else stack.pop()),backend_modules_Parser.parseToken((None if ((len(tokens) == 0)) else tokens.pop(0))))})
                stack.append(x1)
            elif (token1 == "-"):
                x2 = _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Sub,(None if ((len(stack) == 0)) else stack.pop()),backend_modules_Parser.parseToken((None if ((len(tokens) == 0)) else tokens.pop(0))))})
                stack.append(x2)
            elif (token1 == "/"):
                x3 = _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Div,(None if ((len(stack) == 0)) else stack.pop()),backend_modules_Parser.parseToken((None if ((len(tokens) == 0)) else tokens.pop(0))))})
                stack.append(x3)
            elif (token1 == "^"):
                x4 = _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Pow,(None if ((len(stack) == 0)) else stack.pop()),backend_modules_Parser.parseToken((None if ((len(tokens) == 0)) else tokens.pop(0))))})
                stack.append(x4)
            else:
                x5 = backend_modules_Parser.parseToken(token)
                stack.append(x5)
        if (len(stack) > 1):
            return _hx_AnonObject({'expr': backend_modules_Expr.EBinop(backend_modules_Binop.Add,(stack[0] if 0 < len(stack) else None),(stack[1] if 1 < len(stack) else None))})
        else:
            return (stack[0] if 0 < len(stack) else None)

    @staticmethod
    def parseToken(token):
        return _hx_AnonObject({'expr': backend_modules_Expr.EConst(token)})
backend_modules_Parser._hx_class = backend_modules_Parser
_hx_classes["backend.modules.Parser"] = backend_modules_Parser

class backend_modules_Expr(Enum):
    __slots__ = ()
    _hx_class_name = "backend.modules.Expr"
    _hx_constructs = ["EConst", "EBinop", "ECustom"]

    @staticmethod
    def EConst(exp):
        return backend_modules_Expr("EConst", 0, (exp,))

    @staticmethod
    def EBinop(e,o,d):
        return backend_modules_Expr("EBinop", 1, (e,o,d))

    @staticmethod
    def ECustom(exp,o,d):
        return backend_modules_Expr("ECustom", 2, (exp,o,d))
backend_modules_Expr._hx_class = backend_modules_Expr
_hx_classes["backend.modules.Expr"] = backend_modules_Expr

class backend_modules_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "backend.modules.Binop"
    _hx_constructs = ["Add", "Sub", "Mul", "Div", "Pow"]
backend_modules_Binop.Add = backend_modules_Binop("Add", 0, ())
backend_modules_Binop.Sub = backend_modules_Binop("Sub", 1, ())
backend_modules_Binop.Mul = backend_modules_Binop("Mul", 2, ())
backend_modules_Binop.Div = backend_modules_Binop("Div", 3, ())
backend_modules_Binop.Pow = backend_modules_Binop("Pow", 4, ())
backend_modules_Binop._hx_class = backend_modules_Binop
_hx_classes["backend.modules.Binop"] = backend_modules_Binop


class backend_modules_Variable:
    _hx_class_name = "backend.modules.Variable"
    __slots__ = ("expr",)
    _hx_fields = ["expr"]
    _hx_methods = ["evaluate"]
    _hx_statics = ["fromValue", "fromFunction"]

    def __init__(self,expr):
        self.expr = expr
        haxe_Log.trace("Variable created.",_hx_AnonObject({'fileName': "src/backend/modules/Variable.hx", 'lineNumber': 8, 'className': "backend.modules.Variable", 'methodName': "new"}))
        haxe_Log.trace(self.expr,_hx_AnonObject({'fileName': "src/backend/modules/Variable.hx", 'lineNumber': 9, 'className': "backend.modules.Variable", 'methodName': "new"}))

    def evaluate(self):
        try:
            return self.expr()
        except BaseException as _g:
            None
            error = haxe_Exception.caught(_g).unwrap()
            haxe_Log.trace(("Evaluation failed: " + Std.string(error)),_hx_AnonObject({'fileName': "src/backend/modules/Variable.hx", 'lineNumber': 16, 'className': "backend.modules.Variable", 'methodName': "evaluate"}))
            return None

    @staticmethod
    def fromValue(value):
        def _hx_local_1():
            def _hx_local_0():
                return value
            return backend_modules_Variable(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def fromFunction(func):
        return backend_modules_Variable(func)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.expr = None
backend_modules_Variable._hx_class = backend_modules_Variable
_hx_classes["backend.modules.Variable"] = backend_modules_Variable

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem
_hx_classes["haxe.StackItem"] = haxe_StackItem


class haxe__CallStack_CallStack_Impl_:
    _hx_class_name = "haxe._CallStack.CallStack_Impl_"
    __slots__ = ()
    _hx_statics = ["callStack", "exceptionStack", "toString", "subtract", "equalItems", "itemToString"]

    @staticmethod
    def callStack():
        infos = python_lib_Traceback.extract_stack()
        if (len(infos) != 0):
            infos.pop()
        infos.reverse()
        return haxe_NativeStackTrace.toHaxe(infos)

    @staticmethod
    def exceptionStack(fullStack = None):
        if (fullStack is None):
            fullStack = False
        eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack())
        return (eStack if fullStack else haxe__CallStack_CallStack_Impl_.subtract(eStack,haxe__CallStack_CallStack_Impl_.callStack()))

    @staticmethod
    def toString(stack):
        b = StringBuf()
        _g = 0
        _g1 = stack
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.b.write("\nCalled from ")
            haxe__CallStack_CallStack_Impl_.itemToString(b,s)
        return b.b.getvalue()

    @staticmethod
    def subtract(this1,stack):
        startIndex = -1
        i = -1
        while True:
            i = (i + 1)
            tmp = i
            if (not ((tmp < len(this1)))):
                break
            _g = 0
            _g1 = len(stack)
            while (_g < _g1):
                j = _g
                _g = (_g + 1)
                if haxe__CallStack_CallStack_Impl_.equalItems((this1[i] if i >= 0 and i < len(this1) else None),python_internal_ArrayImpl._get(stack, j)):
                    if (startIndex < 0):
                        startIndex = i
                    i = (i + 1)
                    if (i >= len(this1)):
                        break
                else:
                    startIndex = -1
            if (not ((startIndex < 0))):
                break
        if (startIndex >= 0):
            return this1[0:startIndex]
        else:
            return this1

    @staticmethod
    def equalItems(item1,item2):
        if (item1 is None):
            if (item2 is None):
                return True
            else:
                return False
        else:
            tmp = item1.index
            if (tmp == 0):
                if (item2 is None):
                    return False
                elif (item2.index == 0):
                    return True
                else:
                    return False
            elif (tmp == 1):
                if (item2 is None):
                    return False
                elif (item2.index == 1):
                    m2 = item2.params[0]
                    m1 = item1.params[0]
                    return (m1 == m2)
                else:
                    return False
            elif (tmp == 2):
                if (item2 is None):
                    return False
                elif (item2.index == 2):
                    item21 = item2.params[0]
                    file2 = item2.params[1]
                    line2 = item2.params[2]
                    col2 = item2.params[3]
                    col1 = item1.params[3]
                    line1 = item1.params[2]
                    file1 = item1.params[1]
                    item11 = item1.params[0]
                    if (((file1 == file2) and ((line1 == line2))) and ((col1 == col2))):
                        return haxe__CallStack_CallStack_Impl_.equalItems(item11,item21)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 3):
                if (item2 is None):
                    return False
                elif (item2.index == 3):
                    class2 = item2.params[0]
                    method2 = item2.params[1]
                    method1 = item1.params[1]
                    class1 = item1.params[0]
                    if (class1 == class2):
                        return (method1 == method2)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 4):
                if (item2 is None):
                    return False
                elif (item2.index == 4):
                    v2 = item2.params[0]
                    v1 = item1.params[0]
                    return (v1 == v2)
                else:
                    return False
            else:
                pass

    @staticmethod
    def itemToString(b,s):
        tmp = s.index
        if (tmp == 0):
            b.b.write("a C function")
        elif (tmp == 1):
            m = s.params[0]
            b.b.write("module ")
            s1 = Std.string(m)
            b.b.write(s1)
        elif (tmp == 2):
            s1 = s.params[0]
            file = s.params[1]
            line = s.params[2]
            col = s.params[3]
            if (s1 is not None):
                haxe__CallStack_CallStack_Impl_.itemToString(b,s1)
                b.b.write(" (")
            s2 = Std.string(file)
            b.b.write(s2)
            b.b.write(" line ")
            s2 = Std.string(line)
            b.b.write(s2)
            if (col is not None):
                b.b.write(" column ")
                s2 = Std.string(col)
                b.b.write(s2)
            if (s1 is not None):
                b.b.write(")")
        elif (tmp == 3):
            cname = s.params[0]
            meth = s.params[1]
            s1 = Std.string(("<unknown>" if ((cname is None)) else cname))
            b.b.write(s1)
            b.b.write(".")
            s1 = Std.string(meth)
            b.b.write(s1)
        elif (tmp == 4):
            n = s.params[0]
            b.b.write("local function #")
            s = Std.string(n)
            b.b.write(s)
        else:
            pass
haxe__CallStack_CallStack_Impl_._hx_class = haxe__CallStack_CallStack_Impl_
_hx_classes["haxe._CallStack.CallStack_Impl_"] = haxe__CallStack_CallStack_Impl_


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "remove", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class sys_thread_Mutex:
    _hx_class_name = "sys.thread.Mutex"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]

    def __init__(self):
        self.lock = python_lib_threading_RLock()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lock = None
sys_thread_Mutex._hx_class = sys_thread_Mutex
_hx_classes["sys.thread.Mutex"] = sys_thread_Mutex


class sys_thread_EventLoop:
    _hx_class_name = "sys.thread.EventLoop"
    __slots__ = ("mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread")
    _hx_fields = ["mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread"]
    _hx_methods = ["loop"]
    _hx_statics = ["CREATED"]

    def __init__(self):
        self.regularEvents = None
        self.promisedEventsCount = 0
        self.waitLock = sys_thread_Lock()
        self.oneTimeEventsIdx = 0
        self.oneTimeEvents = list()
        self.mutex = sys_thread_Mutex()
        self.isMainThread = (not sys_thread_EventLoop.CREATED)
        sys_thread_EventLoop.CREATED = True

    def loop(self):
        recycleRegular = []
        recycleOneTimers = []
        while True:
            now = python_lib_Time.time()
            regularsToRun = recycleRegular
            eventsToRunIdx = 0
            nextEventAt = -1
            self.mutex.lock.acquire(True)
            while self.waitLock.semaphore.acquire(True,0.0):
                pass
            current = self.regularEvents
            while (current is not None):
                if (current.nextRunTime <= now):
                    tmp = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(regularsToRun, tmp, current)
                    current.nextRunTime = (current.nextRunTime + current.interval)
                    nextEventAt = -2
                elif ((nextEventAt == -1) or ((current.nextRunTime < nextEventAt))):
                    nextEventAt = current.nextRunTime
                current = current.next
            self.mutex.lock.release()
            _g = 0
            _g1 = eventsToRunIdx
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not (regularsToRun[i] if i >= 0 and i < len(regularsToRun) else None).cancelled):
                    (regularsToRun[i] if i >= 0 and i < len(regularsToRun) else None).run()
                python_internal_ArrayImpl._set(regularsToRun, i, None)
            eventsToRunIdx = 0
            oneTimersToRun = recycleOneTimers
            self.mutex.lock.acquire(True)
            _g_current = 0
            _g_array = self.oneTimeEvents
            while (_g_current < len(_g_array)):
                _g_value = (_g_array[_g_current] if _g_current >= 0 and _g_current < len(_g_array) else None)
                _g_key = _g_current
                _g_current = (_g_current + 1)
                i1 = _g_key
                event = _g_value
                if (event is None):
                    break
                else:
                    tmp1 = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(oneTimersToRun, tmp1, event)
                    python_internal_ArrayImpl._set(self.oneTimeEvents, i1, None)
            self.oneTimeEventsIdx = 0
            hasPromisedEvents = (self.promisedEventsCount > 0)
            self.mutex.lock.release()
            _g2 = 0
            _g3 = eventsToRunIdx
            while (_g2 < _g3):
                i2 = _g2
                _g2 = (_g2 + 1)
                (oneTimersToRun[i2] if i2 >= 0 and i2 < len(oneTimersToRun) else None)()
                python_internal_ArrayImpl._set(oneTimersToRun, i2, None)
            if self.isMainThread:
                next = haxe_MainLoop.tick()
                if haxe_MainLoop.hasEvents():
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    if (nextEventAt > next):
                        nextEventAt = next
            if (eventsToRunIdx > 0):
                nextEventAt = -2
            r_nextEventAt = nextEventAt
            r_anyTime = hasPromisedEvents
            _g4 = r_anyTime
            _g5 = r_nextEventAt
            _g6 = _g5
            if (_g6 == -2):
                pass
            elif (_g6 == -1):
                if _g4:
                    self.waitLock.semaphore.acquire(True,None)
                else:
                    break
            else:
                time = _g5
                timeout = (time - python_lib_Time.time())
                _this = self.waitLock
                timeout1 = (0 if (python_lib_Math.isnan(0)) else (timeout if (python_lib_Math.isnan(timeout)) else max(0,timeout)))
                _this.semaphore.acquire(True,timeout1)
    CREATED = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mutex = None
        _hx_o.oneTimeEvents = None
        _hx_o.oneTimeEventsIdx = None
        _hx_o.waitLock = None
        _hx_o.promisedEventsCount = None
        _hx_o.regularEvents = None
        _hx_o.isMainThread = None
sys_thread_EventLoop._hx_class = sys_thread_EventLoop
_hx_classes["sys.thread.EventLoop"] = sys_thread_EventLoop


class sys_thread__Thread_HxThread:
    _hx_class_name = "sys.thread._Thread.HxThread"
    __slots__ = ("events", "nativeThread")
    _hx_fields = ["events", "nativeThread"]
    _hx_statics = ["threads", "threadsMutex", "mainThread", "current", "create"]

    def __init__(self,t):
        self.events = None
        self.nativeThread = t
    threads = None
    threadsMutex = None
    mainThread = None

    @staticmethod
    def current():
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        ct = python_lib_Threading.current_thread()
        if (ct == python_lib_Threading.main_thread()):
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
            return sys_thread__Thread_HxThread.mainThread
        if (not (ct in sys_thread__Thread_HxThread.threads.h)):
            sys_thread__Thread_HxThread.threads.set(ct,sys_thread__Thread_HxThread(ct))
        t = sys_thread__Thread_HxThread.threads.h.get(ct,None)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        return t

    @staticmethod
    def create(callb,withEventLoop):
        nt = None
        t = None
        def _hx_local_0():
            try:
                callb()
                if withEventLoop:
                    t.events.loop()
            except BaseException as _g:
                e = haxe_Exception.caught(_g)
                sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
                sys_thread__Thread_HxThread.threads.remove(nt)
                sys_thread__Thread_HxThread.threadsMutex.lock.release()
                raise haxe_Exception.thrown(e)
            sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
            sys_thread__Thread_HxThread.threads.remove(nt)
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
        wrappedCallB = _hx_local_0
        nt = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': wrappedCallB})))
        t = sys_thread__Thread_HxThread(nt)
        if withEventLoop:
            t.events = sys_thread_EventLoop()
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        sys_thread__Thread_HxThread.threads.set(nt,t)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        nt.start()
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.events = None
        _hx_o.nativeThread = None
sys_thread__Thread_HxThread._hx_class = sys_thread__Thread_HxThread
_hx_classes["sys.thread._Thread.HxThread"] = sys_thread__Thread_HxThread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run():
        pass
haxe_EntryPoint._hx_class = haxe_EntryPoint
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
haxe_Exception._hx_class = haxe_Exception
_hx_classes["haxe.Exception"] = haxe_Exception


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "sortEvents", "tick"]
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack", "toHaxe"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []

    @staticmethod
    def toHaxe(native,skip = None):
        if (skip is None):
            skip = 0
        stack = []
        _g = 0
        _g1 = len(native)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (skip > i):
                continue
            elem = (native[i] if i >= 0 and i < len(native) else None)
            x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
            stack.append(x)
        return stack
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace
_hx_classes["haxe.NativeStackTrace"] = haxe_NativeStackTrace


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
haxe_ValueException._hx_class = haxe_ValueException
_hx_classes["haxe.ValueException"] = haxe_ValueException


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString", "toString"]
    _hx_statics = ["alloc", "ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str
haxe_crypto_Base64._hx_class = haxe_crypto_Base64
_hx_classes["haxe.crypto.Base64"] = haxe_crypto_Base64


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits")
    _hx_fields = ["base", "nbits"]
    _hx_methods = ["encodeBytes"]

    def __init__(self,base):
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
haxe_crypto_BaseCode._hx_class = haxe_crypto_BaseCode
_hx_classes["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "keys", "setLoop", "keysLoop", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def keys(self):
        ret = []
        self.keysLoop(self.root,ret)
        return haxe_iterators_ArrayIterator(ret)

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def keysLoop(self,node,acc):
        if (node is not None):
            self.keysLoop(node.left,acc)
            x = node.key
            acc.append(x)
            self.keysLoop(node.right,acc)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this = r.right
            _this1 = r.left
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this = self.left
                tmp = (0 if ((_this is None)) else _this._height)
            else:
                _this = self.right
                tmp = (0 if ((_this is None)) else _this._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std.isOfType(v1,list) and Std.isOfType(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds_GenericCell:
    _hx_class_name = "haxe.ds.GenericCell"
    __slots__ = ("elt", "next")
    _hx_fields = ["elt", "next"]

    def __init__(self,elt,next):
        self.elt = elt
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.elt = None
        _hx_o.next = None
haxe_ds_GenericCell._hx_class = haxe_ds_GenericCell
_hx_classes["haxe.ds.GenericCell"] = haxe_ds_GenericCell


class haxe_ds_GenericStack:
    _hx_class_name = "haxe.ds.GenericStack"
    __slots__ = ("head",)
    _hx_fields = ["head"]

    def __init__(self):
        self.head = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.head = None
haxe_ds_GenericStack._hx_class = haxe_ds_GenericStack
_hx_classes["haxe.ds.GenericStack"] = haxe_ds_GenericStack


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "remove", "keys", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("]")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            v = Std.string(i)
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        empty = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if empty:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                empty = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
        if (not empty):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nind
            _hx_local_2.nind = (_hx_local_3 - 1)
            _hx_local_3
            if self.pretty:
                _this = self.buf
                s = "".join(map(chr,[10]))
                _this.b.write(s)
            if self.pretty:
                v = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this = self.buf
                s = Std.string(v)
                _this.b.write(s)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        length = len(s)
        while (i < length):
            index = i
            i = (i + 1)
            c = ord(s[index])
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter
_hx_classes["haxe.format.JsonPrinter"] = haxe_format_JsonPrinter

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_statics = ["directory"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex = None
        cp = None
        if (startIndex is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i = path.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = path.find(".", startLeft, len(path))
            cp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    @staticmethod
    def directory(path):
        s = haxe_io_Path(path)
        if (s.dir is None):
            return ""
        return s.dir

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dir = None
        _hx_o.file = None
        _hx_o.ext = None
        _hx_o.backslash = None
haxe_io_Path._hx_class = haxe_io_Path
_hx_classes["haxe.io.Path"] = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator
_hx_classes["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator
_hx_classes["haxe.iterators.ArrayKeyValueIterator"] = haxe_iterators_ArrayKeyValueIterator


class haxe_iterators_MapKeyValueIterator:
    _hx_class_name = "haxe.iterators.MapKeyValueIterator"
    __slots__ = ("map", "keys")
    _hx_fields = ["map", "keys"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        return _hx_AnonObject({'value': self.map.get(key), 'key': key})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.keys = None
haxe_iterators_MapKeyValueIterator._hx_class = haxe_iterators_MapKeyValueIterator
_hx_classes["haxe.iterators.MapKeyValueIterator"] = haxe_iterators_MapKeyValueIterator

class haxe_macro_StringLiteralKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.StringLiteralKind"
    _hx_constructs = ["DoubleQuotes", "SingleQuotes"]
haxe_macro_StringLiteralKind.DoubleQuotes = haxe_macro_StringLiteralKind("DoubleQuotes", 0, ())
haxe_macro_StringLiteralKind.SingleQuotes = haxe_macro_StringLiteralKind("SingleQuotes", 1, ())
haxe_macro_StringLiteralKind._hx_class = haxe_macro_StringLiteralKind
_hx_classes["haxe.macro.StringLiteralKind"] = haxe_macro_StringLiteralKind

class haxe_macro_Constant(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Constant"
    _hx_constructs = ["CInt", "CFloat", "CString", "CIdent", "CRegexp"]

    @staticmethod
    def CInt(v,s = None):
        return haxe_macro_Constant("CInt", 0, (v,s))

    @staticmethod
    def CFloat(f,s = None):
        return haxe_macro_Constant("CFloat", 1, (f,s))

    @staticmethod
    def CString(s,kind = None):
        return haxe_macro_Constant("CString", 2, (s,kind))

    @staticmethod
    def CIdent(s):
        return haxe_macro_Constant("CIdent", 3, (s,))

    @staticmethod
    def CRegexp(r,opt):
        return haxe_macro_Constant("CRegexp", 4, (r,opt))
haxe_macro_Constant._hx_class = haxe_macro_Constant
_hx_classes["haxe.macro.Constant"] = haxe_macro_Constant

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn", "OpNullCoal"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, (op,))
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, ())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, ())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, ())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, ())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, ())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, ())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, ())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, ())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, ())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, ())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, ())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, ())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, ())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, ())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, ())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, ())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, ())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, ())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, ())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, ())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, ())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, ())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, ())
haxe_macro_Binop.OpNullCoal = haxe_macro_Binop("OpNullCoal", 24, ())
haxe_macro_Binop._hx_class = haxe_macro_Binop
_hx_classes["haxe.macro.Binop"] = haxe_macro_Binop

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits", "OpSpread"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, ())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, ())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, ())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, ())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, ())
haxe_macro_Unop.OpSpread = haxe_macro_Unop("OpSpread", 5, ())
haxe_macro_Unop._hx_class = haxe_macro_Unop
_hx_classes["haxe.macro.Unop"] = haxe_macro_Unop

class haxe_macro_EFieldKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.EFieldKind"
    _hx_constructs = ["Normal", "Safe"]
haxe_macro_EFieldKind.Normal = haxe_macro_EFieldKind("Normal", 0, ())
haxe_macro_EFieldKind.Safe = haxe_macro_EFieldKind("Safe", 1, ())
haxe_macro_EFieldKind._hx_class = haxe_macro_EFieldKind
_hx_classes["haxe.macro.EFieldKind"] = haxe_macro_EFieldKind

class haxe_macro_QuoteStatus(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.QuoteStatus"
    _hx_constructs = ["Unquoted", "Quoted"]
haxe_macro_QuoteStatus.Unquoted = haxe_macro_QuoteStatus("Unquoted", 0, ())
haxe_macro_QuoteStatus.Quoted = haxe_macro_QuoteStatus("Quoted", 1, ())
haxe_macro_QuoteStatus._hx_class = haxe_macro_QuoteStatus
_hx_classes["haxe.macro.QuoteStatus"] = haxe_macro_QuoteStatus

class haxe_macro_FunctionKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.FunctionKind"
    _hx_constructs = ["FAnonymous", "FNamed", "FArrow"]

    @staticmethod
    def FNamed(name,inlined = None):
        return haxe_macro_FunctionKind("FNamed", 1, (name,inlined))
haxe_macro_FunctionKind.FAnonymous = haxe_macro_FunctionKind("FAnonymous", 0, ())
haxe_macro_FunctionKind.FArrow = haxe_macro_FunctionKind("FArrow", 2, ())
haxe_macro_FunctionKind._hx_class = haxe_macro_FunctionKind
_hx_classes["haxe.macro.FunctionKind"] = haxe_macro_FunctionKind

class haxe_macro_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ExprDef"
    _hx_constructs = ["EConst", "EArray", "EBinop", "EField", "EParenthesis", "EObjectDecl", "EArrayDecl", "ECall", "ENew", "EUnop", "EVars", "EFunction", "EBlock", "EFor", "EIf", "EWhile", "ESwitch", "ETry", "EReturn", "EBreak", "EContinue", "EUntyped", "EThrow", "ECast", "EDisplay", "ETernary", "ECheckType", "EMeta", "EIs"]

    @staticmethod
    def EConst(c):
        return haxe_macro_ExprDef("EConst", 0, (c,))

    @staticmethod
    def EArray(e1,e2):
        return haxe_macro_ExprDef("EArray", 1, (e1,e2))

    @staticmethod
    def EBinop(op,e1,e2):
        return haxe_macro_ExprDef("EBinop", 2, (op,e1,e2))

    @staticmethod
    def EField(e,field,kind = None):
        return haxe_macro_ExprDef("EField", 3, (e,field,kind))

    @staticmethod
    def EParenthesis(e):
        return haxe_macro_ExprDef("EParenthesis", 4, (e,))

    @staticmethod
    def EObjectDecl(fields):
        return haxe_macro_ExprDef("EObjectDecl", 5, (fields,))

    @staticmethod
    def EArrayDecl(values):
        return haxe_macro_ExprDef("EArrayDecl", 6, (values,))

    @staticmethod
    def ECall(e,params):
        return haxe_macro_ExprDef("ECall", 7, (e,params))

    @staticmethod
    def ENew(t,params):
        return haxe_macro_ExprDef("ENew", 8, (t,params))

    @staticmethod
    def EUnop(op,postFix,e):
        return haxe_macro_ExprDef("EUnop", 9, (op,postFix,e))

    @staticmethod
    def EVars(vars):
        return haxe_macro_ExprDef("EVars", 10, (vars,))

    @staticmethod
    def EFunction(kind,f):
        return haxe_macro_ExprDef("EFunction", 11, (kind,f))

    @staticmethod
    def EBlock(exprs):
        return haxe_macro_ExprDef("EBlock", 12, (exprs,))

    @staticmethod
    def EFor(it,expr):
        return haxe_macro_ExprDef("EFor", 13, (it,expr))

    @staticmethod
    def EIf(econd,eif,eelse):
        return haxe_macro_ExprDef("EIf", 14, (econd,eif,eelse))

    @staticmethod
    def EWhile(econd,e,normalWhile):
        return haxe_macro_ExprDef("EWhile", 15, (econd,e,normalWhile))

    @staticmethod
    def ESwitch(e,cases,edef):
        return haxe_macro_ExprDef("ESwitch", 16, (e,cases,edef))

    @staticmethod
    def ETry(e,catches):
        return haxe_macro_ExprDef("ETry", 17, (e,catches))

    @staticmethod
    def EReturn(e = None):
        return haxe_macro_ExprDef("EReturn", 18, (e,))

    @staticmethod
    def EUntyped(e):
        return haxe_macro_ExprDef("EUntyped", 21, (e,))

    @staticmethod
    def EThrow(e):
        return haxe_macro_ExprDef("EThrow", 22, (e,))

    @staticmethod
    def ECast(e,t):
        return haxe_macro_ExprDef("ECast", 23, (e,t))

    @staticmethod
    def EDisplay(e,displayKind):
        return haxe_macro_ExprDef("EDisplay", 24, (e,displayKind))

    @staticmethod
    def ETernary(econd,eif,eelse):
        return haxe_macro_ExprDef("ETernary", 25, (econd,eif,eelse))

    @staticmethod
    def ECheckType(e,t):
        return haxe_macro_ExprDef("ECheckType", 26, (e,t))

    @staticmethod
    def EMeta(s,e):
        return haxe_macro_ExprDef("EMeta", 27, (s,e))

    @staticmethod
    def EIs(e,t):
        return haxe_macro_ExprDef("EIs", 28, (e,t))
haxe_macro_ExprDef.EBreak = haxe_macro_ExprDef("EBreak", 19, ())
haxe_macro_ExprDef.EContinue = haxe_macro_ExprDef("EContinue", 20, ())
haxe_macro_ExprDef._hx_class = haxe_macro_ExprDef
_hx_classes["haxe.macro.ExprDef"] = haxe_macro_ExprDef

class haxe_macro_DisplayKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.DisplayKind"
    _hx_constructs = ["DKCall", "DKDot", "DKStructure", "DKMarked", "DKPattern"]

    @staticmethod
    def DKPattern(outermost):
        return haxe_macro_DisplayKind("DKPattern", 4, (outermost,))
haxe_macro_DisplayKind.DKCall = haxe_macro_DisplayKind("DKCall", 0, ())
haxe_macro_DisplayKind.DKDot = haxe_macro_DisplayKind("DKDot", 1, ())
haxe_macro_DisplayKind.DKStructure = haxe_macro_DisplayKind("DKStructure", 2, ())
haxe_macro_DisplayKind.DKMarked = haxe_macro_DisplayKind("DKMarked", 3, ())
haxe_macro_DisplayKind._hx_class = haxe_macro_DisplayKind
_hx_classes["haxe.macro.DisplayKind"] = haxe_macro_DisplayKind

class haxe_macro_ComplexType(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ComplexType"
    _hx_constructs = ["TPath", "TFunction", "TAnonymous", "TParent", "TExtend", "TOptional", "TNamed", "TIntersection"]

    @staticmethod
    def TPath(p):
        return haxe_macro_ComplexType("TPath", 0, (p,))

    @staticmethod
    def TFunction(args,ret):
        return haxe_macro_ComplexType("TFunction", 1, (args,ret))

    @staticmethod
    def TAnonymous(fields):
        return haxe_macro_ComplexType("TAnonymous", 2, (fields,))

    @staticmethod
    def TParent(t):
        return haxe_macro_ComplexType("TParent", 3, (t,))

    @staticmethod
    def TExtend(p,fields):
        return haxe_macro_ComplexType("TExtend", 4, (p,fields))

    @staticmethod
    def TOptional(t):
        return haxe_macro_ComplexType("TOptional", 5, (t,))

    @staticmethod
    def TNamed(n,t):
        return haxe_macro_ComplexType("TNamed", 6, (n,t))

    @staticmethod
    def TIntersection(tl):
        return haxe_macro_ComplexType("TIntersection", 7, (tl,))
haxe_macro_ComplexType._hx_class = haxe_macro_ComplexType
_hx_classes["haxe.macro.ComplexType"] = haxe_macro_ComplexType

class haxe_macro_TypeParam(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.TypeParam"
    _hx_constructs = ["TPType", "TPExpr"]

    @staticmethod
    def TPType(t):
        return haxe_macro_TypeParam("TPType", 0, (t,))

    @staticmethod
    def TPExpr(e):
        return haxe_macro_TypeParam("TPExpr", 1, (e,))
haxe_macro_TypeParam._hx_class = haxe_macro_TypeParam
_hx_classes["haxe.macro.TypeParam"] = haxe_macro_TypeParam

class haxe_macro_Access(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Access"
    _hx_constructs = ["APublic", "APrivate", "AStatic", "AOverride", "ADynamic", "AInline", "AMacro", "AFinal", "AExtern", "AAbstract", "AOverload"]
haxe_macro_Access.APublic = haxe_macro_Access("APublic", 0, ())
haxe_macro_Access.APrivate = haxe_macro_Access("APrivate", 1, ())
haxe_macro_Access.AStatic = haxe_macro_Access("AStatic", 2, ())
haxe_macro_Access.AOverride = haxe_macro_Access("AOverride", 3, ())
haxe_macro_Access.ADynamic = haxe_macro_Access("ADynamic", 4, ())
haxe_macro_Access.AInline = haxe_macro_Access("AInline", 5, ())
haxe_macro_Access.AMacro = haxe_macro_Access("AMacro", 6, ())
haxe_macro_Access.AFinal = haxe_macro_Access("AFinal", 7, ())
haxe_macro_Access.AExtern = haxe_macro_Access("AExtern", 8, ())
haxe_macro_Access.AAbstract = haxe_macro_Access("AAbstract", 9, ())
haxe_macro_Access.AOverload = haxe_macro_Access("AOverload", 10, ())
haxe_macro_Access._hx_class = haxe_macro_Access
_hx_classes["haxe.macro.Access"] = haxe_macro_Access

class haxe_macro_FieldType(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.FieldType"
    _hx_constructs = ["FVar", "FFun", "FProp"]

    @staticmethod
    def FVar(t,e = None):
        return haxe_macro_FieldType("FVar", 0, (t,e))

    @staticmethod
    def FFun(f):
        return haxe_macro_FieldType("FFun", 1, (f,))

    @staticmethod
    def FProp(get,set,t = None,e= None):
        return haxe_macro_FieldType("FProp", 2, (get,set,t,e))
haxe_macro_FieldType._hx_class = haxe_macro_FieldType
_hx_classes["haxe.macro.FieldType"] = haxe_macro_FieldType


class haxe_macro_ExprTools:
    _hx_class_name = "haxe.macro.ExprTools"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(e):
        return haxe_macro_Printer().printExpr(e)
haxe_macro_ExprTools._hx_class = haxe_macro_ExprTools
_hx_classes["haxe.macro.ExprTools"] = haxe_macro_ExprTools


class haxe_macro_Printer:
    _hx_class_name = "haxe.macro.Printer"
    __slots__ = ("tabs", "tabString")
    _hx_fields = ["tabs", "tabString"]
    _hx_methods = ["printUnop", "printBinop", "escapeString", "printFormatString", "printString", "printConstant", "printTypeParam", "printTypePath", "printComplexType", "printMetadata", "printAccess", "printField", "printTypeParamDecl", "printFunctionArg", "printFunction", "printVar", "printObjectFieldKey", "printObjectField", "printExpr", "printExprs", "opt"]

    def __init__(self,tabString = None):
        if (tabString is None):
            tabString = "\t"
        self.tabs = ""
        self.tabString = tabString

    def printUnop(self,op):
        tmp = op.index
        if (tmp == 0):
            return "++"
        elif (tmp == 1):
            return "--"
        elif (tmp == 2):
            return "!"
        elif (tmp == 3):
            return "-"
        elif (tmp == 4):
            return "~"
        elif (tmp == 5):
            return "..."
        else:
            pass

    def printBinop(self,op):
        tmp = op.index
        if (tmp == 0):
            return "+"
        elif (tmp == 1):
            return "*"
        elif (tmp == 2):
            return "/"
        elif (tmp == 3):
            return "-"
        elif (tmp == 4):
            return "="
        elif (tmp == 5):
            return "=="
        elif (tmp == 6):
            return "!="
        elif (tmp == 7):
            return ">"
        elif (tmp == 8):
            return ">="
        elif (tmp == 9):
            return "<"
        elif (tmp == 10):
            return "<="
        elif (tmp == 11):
            return "&"
        elif (tmp == 12):
            return "|"
        elif (tmp == 13):
            return "^"
        elif (tmp == 14):
            return "&&"
        elif (tmp == 15):
            return "||"
        elif (tmp == 16):
            return "<<"
        elif (tmp == 17):
            return ">>"
        elif (tmp == 18):
            return ">>>"
        elif (tmp == 19):
            return "%"
        elif (tmp == 20):
            op1 = op.params[0]
            return (HxOverrides.stringOrNull(self.printBinop(op1)) + "=")
        elif (tmp == 21):
            return "..."
        elif (tmp == 22):
            return "=>"
        elif (tmp == 23):
            return "in"
        elif (tmp == 24):
            return "??"
        else:
            pass

    def escapeString(self,s,delim):
        return ((("null" if delim is None else delim) + HxOverrides.stringOrNull(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(s,"\\","\\\\"),"\n","\\n"),"\t","\\t"),"\r","\\r"),"'","\\'"),"\"","\\\""),"\x00","\\x00"))) + ("null" if delim is None else delim))

    def printFormatString(self,s):
        return self.escapeString(s,"'")

    def printString(self,s):
        return self.escapeString(s,"\"")

    def printConstant(self,c):
        tmp = c.index
        if (tmp == 0):
            _g = c.params[0]
            _g1 = c.params[1]
            if (_g1 is None):
                s = _g
                return s
            else:
                suffix = _g1
                s = _g
                return (("null" if s is None else s) + ("null" if suffix is None else suffix))
        elif (tmp == 1):
            _g = c.params[0]
            _g1 = c.params[1]
            if (_g1 is None):
                s = _g
                return s
            else:
                suffix = _g1
                s = _g
                return (("null" if s is None else s) + ("null" if suffix is None else suffix))
        elif (tmp == 2):
            _g = c.params[0]
            _g1 = c.params[1]
            if (_g1 is None):
                s = _g
                return self.printString(s)
            elif (_g1.index == 1):
                s = _g
                return self.printFormatString(s)
            else:
                s = _g
                return self.printString(s)
        elif (tmp == 3):
            s = c.params[0]
            return s
        elif (tmp == 4):
            s = c.params[0]
            opt = c.params[1]
            return ((("~/" + ("null" if s is None else s)) + "/") + ("null" if opt is None else opt))
        else:
            pass

    def printTypeParam(self,param):
        tmp = param.index
        if (tmp == 0):
            ct = param.params[0]
            return self.printComplexType(ct)
        elif (tmp == 1):
            e = param.params[0]
            return self.printExpr(e)
        else:
            pass

    def printTypePath(self,tp):
        tmp = None
        if (len(tp.pack) > 0):
            _this = tp.pack
            tmp = (HxOverrides.stringOrNull(".".join([python_Boot.toString1(x1,'') for x1 in _this])) + ".")
        else:
            tmp = ""
        tmp1 = ((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(tp.name)) + HxOverrides.stringOrNull(((("." + HxOverrides.stringOrNull(Reflect.field(tp,"sub"))) if ((Reflect.field(tp,"sub") is not None)) else ""))))
        tmp = None
        if (Reflect.field(tp,"params") is None):
            tmp = ""
        elif (len(Reflect.field(tp,"params")) > 0):
            _this = list(map(self.printTypeParam,Reflect.field(tp,"params")))
            tmp = (("<" + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ">")
        else:
            tmp = ""
        return (("null" if tmp1 is None else tmp1) + ("null" if tmp is None else tmp))

    def printComplexType(self,ct):
        tmp = ct.index
        if (tmp == 0):
            tp = ct.params[0]
            return self.printTypePath(tp)
        elif (tmp == 1):
            args = ct.params[0]
            ret = ct.params[1]
            wrapArgumentsInParentheses = None
            if (len(args) == 1):
                _g = (args[0] if 0 < len(args) else None)
                wrapArgumentsInParentheses1 = _g.index
                if (wrapArgumentsInParentheses1 == 0):
                    _g1 = _g.params[0]
                    wrapArgumentsInParentheses = False
                elif (wrapArgumentsInParentheses1 == 3):
                    t = _g.params[0]
                    wrapArgumentsInParentheses = False
                elif (wrapArgumentsInParentheses1 == 5):
                    _g1 = _g.params[0]
                    if (_g1.index == 0):
                        _g = _g1.params[0]
                        wrapArgumentsInParentheses = False
                    else:
                        wrapArgumentsInParentheses = True
                else:
                    wrapArgumentsInParentheses = True
            else:
                wrapArgumentsInParentheses = True
            _this = list(map(self.printComplexType,args))
            argStr = ", ".join([python_Boot.toString1(x1,'') for x1 in _this])
            tmp = None
            if (ret.index == 1):
                _g = ret.params[0]
                _g = ret.params[1]
                tmp = (("(" + HxOverrides.stringOrNull(self.printComplexType(ret))) + ")")
            else:
                tmp = self.printComplexType(ret)
            return ((HxOverrides.stringOrNull((((("(" + ("null" if argStr is None else argStr)) + ")") if wrapArgumentsInParentheses else argStr))) + " -> ") + ("null" if tmp is None else tmp))
        elif (tmp == 2):
            fields = ct.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(fields)):
                f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                _g1 = (_g1 + 1)
                x = (HxOverrides.stringOrNull(self.printField(f)) + "; ")
                _g.append(x)
            return (("{ " + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "}")
        elif (tmp == 3):
            ct1 = ct.params[0]
            return (("(" + HxOverrides.stringOrNull(self.printComplexType(ct1))) + ")")
        elif (tmp == 4):
            tpl = ct.params[0]
            fields = ct.params[1]
            _g = []
            _g1 = 0
            while (_g1 < len(tpl)):
                t = (tpl[_g1] if _g1 >= 0 and _g1 < len(tpl) else None)
                _g1 = (_g1 + 1)
                x = (("> " + HxOverrides.stringOrNull(self.printTypePath(t))) + ", ")
                _g.append(x)
            types = "".join([python_Boot.toString1(x1,'') for x1 in _g])
            _g = []
            _g1 = 0
            while (_g1 < len(fields)):
                f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                _g1 = (_g1 + 1)
                x = (HxOverrides.stringOrNull(self.printField(f)) + "; ")
                _g.append(x)
            fields = "".join([python_Boot.toString1(x1,'') for x1 in _g])
            return ((("{" + ("null" if types is None else types)) + ("null" if fields is None else fields)) + "}")
        elif (tmp == 5):
            ct1 = ct.params[0]
            return ("?" + HxOverrides.stringOrNull(self.printComplexType(ct1)))
        elif (tmp == 6):
            n = ct.params[0]
            ct1 = ct.params[1]
            return ((("null" if n is None else n) + ":") + HxOverrides.stringOrNull(self.printComplexType(ct1)))
        elif (tmp == 7):
            tl = ct.params[0]
            _this = list(map(self.printComplexType,tl))
            return " & ".join([python_Boot.toString1(x1,'') for x1 in _this])
        else:
            pass

    def printMetadata(self,meta):
        return (("@" + HxOverrides.stringOrNull(meta.name)) + HxOverrides.stringOrNull((((("(" + HxOverrides.stringOrNull(self.printExprs(Reflect.field(meta,"params"),", "))) + ")") if (((Reflect.field(meta,"params") is not None) and ((len(Reflect.field(meta,"params")) > 0)))) else ""))))

    def printAccess(self,access):
        tmp = access.index
        if (tmp == 0):
            return "public"
        elif (tmp == 1):
            return "private"
        elif (tmp == 2):
            return "static"
        elif (tmp == 3):
            return "override"
        elif (tmp == 4):
            return "dynamic"
        elif (tmp == 5):
            return "inline"
        elif (tmp == 6):
            return "macro"
        elif (tmp == 7):
            return "final"
        elif (tmp == 8):
            return "extern"
        elif (tmp == 9):
            return "abstract"
        elif (tmp == 10):
            return "overload"
        else:
            pass

    def printField(self,field):
        tmp = (((((((("/**\n" + HxOverrides.stringOrNull(self.tabs)) + HxOverrides.stringOrNull(self.tabString)) + HxOverrides.stringOrNull(StringTools.replace(Reflect.field(field,"doc"),"\n",(("\n" + HxOverrides.stringOrNull(self.tabs)) + HxOverrides.stringOrNull(self.tabString))))) + "\n") + HxOverrides.stringOrNull(self.tabs)) + "**/\n") + HxOverrides.stringOrNull(self.tabs)) if (((Reflect.field(field,"doc") is not None) and ((Reflect.field(field,"doc") != "")))) else "")
        tmp1 = None
        if ((Reflect.field(field,"meta") is not None) and ((len(Reflect.field(field,"meta")) > 0))):
            _this = list(map(self.printMetadata,Reflect.field(field,"meta")))
            tmp1 = (HxOverrides.stringOrNull(("\n" + HxOverrides.stringOrNull(self.tabs)).join([python_Boot.toString1(x1,'') for x1 in _this])) + HxOverrides.stringOrNull((("\n" + HxOverrides.stringOrNull(self.tabs)))))
        else:
            tmp1 = ""
        tmp2 = None
        if ((Reflect.field(field,"access") is not None) and ((len(Reflect.field(field,"access")) > 0))):
            access = Reflect.field(field,"access")
            def _hx_local_2():
                def _hx_local_0(a):
                    return (a.index != 7)
                return (list(filter(_hx_local_0,access)) + [haxe_macro_Access.AFinal]) if Lambda.has(access,haxe_macro_Access.AFinal) else access
            _this = list(map(self.printAccess,_hx_local_2()))
            tmp2 = (HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in _this])) + " ")
        else:
            tmp2 = ""
        tmp3 = ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + ("null" if tmp2 is None else tmp2))
        _g = field.kind
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 0):
            t = _g.params[0]
            eo = _g.params[1]
            tmp = (((HxOverrides.stringOrNull((("" if (((Reflect.field(field,"access") is not None) and Lambda.has(Reflect.field(field,"access"),haxe_macro_Access.AFinal))) else "var "))) + HxOverrides.stringOrNull((("" + HxOverrides.stringOrNull(field.name))))) + HxOverrides.stringOrNull(self.opt(t,self.printComplexType," : "))) + HxOverrides.stringOrNull(self.opt(eo,self.printExpr," = ")))
        elif (tmp1 == 1):
            func = _g.params[0]
            tmp = (("function " + HxOverrides.stringOrNull(field.name)) + HxOverrides.stringOrNull(self.printFunction(func)))
        elif (tmp1 == 2):
            get = _g.params[0]
            _hx_set = _g.params[1]
            t = _g.params[2]
            eo = _g.params[3]
            tmp = (((((((("var " + HxOverrides.stringOrNull(field.name)) + "(") + ("null" if get is None else get)) + ", ") + ("null" if _hx_set is None else _hx_set)) + ")") + HxOverrides.stringOrNull(self.opt(t,self.printComplexType," : "))) + HxOverrides.stringOrNull(self.opt(eo,self.printExpr," = ")))
        else:
            pass
        return (("null" if tmp3 is None else tmp3) + ("null" if tmp is None else tmp))

    def printTypeParamDecl(self,tpd):
        tmp = None
        if ((Reflect.field(tpd,"meta") is not None) and ((len(Reflect.field(tpd,"meta")) > 0))):
            _this = list(map(self.printMetadata,Reflect.field(tpd,"meta")))
            tmp = (HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in _this])) + " ")
        else:
            tmp = ""
        tmp1 = (("null" if tmp is None else tmp) + HxOverrides.stringOrNull(tpd.name))
        tmp = None
        if ((Reflect.field(tpd,"params") is not None) and ((len(Reflect.field(tpd,"params")) > 0))):
            _this = list(map(self.printTypeParamDecl,Reflect.field(tpd,"params")))
            tmp = (("<" + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ">")
        else:
            tmp = ""
        tmp2 = None
        if ((Reflect.field(tpd,"constraints") is not None) and ((len(Reflect.field(tpd,"constraints")) > 0))):
            _this = list(map(self.printComplexType,Reflect.field(tpd,"constraints")))
            tmp2 = ((":(" + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")
        else:
            tmp2 = ""
        return (((("null" if tmp1 is None else tmp1) + ("null" if tmp is None else tmp)) + ("null" if tmp2 is None else tmp2)) + HxOverrides.stringOrNull(((("=" + HxOverrides.stringOrNull(self.printComplexType(Reflect.field(tpd,"defaultType")))) if ((Reflect.field(tpd,"defaultType") is not None)) else ""))))

    def printFunctionArg(self,arg):
        return (((HxOverrides.stringOrNull((("?" if (Reflect.field(arg,"opt")) else ""))) + HxOverrides.stringOrNull(arg.name)) + HxOverrides.stringOrNull(self.opt(Reflect.field(arg,"type"),self.printComplexType,":"))) + HxOverrides.stringOrNull(self.opt(Reflect.field(arg,"value"),self.printExpr," = ")))

    def printFunction(self,func,kind = None):
        skipParentheses = None
        _g = func.args
        if (len(_g) == 1):
            _g1 = (_g[0] if 0 < len(_g) else None)
            _g = Reflect.field(_g1,"meta")
            _g = _g1.name
            _g = Reflect.field(_g1,"opt")
            _g = Reflect.field(_g1,"value")
            skipParentheses = ((Reflect.field(_g1,"type") is None) and ((kind == haxe_macro_FunctionKind.FArrow)))
        else:
            skipParentheses = False
        tmp = None
        if (Reflect.field(func,"params") is None):
            tmp = ""
        elif (len(Reflect.field(func,"params")) > 0):
            _this = list(map(self.printTypeParamDecl,Reflect.field(func,"params")))
            tmp = (("<" + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ">")
        else:
            tmp = ""
        _this = list(map(self.printFunctionArg,func.args))
        return ((((((("null" if tmp is None else tmp) + HxOverrides.stringOrNull((("" if skipParentheses else "(")))) + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + HxOverrides.stringOrNull((("" if skipParentheses else ")")))) + HxOverrides.stringOrNull(((" ->" if ((kind == haxe_macro_FunctionKind.FArrow)) else "")))) + HxOverrides.stringOrNull(self.opt(Reflect.field(func,"ret"),self.printComplexType,":"))) + HxOverrides.stringOrNull(self.opt(Reflect.field(func,"expr"),self.printExpr," ")))

    def printVar(self,v):
        s = ((HxOverrides.stringOrNull(v.name) + HxOverrides.stringOrNull(self.opt(Reflect.field(v,"type"),self.printComplexType,":"))) + HxOverrides.stringOrNull(self.opt(Reflect.field(v,"expr"),self.printExpr," = ")))
        _g = Reflect.field(v,"meta")
        if (_g is None):
            return s
        elif (len(_g) == 0):
            return s
        else:
            meta = _g
            _this = list(map(self.printMetadata,meta))
            return ((HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in _this])) + " ") + ("null" if s is None else s))

    def printObjectFieldKey(self,of):
        _g = Reflect.field(of,"quotes")
        if (_g is None):
            return of.field
        else:
            tmp = _g.index
            if (tmp == 0):
                return of.field
            elif (tmp == 1):
                return (("\"" + HxOverrides.stringOrNull(of.field)) + "\"")
            else:
                pass

    def printObjectField(self,of):
        return ((("" + HxOverrides.stringOrNull(self.printObjectFieldKey(of))) + " : ") + HxOverrides.stringOrNull(self.printExpr(of.expr)))

    def printExpr(self,e):
        _gthis = self
        if (e is None):
            return "#NULL"
        else:
            _g = e.expr
            tmp = _g.index
            if (tmp == 0):
                c = _g.params[0]
                return self.printConstant(c)
            elif (tmp == 1):
                e1 = _g.params[0]
                e2 = _g.params[1]
                return (((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + "[") + HxOverrides.stringOrNull(self.printExpr(e2))) + "]")
            elif (tmp == 2):
                op = _g.params[0]
                e1 = _g.params[1]
                e2 = _g.params[2]
                return ((((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + " ") + HxOverrides.stringOrNull(self.printBinop(op))) + " ") + HxOverrides.stringOrNull(self.printExpr(e2)))
            elif (tmp == 3):
                e1 = _g.params[0]
                n = _g.params[1]
                kind = _g.params[2]
                if (kind == haxe_macro_EFieldKind.Safe):
                    return ((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + "?.") + ("null" if n is None else n))
                else:
                    return ((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + ".") + ("null" if n is None else n))
            elif (tmp == 4):
                e1 = _g.params[0]
                return (("(" + HxOverrides.stringOrNull(self.printExpr(e1))) + ")")
            elif (tmp == 5):
                fl = _g.params[0]
                def _hx_local_0(fld):
                    return _gthis.printObjectField(fld)
                _this = list(map(_hx_local_0,fl))
                return (("{ " + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this]))) + " }")
            elif (tmp == 6):
                el = _g.params[0]
                return (("[" + HxOverrides.stringOrNull(self.printExprs(el,", "))) + "]")
            elif (tmp == 7):
                e1 = _g.params[0]
                el = _g.params[1]
                return (((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + "(") + HxOverrides.stringOrNull(self.printExprs(el,", "))) + ")")
            elif (tmp == 8):
                tp = _g.params[0]
                el = _g.params[1]
                return (((("new " + HxOverrides.stringOrNull(self.printTypePath(tp))) + "(") + HxOverrides.stringOrNull(self.printExprs(el,", "))) + ")")
            elif (tmp == 9):
                _g1 = _g.params[0]
                _g2 = _g.params[2]
                if _g.params[1]:
                    op = _g1
                    e1 = _g2
                    return (HxOverrides.stringOrNull(self.printExpr(e1)) + HxOverrides.stringOrNull(self.printUnop(op)))
                else:
                    op = _g1
                    e1 = _g2
                    return (HxOverrides.stringOrNull(self.printUnop(op)) + HxOverrides.stringOrNull(self.printExpr(e1)))
            elif (tmp == 10):
                _g1 = _g.params[0]
                if (len(_g1) == 0):
                    return "var "
                else:
                    vl = _g1
                    tmp = ("static " if (Reflect.field((vl[0] if 0 < len(vl) else None),"isStatic")) else "")
                    tmp1 = ("final " if (Reflect.field((vl[0] if 0 < len(vl) else None),"isFinal")) else "var ")
                    _this = list(map(self.printVar,vl))
                    return ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this])))
            elif (tmp == 11):
                _g1 = _g.params[0]
                _g2 = _g.params[1]
                if (_g1 is None):
                    kind = _g1
                    func = _g2
                    return (HxOverrides.stringOrNull((("function" if ((kind != haxe_macro_FunctionKind.FArrow)) else ""))) + HxOverrides.stringOrNull(self.printFunction(func,kind)))
                elif (_g1.index == 1):
                    no = _g1.params[0]
                    inlined = _g1.params[1]
                    func = _g2
                    return ((HxOverrides.stringOrNull((("inline " if inlined else ""))) + HxOverrides.stringOrNull((("function " + ("null" if no is None else no))))) + HxOverrides.stringOrNull(self.printFunction(func)))
                else:
                    kind = _g1
                    func = _g2
                    return (HxOverrides.stringOrNull((("function" if ((kind != haxe_macro_FunctionKind.FArrow)) else ""))) + HxOverrides.stringOrNull(self.printFunction(func,kind)))
            elif (tmp == 12):
                _g1 = _g.params[0]
                if (len(_g1) == 0):
                    return "{ }"
                else:
                    el = _g1
                    old = self.tabs
                    _hx_local_1 = self
                    _hx_local_2 = _hx_local_1.tabs
                    _hx_local_1.tabs = (("null" if _hx_local_2 is None else _hx_local_2) + HxOverrides.stringOrNull(self.tabString))
                    _hx_local_1.tabs
                    s = (("{\n" + HxOverrides.stringOrNull(self.tabs)) + HxOverrides.stringOrNull(self.printExprs(el,(";\n" + HxOverrides.stringOrNull(self.tabs)))))
                    self.tabs = old
                    return (("null" if s is None else s) + HxOverrides.stringOrNull((((";\n" + HxOverrides.stringOrNull(self.tabs)) + "}"))))
            elif (tmp == 13):
                e1 = _g.params[0]
                e2 = _g.params[1]
                return ((("for (" + HxOverrides.stringOrNull(self.printExpr(e1))) + ") ") + HxOverrides.stringOrNull(self.printExpr(e2)))
            elif (tmp == 14):
                _g1 = _g.params[0]
                _g2 = _g.params[1]
                _g3 = _g.params[2]
                if (_g3 is None):
                    eif = _g2
                    econd = _g1
                    return ((("if (" + HxOverrides.stringOrNull(self.printExpr(econd))) + ") ") + HxOverrides.stringOrNull(self.printExpr(eif)))
                else:
                    eelse = _g3
                    eif = _g2
                    econd = _g1
                    return ((((("if (" + HxOverrides.stringOrNull(self.printExpr(econd))) + ") ") + HxOverrides.stringOrNull(self.printExpr(eif))) + " else ") + HxOverrides.stringOrNull(self.printExpr(eelse)))
            elif (tmp == 15):
                _g1 = _g.params[0]
                _g2 = _g.params[1]
                if _g.params[2]:
                    e1 = _g2
                    econd = _g1
                    return ((("while (" + HxOverrides.stringOrNull(self.printExpr(econd))) + ") ") + HxOverrides.stringOrNull(self.printExpr(e1)))
                else:
                    e1 = _g2
                    econd = _g1
                    return (((("do " + HxOverrides.stringOrNull(self.printExpr(e1))) + " while (") + HxOverrides.stringOrNull(self.printExpr(econd))) + ")")
            elif (tmp == 16):
                e1 = _g.params[0]
                cl = _g.params[1]
                edef = _g.params[2]
                old = self.tabs
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.tabs
                _hx_local_3.tabs = (("null" if _hx_local_4 is None else _hx_local_4) + HxOverrides.stringOrNull(self.tabString))
                _hx_local_3.tabs
                s = ((("switch " + HxOverrides.stringOrNull(self.printExpr(e1))) + " {\n") + HxOverrides.stringOrNull(self.tabs))
                def _hx_local_5(c):
                    return ((("case " + HxOverrides.stringOrNull(_gthis.printExprs(c.values,", "))) + HxOverrides.stringOrNull(((((" if (" + HxOverrides.stringOrNull(_gthis.printExpr(Reflect.field(c,"guard")))) + "):") if ((Reflect.field(c,"guard") is not None)) else ":")))) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(_gthis.opt(Reflect.field(c,"expr"),_gthis.printExpr)) + ";") if ((Reflect.field(c,"expr") is not None)) else ""))))
                _this = list(map(_hx_local_5,cl))
                s1 = (("null" if s is None else s) + HxOverrides.stringOrNull(("\n" + HxOverrides.stringOrNull(self.tabs)).join([python_Boot.toString1(x1,'') for x1 in _this])))
                if (edef is not None):
                    s1 = (("null" if s1 is None else s1) + HxOverrides.stringOrNull((((("\n" + HxOverrides.stringOrNull(self.tabs)) + "default:") + HxOverrides.stringOrNull((("" if ((edef.expr is None)) else (HxOverrides.stringOrNull(self.printExpr(edef)) + ";"))))))))
                self.tabs = old
                return (("null" if s1 is None else s1) + HxOverrides.stringOrNull(((("\n" + HxOverrides.stringOrNull(self.tabs)) + "}"))))
            elif (tmp == 17):
                e1 = _g.params[0]
                cl = _g.params[1]
                tmp = ("try " + HxOverrides.stringOrNull(self.printExpr(e1)))
                def _hx_local_7(c):
                    return ((((" catch(" + HxOverrides.stringOrNull(c.name)) + HxOverrides.stringOrNull((("" if ((Reflect.field(c,"type") is None)) else (":" + HxOverrides.stringOrNull(_gthis.printComplexType(Reflect.field(c,"type")))))))) + ") ") + HxOverrides.stringOrNull(_gthis.printExpr(c.expr)))
                _this = list(map(_hx_local_7,cl))
                return (("null" if tmp is None else tmp) + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _this])))
            elif (tmp == 18):
                eo = _g.params[0]
                return ("return" + HxOverrides.stringOrNull(self.opt(eo,self.printExpr," ")))
            elif (tmp == 19):
                return "break"
            elif (tmp == 20):
                return "continue"
            elif (tmp == 21):
                e1 = _g.params[0]
                return ("untyped " + HxOverrides.stringOrNull(self.printExpr(e1)))
            elif (tmp == 22):
                e1 = _g.params[0]
                return ("throw " + HxOverrides.stringOrNull(self.printExpr(e1)))
            elif (tmp == 23):
                _g1 = _g.params[0]
                e1 = _g1
                cto = _g.params[1]
                if (cto is not None):
                    return (((("cast(" + HxOverrides.stringOrNull(self.printExpr(e1))) + ", ") + HxOverrides.stringOrNull(self.printComplexType(cto))) + ")")
                else:
                    e1 = _g1
                    return ("cast " + HxOverrides.stringOrNull(self.printExpr(e1)))
            elif (tmp == 24):
                _g1 = _g.params[1]
                e1 = _g.params[0]
                return (("#DISPLAY(" + HxOverrides.stringOrNull(self.printExpr(e1))) + ")")
            elif (tmp == 25):
                econd = _g.params[0]
                eif = _g.params[1]
                eelse = _g.params[2]
                return ((((("" + HxOverrides.stringOrNull(self.printExpr(econd))) + " ? ") + HxOverrides.stringOrNull(self.printExpr(eif))) + " : ") + HxOverrides.stringOrNull(self.printExpr(eelse)))
            elif (tmp == 26):
                e1 = _g.params[0]
                ct = _g.params[1]
                return (((("(" + HxOverrides.stringOrNull(self.printExpr(e1))) + " : ") + HxOverrides.stringOrNull(self.printComplexType(ct))) + ")")
            elif (tmp == 27):
                _g1 = _g.params[0]
                _g2 = _g.params[1]
                _g3 = Reflect.field(_g1,"params")
                _g3 = _g1.pos
                if (_g1.name == ":implicitReturn"):
                    _g3 = _g2.expr
                    _g4 = _g2.pos
                    if (_g3.index == 18):
                        e1 = _g3.params[0]
                        return self.printExpr(e1)
                    else:
                        meta = _g1
                        e1 = _g2
                        return ((HxOverrides.stringOrNull(self.printMetadata(meta)) + " ") + HxOverrides.stringOrNull(self.printExpr(e1)))
                else:
                    meta = _g1
                    e1 = _g2
                    return ((HxOverrides.stringOrNull(self.printMetadata(meta)) + " ") + HxOverrides.stringOrNull(self.printExpr(e1)))
            elif (tmp == 28):
                e1 = _g.params[0]
                ct = _g.params[1]
                return ((("" + HxOverrides.stringOrNull(self.printExpr(e1))) + " is ") + HxOverrides.stringOrNull(self.printComplexType(ct)))
            else:
                pass

    def printExprs(self,el,sep):
        _this = list(map(self.printExpr,el))
        return sep.join([python_Boot.toString1(x1,'') for x1 in _this])

    def opt(self,v,f,prefix = None):
        if (prefix is None):
            prefix = ""
        if (v is None):
            return ""
        else:
            return (("null" if prefix is None else prefix) + HxOverrides.stringOrNull(f(v)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tabs = None
        _hx_o.tabString = None
haxe_macro_Printer._hx_class = haxe_macro_Printer
_hx_classes["haxe.macro.Printer"] = haxe_macro_Printer

class hscript_Const(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.Const"
    _hx_constructs = ["CInt", "CFloat", "CString"]

    @staticmethod
    def CInt(v):
        return hscript_Const("CInt", 0, (v,))

    @staticmethod
    def CFloat(f):
        return hscript_Const("CFloat", 1, (f,))

    @staticmethod
    def CString(s):
        return hscript_Const("CString", 2, (s,))
hscript_Const._hx_class = hscript_Const
_hx_classes["hscript.Const"] = hscript_Const

class hscript_Expr(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.Expr"
    _hx_constructs = ["EConst", "EIdent", "EVar", "EParent", "EBlock", "EField", "EBinop", "EUnop", "ECall", "EIf", "EWhile", "EFor", "EBreak", "EContinue", "EFunction", "EReturn", "EArray", "EArrayDecl", "ENew", "EThrow", "ETry", "EObject", "ETernary", "ESwitch", "EDoWhile", "EMeta", "ECheckType"]

    @staticmethod
    def EConst(c):
        return hscript_Expr("EConst", 0, (c,))

    @staticmethod
    def EIdent(v):
        return hscript_Expr("EIdent", 1, (v,))

    @staticmethod
    def EVar(n,t = None,e= None):
        return hscript_Expr("EVar", 2, (n,t,e))

    @staticmethod
    def EParent(e):
        return hscript_Expr("EParent", 3, (e,))

    @staticmethod
    def EBlock(e):
        return hscript_Expr("EBlock", 4, (e,))

    @staticmethod
    def EField(e,f):
        return hscript_Expr("EField", 5, (e,f))

    @staticmethod
    def EBinop(op,e1,e2):
        return hscript_Expr("EBinop", 6, (op,e1,e2))

    @staticmethod
    def EUnop(op,prefix,e):
        return hscript_Expr("EUnop", 7, (op,prefix,e))

    @staticmethod
    def ECall(e,params):
        return hscript_Expr("ECall", 8, (e,params))

    @staticmethod
    def EIf(cond,e1,e2 = None):
        return hscript_Expr("EIf", 9, (cond,e1,e2))

    @staticmethod
    def EWhile(cond,e):
        return hscript_Expr("EWhile", 10, (cond,e))

    @staticmethod
    def EFor(v,it,e):
        return hscript_Expr("EFor", 11, (v,it,e))

    @staticmethod
    def EFunction(args,e,name = None,ret= None):
        return hscript_Expr("EFunction", 14, (args,e,name,ret))

    @staticmethod
    def EReturn(e = None):
        return hscript_Expr("EReturn", 15, (e,))

    @staticmethod
    def EArray(e,index):
        return hscript_Expr("EArray", 16, (e,index))

    @staticmethod
    def EArrayDecl(e):
        return hscript_Expr("EArrayDecl", 17, (e,))

    @staticmethod
    def ENew(cl,params):
        return hscript_Expr("ENew", 18, (cl,params))

    @staticmethod
    def EThrow(e):
        return hscript_Expr("EThrow", 19, (e,))

    @staticmethod
    def ETry(e,v,t,ecatch):
        return hscript_Expr("ETry", 20, (e,v,t,ecatch))

    @staticmethod
    def EObject(fl):
        return hscript_Expr("EObject", 21, (fl,))

    @staticmethod
    def ETernary(cond,e1,e2):
        return hscript_Expr("ETernary", 22, (cond,e1,e2))

    @staticmethod
    def ESwitch(e,cases,defaultExpr = None):
        return hscript_Expr("ESwitch", 23, (e,cases,defaultExpr))

    @staticmethod
    def EDoWhile(cond,e):
        return hscript_Expr("EDoWhile", 24, (cond,e))

    @staticmethod
    def EMeta(name,args,e):
        return hscript_Expr("EMeta", 25, (name,args,e))

    @staticmethod
    def ECheckType(e,t):
        return hscript_Expr("ECheckType", 26, (e,t))
hscript_Expr.EBreak = hscript_Expr("EBreak", 12, ())
hscript_Expr.EContinue = hscript_Expr("EContinue", 13, ())
hscript_Expr._hx_class = hscript_Expr
_hx_classes["hscript.Expr"] = hscript_Expr

class hscript_CType(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.CType"
    _hx_constructs = ["CTPath", "CTFun", "CTAnon", "CTParent", "CTOpt", "CTNamed"]

    @staticmethod
    def CTPath(path,params = None):
        return hscript_CType("CTPath", 0, (path,params))

    @staticmethod
    def CTFun(args,ret):
        return hscript_CType("CTFun", 1, (args,ret))

    @staticmethod
    def CTAnon(fields):
        return hscript_CType("CTAnon", 2, (fields,))

    @staticmethod
    def CTParent(t):
        return hscript_CType("CTParent", 3, (t,))

    @staticmethod
    def CTOpt(t):
        return hscript_CType("CTOpt", 4, (t,))

    @staticmethod
    def CTNamed(n,t):
        return hscript_CType("CTNamed", 5, (n,t))
hscript_CType._hx_class = hscript_CType
_hx_classes["hscript.CType"] = hscript_CType

class hscript_Error(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.Error"
    _hx_constructs = ["EInvalidChar", "EUnexpected", "EUnterminatedString", "EUnterminatedComment", "EInvalidPreprocessor", "EUnknownVariable", "EInvalidIterator", "EInvalidOp", "EInvalidAccess", "ECustom"]

    @staticmethod
    def EInvalidChar(c):
        return hscript_Error("EInvalidChar", 0, (c,))

    @staticmethod
    def EUnexpected(s):
        return hscript_Error("EUnexpected", 1, (s,))

    @staticmethod
    def EInvalidPreprocessor(msg):
        return hscript_Error("EInvalidPreprocessor", 4, (msg,))

    @staticmethod
    def EUnknownVariable(v):
        return hscript_Error("EUnknownVariable", 5, (v,))

    @staticmethod
    def EInvalidIterator(v):
        return hscript_Error("EInvalidIterator", 6, (v,))

    @staticmethod
    def EInvalidOp(op):
        return hscript_Error("EInvalidOp", 7, (op,))

    @staticmethod
    def EInvalidAccess(f):
        return hscript_Error("EInvalidAccess", 8, (f,))

    @staticmethod
    def ECustom(msg):
        return hscript_Error("ECustom", 9, (msg,))
hscript_Error.EUnterminatedString = hscript_Error("EUnterminatedString", 2, ())
hscript_Error.EUnterminatedComment = hscript_Error("EUnterminatedComment", 3, ())
hscript_Error._hx_class = hscript_Error
_hx_classes["hscript.Error"] = hscript_Error

class hscript_ModuleDecl(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.ModuleDecl"
    _hx_constructs = ["DPackage", "DImport", "DClass", "DTypedef"]

    @staticmethod
    def DPackage(path):
        return hscript_ModuleDecl("DPackage", 0, (path,))

    @staticmethod
    def DImport(path,everything = None):
        return hscript_ModuleDecl("DImport", 1, (path,everything))

    @staticmethod
    def DClass(c):
        return hscript_ModuleDecl("DClass", 2, (c,))

    @staticmethod
    def DTypedef(c):
        return hscript_ModuleDecl("DTypedef", 3, (c,))
hscript_ModuleDecl._hx_class = hscript_ModuleDecl
_hx_classes["hscript.ModuleDecl"] = hscript_ModuleDecl

class hscript_FieldAccess(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.FieldAccess"
    _hx_constructs = ["APublic", "APrivate", "AInline", "AOverride", "AStatic", "AMacro"]
hscript_FieldAccess.APublic = hscript_FieldAccess("APublic", 0, ())
hscript_FieldAccess.APrivate = hscript_FieldAccess("APrivate", 1, ())
hscript_FieldAccess.AInline = hscript_FieldAccess("AInline", 2, ())
hscript_FieldAccess.AOverride = hscript_FieldAccess("AOverride", 3, ())
hscript_FieldAccess.AStatic = hscript_FieldAccess("AStatic", 4, ())
hscript_FieldAccess.AMacro = hscript_FieldAccess("AMacro", 5, ())
hscript_FieldAccess._hx_class = hscript_FieldAccess
_hx_classes["hscript.FieldAccess"] = hscript_FieldAccess

class hscript_FieldKind(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.FieldKind"
    _hx_constructs = ["KFunction", "KVar"]

    @staticmethod
    def KFunction(f):
        return hscript_FieldKind("KFunction", 0, (f,))

    @staticmethod
    def KVar(v):
        return hscript_FieldKind("KVar", 1, (v,))
hscript_FieldKind._hx_class = hscript_FieldKind
_hx_classes["hscript.FieldKind"] = hscript_FieldKind

class hscript__Interp_Stop(Enum):
    __slots__ = ()
    _hx_class_name = "hscript._Interp.Stop"
    _hx_constructs = ["SBreak", "SContinue", "SReturn"]
hscript__Interp_Stop.SBreak = hscript__Interp_Stop("SBreak", 0, ())
hscript__Interp_Stop.SContinue = hscript__Interp_Stop("SContinue", 1, ())
hscript__Interp_Stop.SReturn = hscript__Interp_Stop("SReturn", 2, ())
hscript__Interp_Stop._hx_class = hscript__Interp_Stop
_hx_classes["hscript._Interp.Stop"] = hscript__Interp_Stop


class hscript_Interp:
    _hx_class_name = "hscript.Interp"
    __slots__ = ("variables", "locals", "binops", "depth", "inTry", "declared", "returnValue")
    _hx_fields = ["variables", "locals", "binops", "depth", "inTry", "declared", "returnValue"]
    _hx_methods = ["resetVariables", "posInfos", "initOps", "setVar", "assign", "assignOp", "evalAssignOp", "increment", "execute", "exprReturn", "duplicate", "restore", "error", "rethrow", "resolve", "expr", "doWhileLoop", "whileLoop", "makeIterator", "forLoop", "isMap", "getMapValue", "setMapValue", "get", "set", "fcall", "call", "cnew"]

    def __init__(self):
        self.returnValue = None
        self.inTry = None
        self.depth = None
        self.binops = None
        self.variables = None
        self.locals = haxe_ds_StringMap()
        self.declared = list()
        self.resetVariables()
        self.initOps()

    def resetVariables(self):
        _gthis = self
        self.variables = haxe_ds_StringMap()
        self.variables.h["null"] = None
        self.variables.h["true"] = True
        self.variables.h["false"] = False
        this1 = self.variables
        def _hx_local_0(el):
            inf = _gthis.posInfos()
            v = (None if ((len(el) == 0)) else el.pop(0))
            if (len(el) > 0):
                Reflect.setField(inf,"customParams",el)
            haxe_Log.trace(Std.string(v),inf)
        value = Reflect.makeVarArgs(_hx_local_0)
        this1.h["trace"] = value

    def posInfos(self):
        return _hx_AnonObject({'fileName': "hscript", 'lineNumber': 0})

    def initOps(self):
        me = self
        self.binops = haxe_ds_StringMap()
        def _hx_local_0(e1,e2):
            return python_Boot._add_dynamic(me.expr(e1),me.expr(e2))
        self.binops.h["+"] = _hx_local_0
        def _hx_local_1(e1,e2):
            return (me.expr(e1) - me.expr(e2))
        self.binops.h["-"] = _hx_local_1
        def _hx_local_2(e1,e2):
            return (me.expr(e1) * me.expr(e2))
        self.binops.h["*"] = _hx_local_2
        def _hx_local_3(e1,e2):
            return (me.expr(e1) / me.expr(e2))
        self.binops.h["/"] = _hx_local_3
        def _hx_local_4(e1,e2):
            return HxOverrides.modf(me.expr(e1), me.expr(e2))
        self.binops.h["%"] = _hx_local_4
        def _hx_local_5(e1,e2):
            return (me.expr(e1) & me.expr(e2))
        self.binops.h["&"] = _hx_local_5
        def _hx_local_6(e1,e2):
            return (me.expr(e1) | me.expr(e2))
        self.binops.h["|"] = _hx_local_6
        def _hx_local_7(e1,e2):
            return (me.expr(e1) ^ me.expr(e2))
        self.binops.h["^"] = _hx_local_7
        def _hx_local_8(e1,e2):
            return (me.expr(e1) << me.expr(e2))
        self.binops.h["<<"] = _hx_local_8
        def _hx_local_9(e1,e2):
            return (me.expr(e1) >> me.expr(e2))
        self.binops.h[">>"] = _hx_local_9
        def _hx_local_10(e1,e2):
            return HxOverrides.rshift(me.expr(e1), me.expr(e2))
        self.binops.h[">>>"] = _hx_local_10
        def _hx_local_11(e1,e2):
            return HxOverrides.eq(me.expr(e1),me.expr(e2))
        self.binops.h["=="] = _hx_local_11
        def _hx_local_12(e1,e2):
            return not HxOverrides.eq(me.expr(e1),me.expr(e2))
        self.binops.h["!="] = _hx_local_12
        def _hx_local_13(e1,e2):
            return (me.expr(e1) >= me.expr(e2))
        self.binops.h[">="] = _hx_local_13
        def _hx_local_14(e1,e2):
            return (me.expr(e1) <= me.expr(e2))
        self.binops.h["<="] = _hx_local_14
        def _hx_local_15(e1,e2):
            return (me.expr(e1) > me.expr(e2))
        self.binops.h[">"] = _hx_local_15
        def _hx_local_16(e1,e2):
            return (me.expr(e1) < me.expr(e2))
        self.binops.h["<"] = _hx_local_16
        def _hx_local_17(e1,e2):
            if (me.expr(e1) != True):
                return (me.expr(e2) == True)
            else:
                return True
        self.binops.h["||"] = _hx_local_17
        def _hx_local_18(e1,e2):
            if (me.expr(e1) == True):
                return (me.expr(e2) == True)
            else:
                return False
        self.binops.h["&&"] = _hx_local_18
        self.binops.h["="] = self.assign
        def _hx_local_19(e1,e2):
            return IntIterator(me.expr(e1),me.expr(e2))
        self.binops.h["..."] = _hx_local_19
        def _hx_local_20(v1,v2):
            return python_Boot._add_dynamic(v1,v2)
        self.assignOp("+=",_hx_local_20)
        def _hx_local_21(v1,v2):
            return (v1 - v2)
        self.assignOp("-=",_hx_local_21)
        def _hx_local_22(v1,v2):
            return (v1 * v2)
        self.assignOp("*=",_hx_local_22)
        def _hx_local_23(v1,v2):
            return (v1 / v2)
        self.assignOp("/=",_hx_local_23)
        def _hx_local_24(v1,v2):
            return HxOverrides.modf(v1, v2)
        self.assignOp("%=",_hx_local_24)
        def _hx_local_25(v1,v2):
            return (v1 & v2)
        self.assignOp("&=",_hx_local_25)
        def _hx_local_26(v1,v2):
            return (v1 | v2)
        self.assignOp("|=",_hx_local_26)
        def _hx_local_27(v1,v2):
            return (v1 ^ v2)
        self.assignOp("^=",_hx_local_27)
        def _hx_local_28(v1,v2):
            return (v1 << v2)
        self.assignOp("<<=",_hx_local_28)
        def _hx_local_29(v1,v2):
            return (v1 >> v2)
        self.assignOp(">>=",_hx_local_29)
        def _hx_local_30(v1,v2):
            return HxOverrides.rshift(v1, v2)
        self.assignOp(">>>=",_hx_local_30)

    def setVar(self,name,v):
        self.variables.h[name] = v

    def assign(self,e1,e2):
        v = self.expr(e2)
        tmp = e1.index
        if (tmp == 1):
            id = e1.params[0]
            l = self.locals.h.get(id,None)
            if (l is None):
                self.setVar(id,v)
            else:
                l.r = v
        elif (tmp == 5):
            e = e1.params[0]
            f = e1.params[1]
            v = self.set(self.expr(e),f,v)
        elif (tmp == 16):
            e = e1.params[0]
            index = e1.params[1]
            arr = self.expr(e)
            index1 = self.expr(index)
            if Std.isOfType(arr,haxe_IMap):
                def _hx_local_1():
                    _hx_local_0 = arr
                    if (Std.isOfType(_hx_local_0,haxe_IMap) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                (_hx_local_1()).set(index1,v)
            else:
                HxOverrides.arraySet(arr,index1,v)
        else:
            e = hscript_Error.EInvalidOp("=")
            raise haxe_Exception.thrown(e)
        return v

    def assignOp(self,op,fop):
        me = self
        def _hx_local_0(e1,e2):
            return me.evalAssignOp(op,fop,e1,e2)
        self.binops.h[op] = _hx_local_0

    def evalAssignOp(self,op,fop,e1,e2):
        v = None
        tmp = e1.index
        if (tmp == 1):
            id = e1.params[0]
            l = self.locals.h.get(id,None)
            v = fop(self.expr(e1),self.expr(e2))
            if (l is None):
                self.setVar(id,v)
            else:
                l.r = v
        elif (tmp == 5):
            e = e1.params[0]
            f = e1.params[1]
            obj = self.expr(e)
            v = fop(self.get(obj,f),self.expr(e2))
            v = self.set(obj,f,v)
        elif (tmp == 16):
            e = e1.params[0]
            index = e1.params[1]
            arr = self.expr(e)
            index1 = self.expr(index)
            if Std.isOfType(arr,haxe_IMap):
                def _hx_local_1():
                    _hx_local_0 = arr
                    if (Std.isOfType(_hx_local_0,haxe_IMap) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                v = fop((_hx_local_1()).get(index1),self.expr(e2))
                def _hx_local_3():
                    _hx_local_2 = arr
                    if (Std.isOfType(_hx_local_2,haxe_IMap) or ((_hx_local_2 is None))):
                        _hx_local_2
                    else:
                        raise "Class cast error"
                    return _hx_local_2
                (_hx_local_3()).set(index1,v)
            else:
                v = fop(HxOverrides.arrayGet(arr, index1),self.expr(e2))
                HxOverrides.arraySet(arr,index1,v)
        else:
            e = hscript_Error.EInvalidOp(op)
            raise haxe_Exception.thrown(e)
        return v

    def increment(self,e,prefix,delta):
        tmp = e.index
        if (tmp == 1):
            id = e.params[0]
            l = self.locals.h.get(id,None)
            v = (self.resolve(id) if ((l is None)) else l.r)
            if prefix:
                v = python_Boot._add_dynamic(v,delta)
                if (l is None):
                    self.setVar(id,v)
                else:
                    l.r = v
            elif (l is None):
                self.setVar(id,python_Boot._add_dynamic(v,delta))
            else:
                l.r = python_Boot._add_dynamic(v,delta)
            return v
        elif (tmp == 5):
            e1 = e.params[0]
            f = e.params[1]
            obj = self.expr(e1)
            v = self.get(obj,f)
            if prefix:
                v = python_Boot._add_dynamic(v,delta)
                self.set(obj,f,v)
            else:
                self.set(obj,f,python_Boot._add_dynamic(v,delta))
            return v
        elif (tmp == 16):
            e1 = e.params[0]
            index = e.params[1]
            arr = self.expr(e1)
            index1 = self.expr(index)
            if Std.isOfType(arr,haxe_IMap):
                def _hx_local_3():
                    _hx_local_2 = arr
                    if (Std.isOfType(_hx_local_2,haxe_IMap) or ((_hx_local_2 is None))):
                        _hx_local_2
                    else:
                        raise "Class cast error"
                    return _hx_local_2
                v = (_hx_local_3()).get(index1)
                if prefix:
                    v = python_Boot._add_dynamic(v,delta)
                    def _hx_local_6():
                        _hx_local_5 = arr
                        if (Std.isOfType(_hx_local_5,haxe_IMap) or ((_hx_local_5 is None))):
                            _hx_local_5
                        else:
                            raise "Class cast error"
                        return _hx_local_5
                    (_hx_local_6()).set(index1,v)
                else:
                    def _hx_local_8():
                        _hx_local_7 = arr
                        if (Std.isOfType(_hx_local_7,haxe_IMap) or ((_hx_local_7 is None))):
                            _hx_local_7
                        else:
                            raise "Class cast error"
                        return _hx_local_7
                    (_hx_local_8()).set(index1,python_Boot._add_dynamic(v,delta))
                return v
            else:
                v = HxOverrides.arrayGet(arr, index1)
                if prefix:
                    v = (v + delta)
                    HxOverrides.arraySet(arr,index1,v)
                else:
                    HxOverrides.arraySet(arr,index1,(v + delta))
                return v
        else:
            e = hscript_Error.EInvalidOp(("++" if ((delta > 0)) else "--"))
            raise haxe_Exception.thrown(e)

    def execute(self,expr):
        self.depth = 0
        self.locals = haxe_ds_StringMap()
        self.declared = list()
        return self.exprReturn(expr)

    def exprReturn(self,e):
        try:
            return self.expr(e)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hscript__Interp_Stop):
                e = _g1
                tmp = e.index
                if (tmp == 0):
                    raise haxe_Exception.thrown("Invalid break")
                elif (tmp == 1):
                    raise haxe_Exception.thrown("Invalid continue")
                elif (tmp == 2):
                    v = self.returnValue
                    self.returnValue = None
                    return v
                else:
                    pass
            else:
                raise _g

    def duplicate(self,h):
        h2 = haxe_ds_StringMap()
        k = h.keys()
        while k.hasNext():
            k1 = k.next()
            value = h.h.get(k1,None)
            h2.h[k1] = value
        return h2

    def restore(self,old):
        while (len(self.declared) > old):
            _this = self.declared
            d = (None if ((len(_this) == 0)) else _this.pop())
            self.locals.h[d.n] = d.old

    def error(self,e,rethrow = None):
        if (rethrow is None):
            rethrow = False
        if rethrow:
            raise haxe_Exception.thrown(e)
        else:
            raise haxe_Exception.thrown(e)

    def rethrow(self,e):
        raise haxe_Exception.thrown(e)

    def resolve(self,id):
        l = self.locals.h.get(id,None)
        if (l is not None):
            return l.r
        v = self.variables.h.get(id,None)
        if ((v is None) and (not (id in self.variables.h))):
            e = hscript_Error.EUnknownVariable(id)
            raise haxe_Exception.thrown(e)
        return v

    def expr(self,e):
        _gthis = self
        tmp = e.index
        if (tmp == 0):
            c = e.params[0]
            tmp = c.index
            if (tmp == 0):
                v = c.params[0]
                return v
            elif (tmp == 1):
                f = c.params[0]
                return f
            elif (tmp == 2):
                s = c.params[0]
                return s
            else:
                pass
        elif (tmp == 1):
            id = e.params[0]
            return self.resolve(id)
        elif (tmp == 2):
            _g = e.params[1]
            n = e.params[0]
            e1 = e.params[2]
            _this = self.declared
            x = _hx_AnonObject({'n': n, 'old': self.locals.h.get(n,None)})
            _this.append(x)
            this1 = self.locals
            value = (None if ((e1 is None)) else self.expr(e1))
            this1.h[n] = _hx_AnonObject({'r': value})
            return None
        elif (tmp == 3):
            e1 = e.params[0]
            return self.expr(e1)
        elif (tmp == 4):
            exprs = e.params[0]
            old = len(self.declared)
            v = None
            _g = 0
            while (_g < len(exprs)):
                e1 = (exprs[_g] if _g >= 0 and _g < len(exprs) else None)
                _g = (_g + 1)
                v = self.expr(e1)
            self.restore(old)
            return v
        elif (tmp == 5):
            e1 = e.params[0]
            f = e.params[1]
            return self.get(self.expr(e1),f)
        elif (tmp == 6):
            op = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            fop = self.binops.h.get(op,None)
            if (fop is None):
                e3 = hscript_Error.EInvalidOp(op)
                raise haxe_Exception.thrown(e3)
            return fop(e1,e2)
        elif (tmp == 7):
            op = e.params[0]
            prefix = e.params[1]
            e1 = e.params[2]
            op1 = op
            _hx_local_1 = len(op1)
            if (_hx_local_1 == 1):
                if (op1 == "!"):
                    return (self.expr(e1) != True)
                elif (op1 == "-"):
                    return -self.expr(e1)
                elif (op1 == "~"):
                    return ~self.expr(e1)
                else:
                    e1 = hscript_Error.EInvalidOp(op)
                    raise haxe_Exception.thrown(e1)
            elif (_hx_local_1 == 2):
                if (op1 == "++"):
                    return self.increment(e1,prefix,1)
                elif (op1 == "--"):
                    return self.increment(e1,prefix,-1)
                else:
                    e1 = hscript_Error.EInvalidOp(op)
                    raise haxe_Exception.thrown(e1)
            else:
                e1 = hscript_Error.EInvalidOp(op)
                raise haxe_Exception.thrown(e1)
        elif (tmp == 8):
            e1 = e.params[0]
            params = e.params[1]
            args = list()
            _g = 0
            while (_g < len(params)):
                p = (params[_g] if _g >= 0 and _g < len(params) else None)
                _g = (_g + 1)
                x = self.expr(p)
                args.append(x)
            if (e1.index == 5):
                e2 = e1.params[0]
                f = e1.params[1]
                obj = self.expr(e2)
                if (obj is None):
                    e2 = hscript_Error.EInvalidAccess(f)
                    raise haxe_Exception.thrown(e2)
                return self.fcall(obj,f,args)
            else:
                return self.call(None,self.expr(e1),args)
        elif (tmp == 9):
            econd = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            if (self.expr(econd) == True):
                return self.expr(e1)
            elif (e2 is None):
                return None
            else:
                return self.expr(e2)
        elif (tmp == 10):
            econd = e.params[0]
            e1 = e.params[1]
            self.whileLoop(econd,e1)
            return None
        elif (tmp == 11):
            v = e.params[0]
            it = e.params[1]
            e1 = e.params[2]
            self.forLoop(v,it,e1)
            return None
        elif (tmp == 12):
            raise haxe_Exception.thrown(hscript__Interp_Stop.SBreak)
        elif (tmp == 13):
            raise haxe_Exception.thrown(hscript__Interp_Stop.SContinue)
        elif (tmp == 14):
            _g = e.params[3]
            params = e.params[0]
            fexpr = e.params[1]
            name = e.params[2]
            capturedLocals = self.duplicate(self.locals)
            me = self
            hasOpt = False
            minParams = 0
            _g = 0
            while (_g < len(params)):
                p = (params[_g] if _g >= 0 and _g < len(params) else None)
                _g = (_g + 1)
                if Reflect.field(p,"opt"):
                    hasOpt = True
                else:
                    minParams = (minParams + 1)
            def _hx_local_9(args):
                if (((0 if ((args is None)) else len(args))) != len(params)):
                    if (len(args) < minParams):
                        _hx_str = ((("Invalid number of parameters. Got " + Std.string(len(args))) + ", required ") + Std.string(minParams))
                        if (name is not None):
                            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull((((" for function '" + ("null" if name is None else name)) + "'"))))
                        e = hscript_Error.ECustom(_hx_str)
                        raise haxe_Exception.thrown(e)
                    args2 = []
                    extraParams = (len(args) - minParams)
                    pos = 0
                    _g = 0
                    while (_g < len(params)):
                        p = (params[_g] if _g >= 0 and _g < len(params) else None)
                        _g = (_g + 1)
                        if Reflect.field(p,"opt"):
                            if (extraParams > 0):
                                x = pos
                                pos = (pos + 1)
                                x1 = (args[x] if x >= 0 and x < len(args) else None)
                                args2.append(x1)
                                extraParams = (extraParams - 1)
                            else:
                                args2.append(None)
                        else:
                            x2 = pos
                            pos = (pos + 1)
                            x3 = (args[x2] if x2 >= 0 and x2 < len(args) else None)
                            args2.append(x3)
                    args = args2
                old = me.locals
                depth = me.depth
                me.depth = (me.depth + 1)
                me.locals = me.duplicate(capturedLocals)
                _g = 0
                _g1 = len(params)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    me.locals.h[(params[i] if i >= 0 and i < len(params) else None).name] = _hx_AnonObject({'r': (args[i] if i >= 0 and i < len(args) else None)})
                r = None
                oldDecl = len(_gthis.declared)
                if _gthis.inTry:
                    try:
                        r = me.exprReturn(fexpr)
                    except BaseException as _g:
                        None
                        e = haxe_Exception.caught(_g).unwrap()
                        me.locals = old
                        me.depth = depth
                        raise haxe_Exception.thrown(e)
                else:
                    r = me.exprReturn(fexpr)
                _gthis.restore(oldDecl)
                me.locals = old
                me.depth = depth
                return r
            f = _hx_local_9
            f1 = Reflect.makeVarArgs(f)
            if (name is not None):
                if (self.depth == 0):
                    self.variables.h[name] = f1
                else:
                    _this = self.declared
                    x = _hx_AnonObject({'n': name, 'old': self.locals.h.get(name,None)})
                    _this.append(x)
                    ref = _hx_AnonObject({'r': f1})
                    self.locals.h[name] = ref
                    capturedLocals.h[name] = ref
            return f1
        elif (tmp == 15):
            e1 = e.params[0]
            self.returnValue = (None if ((e1 is None)) else self.expr(e1))
            raise haxe_Exception.thrown(hscript__Interp_Stop.SReturn)
        elif (tmp == 16):
            e1 = e.params[0]
            index = e.params[1]
            arr = self.expr(e1)
            index1 = self.expr(index)
            if Std.isOfType(arr,haxe_IMap):
                def _hx_local_12():
                    def _hx_local_11():
                        _hx_local_10 = arr
                        if (Std.isOfType(_hx_local_10,haxe_IMap) or ((_hx_local_10 is None))):
                            _hx_local_10
                        else:
                            raise "Class cast error"
                        return _hx_local_10
                    return (_hx_local_11()).get(index1)
                return _hx_local_12()
            else:
                return HxOverrides.arrayGet(arr, index1)
        elif (tmp == 17):
            arr = e.params[0]
            tmp = None
            if (len(arr) > 0):
                _g = (arr[0] if 0 < len(arr) else None)
                if (_g.index == 6):
                    _g1 = _g.params[1]
                    _g1 = _g.params[2]
                    tmp = (_g.params[0] == "=>")
                else:
                    tmp = False
            else:
                tmp = False
            if tmp:
                isAllString = True
                isAllInt = True
                isAllObject = True
                isAllEnum = True
                keys = []
                values = []
                _g = 0
                while (_g < len(arr)):
                    e1 = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                    _g = (_g + 1)
                    if (e1.index == 6):
                        if (e1.params[0] == "=>"):
                            eKey = e1.params[1]
                            eValue = e1.params[2]
                            key = self.expr(eKey)
                            value = self.expr(eValue)
                            isAllString = (isAllString and Std.isOfType(key,str))
                            isAllInt = (isAllInt and Std.isOfType(key,Int))
                            isAllObject = (isAllObject and Reflect.isObject(key))
                            isAllEnum = (isAllEnum and Reflect.isEnumValue(key))
                            keys.append(key)
                            values.append(value)
                        else:
                            raise haxe_Exception.thrown("=> expected")
                    else:
                        raise haxe_Exception.thrown("=> expected")
                _hx_map = None
                if isAllInt:
                    _hx_map = haxe_ds_IntMap()
                elif isAllString:
                    _hx_map = haxe_ds_StringMap()
                elif isAllEnum:
                    _hx_map = haxe_ds_EnumValueMap()
                elif isAllObject:
                    _hx_map = haxe_ds_ObjectMap()
                else:
                    raise haxe_Exception.thrown("Inconsistent key types")
                _g = 0
                _g1 = len(keys)
                while (_g < _g1):
                    n = _g
                    _g = (_g + 1)
                    def _hx_local_15():
                        _hx_local_14 = _hx_map
                        if (Std.isOfType(_hx_local_14,haxe_IMap) or ((_hx_local_14 is None))):
                            _hx_local_14
                        else:
                            raise "Class cast error"
                        return _hx_local_14
                    (_hx_local_15()).set((keys[n] if n >= 0 and n < len(keys) else None),(values[n] if n >= 0 and n < len(values) else None))
                return _hx_map
            else:
                a = list()
                _g = 0
                while (_g < len(arr)):
                    e1 = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                    _g = (_g + 1)
                    x = self.expr(e1)
                    a.append(x)
                return a
        elif (tmp == 18):
            cl = e.params[0]
            params1 = e.params[1]
            a = list()
            _g = 0
            while (_g < len(params1)):
                e1 = (params1[_g] if _g >= 0 and _g < len(params1) else None)
                _g = (_g + 1)
                x = self.expr(e1)
                a.append(x)
            return self.cnew(cl,a)
        elif (tmp == 19):
            e1 = e.params[0]
            raise haxe_Exception.thrown(self.expr(e1))
        elif (tmp == 20):
            _g = e.params[2]
            e1 = e.params[0]
            n = e.params[1]
            ecatch = e.params[3]
            old = len(self.declared)
            oldTry = self.inTry
            try:
                self.inTry = True
                v = self.expr(e1)
                self.restore(old)
                self.inTry = oldTry
                return v
            except BaseException as _g:
                None
                _g1 = haxe_Exception.caught(_g).unwrap()
                if Std.isOfType(_g1,hscript__Interp_Stop):
                    err = _g1
                    self.inTry = oldTry
                    raise haxe_Exception.thrown(err)
                else:
                    err = _g1
                    self.restore(old)
                    self.inTry = oldTry
                    _this = self.declared
                    x = _hx_AnonObject({'n': n, 'old': self.locals.h.get(n,None)})
                    _this.append(x)
                    self.locals.h[n] = _hx_AnonObject({'r': err})
                    v = self.expr(ecatch)
                    self.restore(old)
                    return v
        elif (tmp == 21):
            fl = e.params[0]
            o = _hx_AnonObject({})
            _g = 0
            while (_g < len(fl)):
                f = (fl[_g] if _g >= 0 and _g < len(fl) else None)
                _g = (_g + 1)
                self.set(o,f.name,self.expr(f.e))
            return o
        elif (tmp == 22):
            econd = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            if (self.expr(econd) == True):
                return self.expr(e1)
            else:
                return self.expr(e2)
        elif (tmp == 23):
            e1 = e.params[0]
            cases = e.params[1]
            _hx_def = e.params[2]
            val = self.expr(e1)
            match = False
            _g = 0
            while (_g < len(cases)):
                c = (cases[_g] if _g >= 0 and _g < len(cases) else None)
                _g = (_g + 1)
                _g1 = 0
                _g2 = c.values
                while (_g1 < len(_g2)):
                    v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    if HxOverrides.eq(self.expr(v),val):
                        match = True
                        break
                if match:
                    val = self.expr(c.expr)
                    break
            if (not match):
                val = (None if ((_hx_def is None)) else self.expr(_hx_def))
            return val
        elif (tmp == 24):
            econd = e.params[0]
            e1 = e.params[1]
            self.doWhileLoop(econd,e1)
            return None
        elif (tmp == 25):
            _g = e.params[0]
            _g = e.params[1]
            e1 = e.params[2]
            return self.expr(e1)
        elif (tmp == 26):
            _g = e.params[1]
            e1 = e.params[0]
            return self.expr(e1)
        else:
            pass

    def doWhileLoop(self,econd,e):
        old = len(self.declared)
        while True:
            try:
                self.expr(e)
            except BaseException as _g:
                None
                _g1 = haxe_Exception.caught(_g).unwrap()
                if Std.isOfType(_g1,hscript__Interp_Stop):
                    err = _g1
                    tmp = err.index
                    if (tmp == 0):
                        break
                    elif (tmp == 1):
                        pass
                    elif (tmp == 2):
                        raise haxe_Exception.thrown(err)
                    else:
                        pass
                else:
                    raise _g
            if (not ((self.expr(econd) == True))):
                break
        self.restore(old)

    def whileLoop(self,econd,e):
        old = len(self.declared)
        while (self.expr(econd) == True):
            try:
                self.expr(e)
            except BaseException as _g:
                None
                _g1 = haxe_Exception.caught(_g).unwrap()
                if Std.isOfType(_g1,hscript__Interp_Stop):
                    err = _g1
                    tmp = err.index
                    if (tmp == 0):
                        break
                    elif (tmp == 1):
                        pass
                    elif (tmp == 2):
                        raise haxe_Exception.thrown(err)
                    else:
                        pass
                else:
                    raise _g
        self.restore(old)

    def makeIterator(self,v):
        try:
            v = Reflect.field(v,"iterator")()
        except BaseException as _g:
            None
        if ((Reflect.field(v,"hasNext") is None) or ((Reflect.field(v,"next") is None))):
            e = hscript_Error.EInvalidIterator(v)
            raise haxe_Exception.thrown(e)
        return v

    def forLoop(self,n,it,e):
        old = len(self.declared)
        _this = self.declared
        x = _hx_AnonObject({'n': n, 'old': self.locals.h.get(n,None)})
        _this.append(x)
        it1 = self.makeIterator(self.expr(it))
        while it1.hasNext():
            this1 = self.locals
            value = _hx_AnonObject({'r': it1.next()})
            this1.h[n] = value
            try:
                self.expr(e)
            except BaseException as _g:
                None
                _g1 = haxe_Exception.caught(_g).unwrap()
                if Std.isOfType(_g1,hscript__Interp_Stop):
                    err = _g1
                    tmp = err.index
                    if (tmp == 0):
                        break
                    elif (tmp == 1):
                        pass
                    elif (tmp == 2):
                        raise haxe_Exception.thrown(err)
                    else:
                        pass
                else:
                    raise _g
        self.restore(old)

    def isMap(self,o):
        return Std.isOfType(o,haxe_IMap)

    def getMapValue(self,_hx_map,key):
        def _hx_local_2():
            def _hx_local_1():
                _hx_local_0 = _hx_map
                if (Std.isOfType(_hx_local_0,haxe_IMap) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            return (_hx_local_1()).get(key)
        return _hx_local_2()

    def setMapValue(self,_hx_map,key,value):
        def _hx_local_1():
            _hx_local_0 = _hx_map
            if (Std.isOfType(_hx_local_0,haxe_IMap) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        (_hx_local_1()).set(key,value)

    def get(self,o,f):
        if (o is None):
            e = hscript_Error.EInvalidAccess(f)
            raise haxe_Exception.thrown(e)
        return Reflect.getProperty(o,f)

    def set(self,o,f,v):
        if (o is None):
            e = hscript_Error.EInvalidAccess(f)
            raise haxe_Exception.thrown(e)
        Reflect.setProperty(o,f,v)
        return v

    def fcall(self,o,f,args):
        return self.call(o,self.get(o,f),args)

    def call(self,o,f,args):
        return Reflect.callMethod(o,f,args)

    def cnew(self,cl,args):
        c = Type.resolveClass(cl)
        if (c is None):
            c = self.resolve(cl)
        return c(*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.variables = None
        _hx_o.locals = None
        _hx_o.binops = None
        _hx_o.depth = None
        _hx_o.inTry = None
        _hx_o.declared = None
        _hx_o.returnValue = None
hscript_Interp._hx_class = hscript_Interp
_hx_classes["hscript.Interp"] = hscript_Interp

class hscript_Token(Enum):
    __slots__ = ()
    _hx_class_name = "hscript.Token"
    _hx_constructs = ["TEof", "TConst", "TId", "TOp", "TPOpen", "TPClose", "TBrOpen", "TBrClose", "TDot", "TComma", "TSemicolon", "TBkOpen", "TBkClose", "TQuestion", "TDoubleDot", "TMeta", "TPrepro"]

    @staticmethod
    def TConst(c):
        return hscript_Token("TConst", 1, (c,))

    @staticmethod
    def TId(s):
        return hscript_Token("TId", 2, (s,))

    @staticmethod
    def TOp(s):
        return hscript_Token("TOp", 3, (s,))

    @staticmethod
    def TMeta(s):
        return hscript_Token("TMeta", 15, (s,))

    @staticmethod
    def TPrepro(s):
        return hscript_Token("TPrepro", 16, (s,))
hscript_Token.TEof = hscript_Token("TEof", 0, ())
hscript_Token.TPOpen = hscript_Token("TPOpen", 4, ())
hscript_Token.TPClose = hscript_Token("TPClose", 5, ())
hscript_Token.TBrOpen = hscript_Token("TBrOpen", 6, ())
hscript_Token.TBrClose = hscript_Token("TBrClose", 7, ())
hscript_Token.TDot = hscript_Token("TDot", 8, ())
hscript_Token.TComma = hscript_Token("TComma", 9, ())
hscript_Token.TSemicolon = hscript_Token("TSemicolon", 10, ())
hscript_Token.TBkOpen = hscript_Token("TBkOpen", 11, ())
hscript_Token.TBkClose = hscript_Token("TBkClose", 12, ())
hscript_Token.TQuestion = hscript_Token("TQuestion", 13, ())
hscript_Token.TDoubleDot = hscript_Token("TDoubleDot", 14, ())
hscript_Token._hx_class = hscript_Token
_hx_classes["hscript.Token"] = hscript_Token


class hscript_Parser:
    _hx_class_name = "hscript.Parser"
    __slots__ = ("line", "opChars", "identChars", "opPriority", "opRightAssoc", "preprocesorValues", "allowJSON", "allowTypes", "allowMetadata", "resumeErrors", "input", "readPos", "char", "ops", "idents", "uid", "tokens", "preprocStack")
    _hx_fields = ["line", "opChars", "identChars", "opPriority", "opRightAssoc", "preprocesorValues", "allowJSON", "allowTypes", "allowMetadata", "resumeErrors", "input", "readPos", "char", "ops", "idents", "uid", "tokens", "preprocStack"]
    _hx_methods = ["error", "invalidChar", "initParser", "parseString", "unexpected", "push", "ensure", "ensureToken", "maybe", "getIdent", "expr", "pmin", "pmax", "mk", "isBlock", "parseFullExpr", "parseObject", "parseExpr", "parseLambda", "parseMetaArgs", "mapCompr", "makeUnop", "makeBinop", "parseStructure", "parseExprNext", "parseFunctionArgs", "parseFunctionDecl", "parsePath", "parseType", "parseTypeNext", "parseExprList", "parseModule", "parseMetadata", "parseParams", "parseModuleDecl", "parseField", "readChar", "readString", "token", "preprocValue", "parsePreproCond", "evalPreproCond", "preprocess", "skipTokens", "tokenComment", "constString", "tokenString"]
    _hx_statics = ["p1", "tokenMin", "tokenMax"]

    def __init__(self):
        self.preprocStack = None
        self.tokens = None
        self.idents = None
        self.ops = None
        self.char = None
        self.readPos = None
        self.input = None
        self.resumeErrors = None
        self.allowMetadata = None
        self.allowTypes = None
        self.allowJSON = None
        self.uid = 0
        self.preprocesorValues = haxe_ds_StringMap()
        self.line = 1
        self.opChars = "+*/-=!><&|^%~"
        self.identChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"
        priorities = [["%"], ["*", "/"], ["+", "-"], ["<<", ">>", ">>>"], ["|", "&", "^"], ["==", "!=", ">", "<", ">=", "<="], ["..."], ["&&"], ["||"], ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "&=", "^=", "=>"], ["->"]]
        self.opPriority = haxe_ds_StringMap()
        self.opRightAssoc = haxe_ds_StringMap()
        _g = 0
        _g1 = len(priorities)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = (priorities[i] if i >= 0 and i < len(priorities) else None)
            while (_g2 < len(_g3)):
                x = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.opPriority.h[x] = i
                if (i == 9):
                    self.opRightAssoc.h[x] = True
        x = "!"
        self.opPriority.h[x] = (-1 if (((x == "++") or ((x == "--")))) else -2)
        x = "++"
        self.opPriority.h[x] = (-1 if (((x == "++") or ((x == "--")))) else -2)
        x = "--"
        self.opPriority.h[x] = (-1 if (((x == "++") or ((x == "--")))) else -2)
        x = "~"
        self.opPriority.h[x] = (-1 if (((x == "++") or ((x == "--")))) else -2)

    def error(self,err,pmin,pmax):
        if (not self.resumeErrors):
            raise haxe_Exception.thrown(err)

    def invalidChar(self,c):
        if (not self.resumeErrors):
            raise haxe_Exception.thrown(hscript_Error.EInvalidChar(c))

    def initParser(self,origin):
        self.preprocStack = []
        self.tokens = haxe_ds_GenericStack()
        self.char = -1
        self.ops = list()
        self.idents = list()
        self.uid = 0
        _g = 0
        _g1 = len(self.opChars)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.ops, HxString.charCodeAt(self.opChars,i), True)
        _g = 0
        _g1 = len(self.identChars)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.idents, HxString.charCodeAt(self.identChars,i), True)

    def parseString(self,s,origin = None):
        if (origin is None):
            origin = "hscript"
        self.initParser(origin)
        self.input = s
        self.readPos = 0
        a = list()
        while True:
            tk = self.token()
            if (tk == hscript_Token.TEof):
                break
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            self.parseFullExpr(a)
        if (len(a) == 1):
            return (a[0] if 0 < len(a) else None)
        else:
            return hscript_Expr.EBlock(a)

    def unexpected(self,tk):
        err = hscript_Error.EUnexpected(self.tokenString(tk))
        if (not self.resumeErrors):
            raise haxe_Exception.thrown(err)
        return None

    def push(self,tk):
        _this = self.tokens
        _this.head = haxe_ds_GenericCell(tk,_this.head)

    def ensure(self,tk):
        t = self.token()
        if (t != tk):
            self.unexpected(t)

    def ensureToken(self,tk):
        t = self.token()
        if (not Type.enumEq(t,tk)):
            self.unexpected(t)

    def maybe(self,tk):
        t = self.token()
        if Type.enumEq(t,tk):
            return True
        _this = self.tokens
        _this.head = haxe_ds_GenericCell(t,_this.head)
        return False

    def getIdent(self):
        tk = self.token()
        if (tk is None):
            self.unexpected(tk)
            return None
        elif (tk.index == 2):
            id = tk.params[0]
            return id
        else:
            self.unexpected(tk)
            return None

    def expr(self,e):
        return e

    def pmin(self,e):
        return 0

    def pmax(self,e):
        return 0

    def mk(self,e,pmin = None,pmax = None):
        return e

    def isBlock(self,e):
        if (e is None):
            return False
        if (e is None):
            return False
        else:
            tmp = e.index
            if (tmp == 2):
                _g = e.params[0]
                t = e.params[1]
                e1 = e.params[2]
                if (e1 is not None):
                    return self.isBlock(e1)
                elif (t is not None):
                    if (t is None):
                        return False
                    elif (t.index == 2):
                        _g = t.params[0]
                        return True
                    else:
                        return False
                else:
                    return False
            elif (tmp == 4):
                _g = e.params[0]
                return True
            elif (tmp == 6):
                _g = e.params[0]
                _g = e.params[1]
                e1 = e.params[2]
                return self.isBlock(e1)
            elif (tmp == 7):
                _g = e.params[0]
                prefix = e.params[1]
                e1 = e.params[2]
                if (not prefix):
                    return self.isBlock(e1)
                else:
                    return False
            elif (tmp == 9):
                _g = e.params[0]
                e1 = e.params[1]
                e2 = e.params[2]
                if (e2 is not None):
                    return self.isBlock(e2)
                else:
                    return self.isBlock(e1)
            elif (tmp == 10):
                _g = e.params[0]
                e1 = e.params[1]
                return self.isBlock(e1)
            elif (tmp == 11):
                _g = e.params[0]
                _g = e.params[1]
                e1 = e.params[2]
                return self.isBlock(e1)
            elif (tmp == 14):
                _g = e.params[0]
                _g = e.params[2]
                _g = e.params[3]
                e1 = e.params[1]
                return self.isBlock(e1)
            elif (tmp == 15):
                e1 = e.params[0]
                if (e1 is not None):
                    return self.isBlock(e1)
                else:
                    return False
            elif (tmp == 20):
                _g = e.params[0]
                _g = e.params[1]
                _g = e.params[2]
                e1 = e.params[3]
                return self.isBlock(e1)
            elif (tmp == 21):
                _g = e.params[0]
                return True
            elif (tmp == 23):
                _g = e.params[0]
                _g = e.params[1]
                _g = e.params[2]
                return True
            elif (tmp == 24):
                _g = e.params[0]
                e1 = e.params[1]
                return self.isBlock(e1)
            elif (tmp == 25):
                _g = e.params[0]
                _g = e.params[1]
                e1 = e.params[2]
                return self.isBlock(e1)
            else:
                return False

    def parseFullExpr(self,exprs):
        e = self.parseExpr()
        exprs.append(e)
        tk = self.token()
        while True:
            tmp = None
            if ((tk == hscript_Token.TComma) and ((e is not None))):
                if (e is None):
                    tmp = False
                elif (e.index == 2):
                    _g = e.params[0]
                    _g1 = e.params[1]
                    _g2 = e.params[2]
                    tmp = True
                else:
                    tmp = False
            else:
                tmp = False
            if (not tmp):
                break
            e = self.parseStructure("var")
            exprs.append(e)
            tk = self.token()
        if ((tk != hscript_Token.TSemicolon) and ((tk != hscript_Token.TEof))):
            if self.isBlock(e):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
            else:
                self.unexpected(tk)

    def parseObject(self,p1):
        fl = list()
        while True:
            tk = self.token()
            id = None
            if (tk is None):
                self.unexpected(tk)
                break
            else:
                tmp = tk.index
                if (tmp == 1):
                    c = tk.params[0]
                    if (not self.allowJSON):
                        self.unexpected(tk)
                    if (c.index == 2):
                        s = c.params[0]
                        id = s
                    else:
                        self.unexpected(tk)
                elif (tmp == 2):
                    i = tk.params[0]
                    id = i
                elif (tmp == 7):
                    break
                else:
                    self.unexpected(tk)
                    break
            t = self.token()
            if (t != hscript_Token.TDoubleDot):
                self.unexpected(t)
            x = _hx_AnonObject({'name': id, 'e': self.parseExpr()})
            fl.append(x)
            tk = self.token()
            if (tk is None):
                self.unexpected(tk)
            else:
                tmp1 = tk.index
                if (tmp1 == 7):
                    break
                elif (tmp1 == 9):
                    pass
                else:
                    self.unexpected(tk)
        return self.parseExprNext(hscript_Expr.EObject(fl))

    def parseExpr(self):
        tk = self.token()
        if (tk is None):
            return self.unexpected(tk)
        else:
            tmp = tk.index
            if (tmp == 1):
                c = tk.params[0]
                return self.parseExprNext(hscript_Expr.EConst(c))
            elif (tmp == 2):
                id = tk.params[0]
                e = self.parseStructure(id)
                if (e is None):
                    e = hscript_Expr.EIdent(id)
                return self.parseExprNext(e)
            elif (tmp == 3):
                op = tk.params[0]
                if (op == "-"):
                    start = 0
                    e = self.parseExpr()
                    if (e is None):
                        return self.makeUnop(op,e)
                    if (e is None):
                        return self.makeUnop(op,e)
                    elif (e.index == 0):
                        _g = e.params[0]
                        tmp = _g.index
                        if (tmp == 0):
                            i = _g.params[0]
                            return hscript_Expr.EConst(hscript_Const.CInt(-i))
                        elif (tmp == 1):
                            f = _g.params[0]
                            return hscript_Expr.EConst(hscript_Const.CFloat(-f))
                        else:
                            return self.makeUnop(op,e)
                    else:
                        return self.makeUnop(op,e)
                if (self.opPriority.h.get(op,None) < 0):
                    return self.makeUnop(op,self.parseExpr())
                return self.unexpected(tk)
            elif (tmp == 4):
                tk = self.token()
                if (tk == hscript_Token.TPClose):
                    t = self.token()
                    if (not Type.enumEq(t,hscript_Token.TOp("->"))):
                        self.unexpected(t)
                    eret = self.parseExpr()
                    return hscript_Expr.EFunction([],hscript_Expr.EReturn(eret))
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                e = self.parseExpr()
                tk = self.token()
                if (tk is not None):
                    tmp = tk.index
                    if (tmp == 5):
                        return self.parseExprNext(hscript_Expr.EParent(e))
                    elif (tmp == 9):
                        if (e is not None):
                            if (e.index == 1):
                                v = e.params[0]
                                return self.parseLambda([_hx_AnonObject({'name': v})],0)
                    elif (tmp == 14):
                        t = self.parseType()
                        tk = self.token()
                        if (tk is not None):
                            tmp = tk.index
                            if (tmp == 5):
                                return self.parseExprNext(hscript_Expr.ECheckType(e,t))
                            elif (tmp == 9):
                                if (e is not None):
                                    if (e.index == 1):
                                        v = e.params[0]
                                        return self.parseLambda([_hx_AnonObject({'name': v, 't': t})],0)
                            else:
                                pass
                    else:
                        pass
                return self.unexpected(tk)
            elif (tmp == 6):
                tk = self.token()
                if (tk is None):
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                else:
                    tmp = tk.index
                    if (tmp == 1):
                        c = tk.params[0]
                        if self.allowJSON:
                            if (c.index == 2):
                                _g = c.params[0]
                                tk2 = self.token()
                                _this = self.tokens
                                _this.head = haxe_ds_GenericCell(tk2,_this.head)
                                _this = self.tokens
                                _this.head = haxe_ds_GenericCell(tk,_this.head)
                                if (tk2 is not None):
                                    if (tk2.index == 14):
                                        return self.parseExprNext(self.parseObject(0))
                            else:
                                _this = self.tokens
                                _this.head = haxe_ds_GenericCell(tk,_this.head)
                        else:
                            _this = self.tokens
                            _this.head = haxe_ds_GenericCell(tk,_this.head)
                    elif (tmp == 2):
                        _g = tk.params[0]
                        tk2 = self.token()
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(tk2,_this.head)
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(tk,_this.head)
                        if (tk2 is not None):
                            if (tk2.index == 14):
                                return self.parseExprNext(self.parseObject(0))
                    elif (tmp == 7):
                        return self.parseExprNext(hscript_Expr.EObject([]))
                    else:
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(tk,_this.head)
                a = list()
                while True:
                    self.parseFullExpr(a)
                    tk = self.token()
                    if ((tk == hscript_Token.TBrClose) or ((self.resumeErrors and ((tk == hscript_Token.TEof))))):
                        break
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                return hscript_Expr.EBlock(a)
            elif (tmp == 11):
                a = list()
                tk = self.token()
                while ((tk != hscript_Token.TBkClose) and (((not self.resumeErrors) or ((tk != hscript_Token.TEof))))):
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                    x = self.parseExpr()
                    a.append(x)
                    tk = self.token()
                    if (tk == hscript_Token.TComma):
                        tk = self.token()
                if ((len(a) == 1) and (((a[0] if 0 < len(a) else None) is not None))):
                    _g = (a[0] if 0 < len(a) else None)
                    if (_g is not None):
                        tmp = _g.index
                        if (tmp == 10):
                            _g1 = _g.params[0]
                            _g1 = _g.params[1]
                            def _hx_local_2():
                                _hx_local_0 = self
                                _hx_local_1 = _hx_local_0.uid
                                _hx_local_0.uid = (_hx_local_1 + 1)
                                return _hx_local_1
                            tmp = ("__a_" + Std.string(_hx_local_2()))
                            e = hscript_Expr.EBlock([hscript_Expr.EVar(tmp,None,hscript_Expr.EArrayDecl([])), self.mapCompr(tmp,(a[0] if 0 < len(a) else None)), hscript_Expr.EIdent(tmp)])
                            return self.parseExprNext(e)
                        elif (tmp == 11):
                            _g1 = _g.params[0]
                            _g1 = _g.params[1]
                            _g1 = _g.params[2]
                            def _hx_local_5():
                                _hx_local_3 = self
                                _hx_local_4 = _hx_local_3.uid
                                _hx_local_3.uid = (_hx_local_4 + 1)
                                return _hx_local_4
                            tmp = ("__a_" + Std.string(_hx_local_5()))
                            e = hscript_Expr.EBlock([hscript_Expr.EVar(tmp,None,hscript_Expr.EArrayDecl([])), self.mapCompr(tmp,(a[0] if 0 < len(a) else None)), hscript_Expr.EIdent(tmp)])
                            return self.parseExprNext(e)
                        elif (tmp == 24):
                            _g1 = _g.params[0]
                            _g1 = _g.params[1]
                            def _hx_local_8():
                                _hx_local_6 = self
                                _hx_local_7 = _hx_local_6.uid
                                _hx_local_6.uid = (_hx_local_7 + 1)
                                return _hx_local_7
                            tmp = ("__a_" + Std.string(_hx_local_8()))
                            e = hscript_Expr.EBlock([hscript_Expr.EVar(tmp,None,hscript_Expr.EArrayDecl([])), self.mapCompr(tmp,(a[0] if 0 < len(a) else None)), hscript_Expr.EIdent(tmp)])
                            return self.parseExprNext(e)
                        else:
                            pass
                return self.parseExprNext(hscript_Expr.EArrayDecl(a))
            elif (tmp == 15):
                id = tk.params[0]
                if self.allowMetadata:
                    args = self.parseMetaArgs()
                    return hscript_Expr.EMeta(id,args,self.parseExpr())
                else:
                    return self.unexpected(tk)
            else:
                return self.unexpected(tk)

    def parseLambda(self,args,pmin):
        while True:
            id = self.getIdent()
            t = (self.parseType() if (self.maybe(hscript_Token.TDoubleDot)) else None)
            args.append(_hx_AnonObject({'name': id, 't': t}))
            tk = self.token()
            if (tk is None):
                self.unexpected(tk)
                break
            else:
                tmp = tk.index
                if (tmp == 5):
                    break
                elif (tmp == 9):
                    pass
                else:
                    self.unexpected(tk)
                    break
        t = self.token()
        if (not Type.enumEq(t,hscript_Token.TOp("->"))):
            self.unexpected(t)
        eret = self.parseExpr()
        return hscript_Expr.EFunction(args,hscript_Expr.EReturn(eret))

    def parseMetaArgs(self):
        tk = self.token()
        if (tk != hscript_Token.TPOpen):
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            return None
        args = []
        tk = self.token()
        if (tk != hscript_Token.TPClose):
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            while True:
                x = self.parseExpr()
                args.append(x)
                _g = self.token()
                if (_g is None):
                    tk = _g
                    self.unexpected(tk)
                else:
                    tmp = _g.index
                    if (tmp == 5):
                        break
                    elif (tmp == 9):
                        pass
                    else:
                        tk1 = _g
                        self.unexpected(tk1)
        return args

    def mapCompr(self,tmp,e):
        if (e is None):
            return None
        edef = None
        edef1 = e.index
        if (edef1 == 3):
            e2 = e.params[0]
            edef = hscript_Expr.EParent(self.mapCompr(tmp,e2))
        elif (edef1 == 4):
            _g = e.params[0]
            if (len(_g) == 1):
                e1 = (_g[0] if 0 < len(_g) else None)
                edef = hscript_Expr.EBlock([self.mapCompr(tmp,e1)])
            else:
                edef = hscript_Expr.ECall(hscript_Expr.EField(hscript_Expr.EIdent(tmp),"push"),[e])
        elif (edef1 == 9):
            cond = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            edef = (hscript_Expr.EIf(cond,self.mapCompr(tmp,e1),None) if ((e2 is None)) else hscript_Expr.ECall(hscript_Expr.EField(hscript_Expr.EIdent(tmp),"push"),[e]))
        elif (edef1 == 10):
            cond = e.params[0]
            e2 = e.params[1]
            edef = hscript_Expr.EWhile(cond,self.mapCompr(tmp,e2))
        elif (edef1 == 11):
            v = e.params[0]
            it = e.params[1]
            e2 = e.params[2]
            edef = hscript_Expr.EFor(v,it,self.mapCompr(tmp,e2))
        elif (edef1 == 24):
            cond = e.params[0]
            e2 = e.params[1]
            edef = hscript_Expr.EDoWhile(cond,self.mapCompr(tmp,e2))
        else:
            edef = hscript_Expr.ECall(hscript_Expr.EField(hscript_Expr.EIdent(tmp),"push"),[e])
        return edef

    def makeUnop(self,op,e):
        if ((e is None) and self.resumeErrors):
            return None
        if (e is None):
            return hscript_Expr.EUnop(op,True,e)
        else:
            tmp = e.index
            if (tmp == 6):
                bop = e.params[0]
                e1 = e.params[1]
                e2 = e.params[2]
                return hscript_Expr.EBinop(bop,self.makeUnop(op,e1),e2)
            elif (tmp == 22):
                e1 = e.params[0]
                e2 = e.params[1]
                e3 = e.params[2]
                return hscript_Expr.ETernary(self.makeUnop(op,e1),e2,e3)
            else:
                return hscript_Expr.EUnop(op,True,e)

    def makeBinop(self,op,e1,e):
        if ((e is None) and self.resumeErrors):
            return hscript_Expr.EBinop(op,e1,e)
        if (e is None):
            return hscript_Expr.EBinop(op,e1,e)
        else:
            tmp = e.index
            if (tmp == 6):
                op2 = e.params[0]
                e2 = e.params[1]
                e3 = e.params[2]
                if ((self.opPriority.h.get(op,None) <= self.opPriority.h.get(op2,None)) and (not (op in self.opRightAssoc.h))):
                    return hscript_Expr.EBinop(op2,self.makeBinop(op,e1,e2),e3)
                else:
                    return hscript_Expr.EBinop(op,e1,e)
            elif (tmp == 22):
                e2 = e.params[0]
                e3 = e.params[1]
                e4 = e.params[2]
                if (op in self.opRightAssoc.h):
                    return hscript_Expr.EBinop(op,e1,e)
                else:
                    return hscript_Expr.ETernary(self.makeBinop(op,e1,e2),e3,e4)
            else:
                return hscript_Expr.EBinop(op,e1,e)

    def parseStructure(self,id):
        id1 = id
        _hx_local_0 = len(id1)
        if (_hx_local_0 == 5):
            if (id1 == "break"):
                return hscript_Expr.EBreak
            elif (id1 == "throw"):
                e = self.parseExpr()
                return hscript_Expr.EThrow(e)
            elif (id1 == "while"):
                econd = self.parseExpr()
                e = self.parseExpr()
                return hscript_Expr.EWhile(econd,e)
            else:
                return None
        elif (_hx_local_0 == 4):
            if (id1 == "else"):
                return self.unexpected(hscript_Token.TId(id))
            else:
                return None
        elif (_hx_local_0 == 3):
            if (id1 == "for"):
                t = self.token()
                if (t != hscript_Token.TPOpen):
                    self.unexpected(t)
                vname = self.getIdent()
                t = self.token()
                if (not Type.enumEq(t,hscript_Token.TId("in"))):
                    self.unexpected(t)
                eiter = self.parseExpr()
                t = self.token()
                if (t != hscript_Token.TPClose):
                    self.unexpected(t)
                e = self.parseExpr()
                return hscript_Expr.EFor(vname,eiter,e)
            elif (id1 == "new"):
                a = list()
                x = self.getIdent()
                a.append(x)
                while True:
                    tk = self.token()
                    if (tk is None):
                        self.unexpected(tk)
                        break
                    else:
                        tmp = tk.index
                        if (tmp == 4):
                            break
                        elif (tmp == 8):
                            x = self.getIdent()
                            a.append(x)
                        else:
                            self.unexpected(tk)
                            break
                args = self.parseExprList(hscript_Token.TPClose)
                return hscript_Expr.ENew(".".join([python_Boot.toString1(x1,'') for x1 in a]),args)
            elif (id1 == "try"):
                e = self.parseExpr()
                t = self.token()
                if (not Type.enumEq(t,hscript_Token.TId("catch"))):
                    self.unexpected(t)
                t = self.token()
                if (t != hscript_Token.TPOpen):
                    self.unexpected(t)
                vname = self.getIdent()
                t = self.token()
                if (t != hscript_Token.TDoubleDot):
                    self.unexpected(t)
                t = None
                if self.allowTypes:
                    t = self.parseType()
                else:
                    t1 = self.token()
                    if (not Type.enumEq(t1,hscript_Token.TId("Dynamic"))):
                        self.unexpected(t1)
                t1 = self.token()
                if (t1 != hscript_Token.TPClose):
                    self.unexpected(t1)
                ec = self.parseExpr()
                return hscript_Expr.ETry(e,vname,t,ec)
            elif (id1 == "var"):
                ident = self.getIdent()
                tk = self.token()
                t = None
                if ((tk == hscript_Token.TDoubleDot) and self.allowTypes):
                    t = self.parseType()
                    tk = self.token()
                e = None
                if Type.enumEq(tk,hscript_Token.TOp("=")):
                    e = self.parseExpr()
                else:
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                return hscript_Expr.EVar(ident,t,e)
            else:
                return None
        elif (_hx_local_0 == 8):
            if (id1 == "continue"):
                return hscript_Expr.EContinue
            elif (id1 == "function"):
                tk = self.token()
                name = None
                if (tk is None):
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                elif (tk.index == 2):
                    id = tk.params[0]
                    name = id
                else:
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                inf = self.parseFunctionDecl()
                return hscript_Expr.EFunction(inf.args,inf.body,name,inf.ret)
            else:
                return None
        elif (_hx_local_0 == 2):
            if (id1 == "do"):
                e = self.parseExpr()
                tk = self.token()
                if (tk is None):
                    self.unexpected(tk)
                elif (tk.index == 2):
                    if (tk.params[0] != "while"):
                        self.unexpected(tk)
                else:
                    self.unexpected(tk)
                econd = self.parseExpr()
                return hscript_Expr.EDoWhile(econd,e)
            elif (id1 == "if"):
                t = self.token()
                if (t != hscript_Token.TPOpen):
                    self.unexpected(t)
                cond = self.parseExpr()
                t = self.token()
                if (t != hscript_Token.TPClose):
                    self.unexpected(t)
                e1 = self.parseExpr()
                e2 = None
                semic = False
                tk = self.token()
                if (tk == hscript_Token.TSemicolon):
                    semic = True
                    tk = self.token()
                if Type.enumEq(tk,hscript_Token.TId("else")):
                    e2 = self.parseExpr()
                else:
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(tk,_this.head)
                    if semic:
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(hscript_Token.TSemicolon,_this.head)
                return hscript_Expr.EIf(cond,e1,e2)
            else:
                return None
        elif (_hx_local_0 == 6):
            if (id1 == "inline"):
                if (not self.maybe(hscript_Token.TId("function"))):
                    self.unexpected(hscript_Token.TId("inline"))
                return self.parseStructure("function")
            elif (id1 == "return"):
                tk = self.token()
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                e = (None if ((tk == hscript_Token.TSemicolon)) else self.parseExpr())
                return hscript_Expr.EReturn(e)
            elif (id1 == "switch"):
                e = self.parseExpr()
                _hx_def = None
                cases = []
                t = self.token()
                if (t != hscript_Token.TBrOpen):
                    self.unexpected(t)
                while True:
                    tk = self.token()
                    if (tk is None):
                        self.unexpected(tk)
                        break
                    else:
                        tmp = tk.index
                        if (tmp == 2):
                            _g = tk.params[0]
                            _hx_local_1 = len(_g)
                            if (_hx_local_1 == 4):
                                if (_g == "case"):
                                    c = _hx_AnonObject({'values': [], 'expr': None})
                                    cases.append(c)
                                    while True:
                                        e1 = self.parseExpr()
                                        _this = c.values
                                        _this.append(e1)
                                        tk = self.token()
                                        if (tk is None):
                                            self.unexpected(tk)
                                            break
                                        else:
                                            tmp1 = tk.index
                                            if (tmp1 == 9):
                                                pass
                                            elif (tmp1 == 14):
                                                break
                                            else:
                                                self.unexpected(tk)
                                                break
                                    exprs = []
                                    while True:
                                        tk = self.token()
                                        _this1 = self.tokens
                                        _this1.head = haxe_ds_GenericCell(tk,_this1.head)
                                        if (tk is None):
                                            self.parseFullExpr(exprs)
                                        else:
                                            tmp2 = tk.index
                                            if (tmp2 == 0):
                                                if self.resumeErrors:
                                                    break
                                                else:
                                                    self.parseFullExpr(exprs)
                                            elif (tmp2 == 2):
                                                _g1 = tk.params[0]
                                                _hx_local_2 = len(_g1)
                                                if (_hx_local_2 == 4):
                                                    if (_g1 == "case"):
                                                        break
                                                    else:
                                                        self.parseFullExpr(exprs)
                                                elif (_hx_local_2 == 7):
                                                    if (_g1 == "default"):
                                                        break
                                                    else:
                                                        self.parseFullExpr(exprs)
                                                else:
                                                    self.parseFullExpr(exprs)
                                            elif (tmp2 == 7):
                                                break
                                            else:
                                                self.parseFullExpr(exprs)
                                    c.expr = ((exprs[0] if 0 < len(exprs) else None) if ((len(exprs) == 1)) else (hscript_Expr.EBlock([]) if ((len(exprs) == 0)) else hscript_Expr.EBlock(exprs)))
                                else:
                                    self.unexpected(tk)
                                    break
                            elif (_hx_local_1 == 7):
                                if (_g == "default"):
                                    if (_hx_def is not None):
                                        self.unexpected(tk)
                                    t = self.token()
                                    if (t != hscript_Token.TDoubleDot):
                                        self.unexpected(t)
                                    exprs1 = []
                                    while True:
                                        tk = self.token()
                                        _this2 = self.tokens
                                        _this2.head = haxe_ds_GenericCell(tk,_this2.head)
                                        if (tk is None):
                                            self.parseFullExpr(exprs1)
                                        else:
                                            tmp3 = tk.index
                                            if (tmp3 == 0):
                                                if self.resumeErrors:
                                                    break
                                                else:
                                                    self.parseFullExpr(exprs1)
                                            elif (tmp3 == 2):
                                                _g2 = tk.params[0]
                                                _hx_local_3 = len(_g2)
                                                if (_hx_local_3 == 4):
                                                    if (_g2 == "case"):
                                                        break
                                                    else:
                                                        self.parseFullExpr(exprs1)
                                                elif (_hx_local_3 == 7):
                                                    if (_g2 == "default"):
                                                        break
                                                    else:
                                                        self.parseFullExpr(exprs1)
                                                else:
                                                    self.parseFullExpr(exprs1)
                                            elif (tmp3 == 7):
                                                break
                                            else:
                                                self.parseFullExpr(exprs1)
                                    _hx_def = ((exprs1[0] if 0 < len(exprs1) else None) if ((len(exprs1) == 1)) else (hscript_Expr.EBlock([]) if ((len(exprs1) == 0)) else hscript_Expr.EBlock(exprs1)))
                                else:
                                    self.unexpected(tk)
                                    break
                            else:
                                self.unexpected(tk)
                                break
                        elif (tmp == 7):
                            break
                        else:
                            self.unexpected(tk)
                            break
                return hscript_Expr.ESwitch(e,cases,_hx_def)
            else:
                return None
        else:
            return None

    def parseExprNext(self,e1):
        tk = self.token()
        if (tk is None):
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            return e1
        else:
            tmp = tk.index
            if (tmp == 3):
                op = tk.params[0]
                if (op == "->"):
                    tmp = e1.index
                    if (tmp == 1):
                        i = e1.params[0]
                        eret = self.parseExpr()
                        return hscript_Expr.EFunction([_hx_AnonObject({'name': i})],hscript_Expr.EReturn(eret))
                    elif (tmp == 3):
                        _hx_tmp = e1.params[0]
                        if (_hx_tmp.index == 1):
                            i = _hx_tmp.params[0]
                            eret = self.parseExpr()
                            return hscript_Expr.EFunction([_hx_AnonObject({'name': i})],hscript_Expr.EReturn(eret))
                    elif (tmp == 26):
                        _hx_tmp = e1.params[0]
                        if (_hx_tmp.index == 1):
                            i = _hx_tmp.params[0]
                            t = e1.params[1]
                            eret = self.parseExpr()
                            return hscript_Expr.EFunction([_hx_AnonObject({'name': i, 't': t})],hscript_Expr.EReturn(eret))
                    else:
                        pass
                    self.unexpected(tk)
                if (self.opPriority.h.get(op,None) == -1):
                    tmp = None
                    if (not self.isBlock(e1)):
                        if (e1.index == 3):
                            _g = e1.params[0]
                            tmp = True
                        else:
                            tmp = False
                    else:
                        tmp = True
                    if tmp:
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(tk,_this.head)
                        return e1
                    return self.parseExprNext(hscript_Expr.EUnop(op,False,e1))
                return self.makeBinop(op,e1,self.parseExpr())
            elif (tmp == 4):
                return self.parseExprNext(hscript_Expr.ECall(e1,self.parseExprList(hscript_Token.TPClose)))
            elif (tmp == 8):
                field = self.getIdent()
                return self.parseExprNext(hscript_Expr.EField(e1,field))
            elif (tmp == 11):
                e2 = self.parseExpr()
                t = self.token()
                if (t != hscript_Token.TBkClose):
                    self.unexpected(t)
                return self.parseExprNext(hscript_Expr.EArray(e1,e2))
            elif (tmp == 13):
                e2 = self.parseExpr()
                t = self.token()
                if (t != hscript_Token.TDoubleDot):
                    self.unexpected(t)
                e3 = self.parseExpr()
                return hscript_Expr.ETernary(e1,e2,e3)
            else:
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                return e1

    def parseFunctionArgs(self):
        args = list()
        tk = self.token()
        if (tk != hscript_Token.TPClose):
            done = False
            while (not done):
                name = None
                opt = False
                if (tk is not None):
                    if (tk.index == 13):
                        opt = True
                        tk = self.token()
                if (tk is None):
                    self.unexpected(tk)
                    break
                elif (tk.index == 2):
                    id = tk.params[0]
                    name = id
                else:
                    self.unexpected(tk)
                    break
                arg = _hx_AnonObject({'name': name})
                args.append(arg)
                if opt:
                    Reflect.setField(arg,"opt",True)
                if self.allowTypes:
                    if self.maybe(hscript_Token.TDoubleDot):
                        Reflect.setField(arg,"t",self.parseType())
                    if self.maybe(hscript_Token.TOp("=")):
                        Reflect.setField(arg,"value",self.parseExpr())
                tk = self.token()
                if (tk is None):
                    self.unexpected(tk)
                else:
                    tmp = tk.index
                    if (tmp == 5):
                        done = True
                    elif (tmp == 9):
                        tk = self.token()
                    else:
                        self.unexpected(tk)
        return args

    def parseFunctionDecl(self):
        t = self.token()
        if (t != hscript_Token.TPOpen):
            self.unexpected(t)
        args = self.parseFunctionArgs()
        ret = None
        if self.allowTypes:
            tk = self.token()
            if (tk != hscript_Token.TDoubleDot):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
            else:
                ret = self.parseType()
        return _hx_AnonObject({'args': args, 'ret': ret, 'body': self.parseExpr()})

    def parsePath(self):
        path = [self.getIdent()]
        while True:
            t = self.token()
            if (t != hscript_Token.TDot):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(t,_this.head)
                break
            x = self.getIdent()
            path.append(x)
        return path

    def parseType(self):
        _gthis = self
        t = self.token()
        if (t is None):
            return self.unexpected(t)
        else:
            tmp = t.index
            if (tmp == 2):
                v = t.params[0]
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(t,_this.head)
                path = self.parsePath()
                params = None
                t = self.token()
                if (t is None):
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(t,_this.head)
                elif (t.index == 3):
                    op = t.params[0]
                    if (op == "<"):
                        params = []
                        while True:
                            x = self.parseType()
                            params.append(x)
                            t = self.token()
                            if (t is not None):
                                tmp = t.index
                                if (tmp == 3):
                                    op = t.params[0]
                                    if (op == ">"):
                                        break
                                    if (HxString.charCodeAt(op,0) == 62):
                                        _this = self.tokens
                                        _this.head = haxe_ds_GenericCell(hscript_Token.TOp(HxString.substr(op,1,None)),_this.head)
                                        break
                                elif (tmp == 9):
                                    continue
                                else:
                                    pass
                            self.unexpected(t)
                            break
                    else:
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(t,_this.head)
                else:
                    _this = self.tokens
                    _this.head = haxe_ds_GenericCell(t,_this.head)
                return self.parseTypeNext(hscript_CType.CTPath(path,params))
            elif (tmp == 4):
                a = self.token()
                b = self.token()
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(b,_this.head)
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(a,_this.head)
                def _hx_local_0(args):
                    _g = _gthis.token()
                    if (_g is None):
                        t = _g
                        _gthis.unexpected(t)
                    elif (_g.index == 3):
                        if (_g.params[0] != "->"):
                            t = _g
                            _gthis.unexpected(t)
                    else:
                        t = _g
                        _gthis.unexpected(t)
                    return hscript_CType.CTFun(args,_gthis.parseType())
                withReturn = _hx_local_0
                if (a is None):
                    t1 = self.parseType()
                    _g = self.token()
                    if (_g is None):
                        t2 = _g
                        return self.unexpected(t2)
                    else:
                        tmp = _g.index
                        if (tmp == 5):
                            return self.parseTypeNext(hscript_CType.CTParent(t1))
                        elif (tmp == 9):
                            args = [t1]
                            while True:
                                x = self.parseType()
                                args.append(x)
                                if (not (self.maybe(hscript_Token.TComma))):
                                    break
                            t1 = self.token()
                            if (t1 != hscript_Token.TPClose):
                                self.unexpected(t1)
                            return withReturn(args)
                        else:
                            t1 = _g
                            return self.unexpected(t1)
                else:
                    tmp = a.index
                    if (tmp == 2):
                        _g = a.params[0]
                        if (b is None):
                            t1 = self.parseType()
                            _g = self.token()
                            if (_g is None):
                                t2 = _g
                                return self.unexpected(t2)
                            else:
                                tmp = _g.index
                                if (tmp == 5):
                                    return self.parseTypeNext(hscript_CType.CTParent(t1))
                                elif (tmp == 9):
                                    args = [t1]
                                    while True:
                                        x = self.parseType()
                                        args.append(x)
                                        if (not (self.maybe(hscript_Token.TComma))):
                                            break
                                    t1 = self.token()
                                    if (t1 != hscript_Token.TPClose):
                                        self.unexpected(t1)
                                    return withReturn(args)
                                else:
                                    t1 = _g
                                    return self.unexpected(t1)
                        elif (b.index == 14):
                            _g = []
                            _g1 = 0
                            _g2 = self.parseFunctionArgs()
                            while (_g1 < len(_g2)):
                                arg = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                                _g1 = (_g1 + 1)
                                _g3 = Reflect.field(arg,"value")
                                if (_g3 is not None):
                                    v = _g3
                                    if (not self.resumeErrors):
                                        raise haxe_Exception.thrown(hscript_Error.ECustom("Default values not allowed in function types"))
                                x = hscript_CType.CTNamed(arg.name,(hscript_CType.CTOpt(Reflect.field(arg,"t")) if (Reflect.field(arg,"opt")) else Reflect.field(arg,"t")))
                                _g.append(x)
                            args = _g
                            return withReturn(args)
                        else:
                            t1 = self.parseType()
                            _g = self.token()
                            if (_g is None):
                                t2 = _g
                                return self.unexpected(t2)
                            else:
                                tmp = _g.index
                                if (tmp == 5):
                                    return self.parseTypeNext(hscript_CType.CTParent(t1))
                                elif (tmp == 9):
                                    args = [t1]
                                    while True:
                                        x = self.parseType()
                                        args.append(x)
                                        if (not (self.maybe(hscript_Token.TComma))):
                                            break
                                    t1 = self.token()
                                    if (t1 != hscript_Token.TPClose):
                                        self.unexpected(t1)
                                    return withReturn(args)
                                else:
                                    t1 = _g
                                    return self.unexpected(t1)
                    elif (tmp == 5):
                        _g = []
                        _g1 = 0
                        _g2 = self.parseFunctionArgs()
                        while (_g1 < len(_g2)):
                            arg = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                            _g1 = (_g1 + 1)
                            _g3 = Reflect.field(arg,"value")
                            if (_g3 is not None):
                                v = _g3
                                if (not self.resumeErrors):
                                    raise haxe_Exception.thrown(hscript_Error.ECustom("Default values not allowed in function types"))
                            x = hscript_CType.CTNamed(arg.name,(hscript_CType.CTOpt(Reflect.field(arg,"t")) if (Reflect.field(arg,"opt")) else Reflect.field(arg,"t")))
                            _g.append(x)
                        args = _g
                        return withReturn(args)
                    else:
                        t1 = self.parseType()
                        _g = self.token()
                        if (_g is None):
                            t2 = _g
                            return self.unexpected(t2)
                        else:
                            tmp = _g.index
                            if (tmp == 5):
                                return self.parseTypeNext(hscript_CType.CTParent(t1))
                            elif (tmp == 9):
                                args = [t1]
                                while True:
                                    x = self.parseType()
                                    args.append(x)
                                    if (not (self.maybe(hscript_Token.TComma))):
                                        break
                                t1 = self.token()
                                if (t1 != hscript_Token.TPClose):
                                    self.unexpected(t1)
                                return withReturn(args)
                            else:
                                t1 = _g
                                return self.unexpected(t1)
            elif (tmp == 6):
                fields = []
                meta = None
                while True:
                    t = self.token()
                    if (t is None):
                        self.unexpected(t)
                        break
                    else:
                        tmp = t.index
                        if (tmp == 2):
                            _g = t.params[0]
                            if (_g == "var"):
                                name = self.getIdent()
                                t1 = self.token()
                                if (t1 != hscript_Token.TDoubleDot):
                                    self.unexpected(t1)
                                x = _hx_AnonObject({'name': name, 't': self.parseType(), 'meta': meta})
                                fields.append(x)
                                meta = None
                                t2 = self.token()
                                if (t2 != hscript_Token.TSemicolon):
                                    self.unexpected(t2)
                            else:
                                name1 = _g
                                t3 = self.token()
                                if (t3 != hscript_Token.TDoubleDot):
                                    self.unexpected(t3)
                                x1 = _hx_AnonObject({'name': name1, 't': self.parseType(), 'meta': meta})
                                fields.append(x1)
                                t = self.token()
                                if (t is None):
                                    self.unexpected(t)
                                else:
                                    tmp1 = t.index
                                    if (tmp1 == 7):
                                        break
                                    elif (tmp1 == 9):
                                        pass
                                    else:
                                        self.unexpected(t)
                        elif (tmp == 7):
                            break
                        elif (tmp == 15):
                            name2 = t.params[0]
                            if (meta is None):
                                meta = []
                            x2 = _hx_AnonObject({'name': name2, 'params': self.parseMetaArgs()})
                            meta.append(x2)
                        else:
                            self.unexpected(t)
                            break
                return self.parseTypeNext(hscript_CType.CTAnon(fields))
            else:
                return self.unexpected(t)

    def parseTypeNext(self,t):
        tk = self.token()
        if (tk is None):
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            return t
        elif (tk.index == 3):
            op = tk.params[0]
            if (op != "->"):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                return t
        else:
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            return t
        t2 = self.parseType()
        if (t2.index == 1):
            _g = t2.params[1]
            args = t2.params[0]
            args.insert(0, t)
            return t2
        else:
            return hscript_CType.CTFun([t],t2)

    def parseExprList(self,etk):
        args = list()
        tk = self.token()
        if (tk == etk):
            return args
        _this = self.tokens
        _this.head = haxe_ds_GenericCell(tk,_this.head)
        while True:
            x = self.parseExpr()
            args.append(x)
            tk = self.token()
            if (tk is None):
                if (tk == etk):
                    break
                self.unexpected(tk)
                break
            elif (tk.index != 9):
                if (tk == etk):
                    break
                self.unexpected(tk)
                break
        return args

    def parseModule(self,content,origin = None):
        if (origin is None):
            origin = "hscript"
        self.initParser(origin)
        self.input = content
        self.readPos = 0
        self.allowTypes = True
        self.allowMetadata = True
        decls = []
        while True:
            tk = self.token()
            if (tk == hscript_Token.TEof):
                break
            _this = self.tokens
            _this.head = haxe_ds_GenericCell(tk,_this.head)
            x = self.parseModuleDecl()
            decls.append(x)
        return decls

    def parseMetadata(self):
        meta = []
        while True:
            tk = self.token()
            if (tk is None):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                break
            elif (tk.index == 15):
                name = tk.params[0]
                x = _hx_AnonObject({'name': name, 'params': self.parseMetaArgs()})
                meta.append(x)
            else:
                _this1 = self.tokens
                _this1.head = haxe_ds_GenericCell(tk,_this1.head)
                break
        return meta

    def parseParams(self):
        if self.maybe(hscript_Token.TOp("<")):
            if (not self.resumeErrors):
                raise haxe_Exception.thrown(hscript_Error.EInvalidOp("Unsupported class type parameters"))
        return _hx_AnonObject({})

    def parseModuleDecl(self):
        meta = self.parseMetadata()
        ident = self.getIdent()
        isPrivate = False
        isExtern = False
        while True:
            ident1 = ident
            _hx_local_0 = len(ident1)
            if (_hx_local_0 == 7):
                if (ident1 == "private"):
                    isPrivate = True
                else:
                    break
            elif (_hx_local_0 == 6):
                if (ident1 == "extern"):
                    isExtern = True
                else:
                    break
            else:
                break
            ident = self.getIdent()
        ident1 = ident
        _hx_local_1 = len(ident1)
        if (_hx_local_1 == 5):
            if (ident1 == "class"):
                name = self.getIdent()
                params = self.parseParams()
                extend = None
                implement = []
                while True:
                    t = self.token()
                    if (t is None):
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(t,_this.head)
                        break
                    elif (t.index == 2):
                        _g = t.params[0]
                        _hx_local_2 = len(_g)
                        if (_hx_local_2 == 10):
                            if (_g == "implements"):
                                x = self.parseType()
                                implement.append(x)
                            else:
                                _this1 = self.tokens
                                _this1.head = haxe_ds_GenericCell(t,_this1.head)
                                break
                        elif (_hx_local_2 == 7):
                            if (_g == "extends"):
                                extend = self.parseType()
                            else:
                                _this1 = self.tokens
                                _this1.head = haxe_ds_GenericCell(t,_this1.head)
                                break
                        else:
                            _this1 = self.tokens
                            _this1.head = haxe_ds_GenericCell(t,_this1.head)
                            break
                    else:
                        _this2 = self.tokens
                        _this2.head = haxe_ds_GenericCell(t,_this2.head)
                        break
                fields = []
                t = self.token()
                if (t != hscript_Token.TBrOpen):
                    self.unexpected(t)
                while (not self.maybe(hscript_Token.TBrClose)):
                    x = self.parseField()
                    fields.append(x)
                return hscript_ModuleDecl.DClass(_hx_AnonObject({'name': name, 'meta': meta, 'params': params, 'extend': extend, 'implement': implement, 'fields': fields, 'isPrivate': isPrivate, 'isExtern': isExtern}))
            else:
                self.unexpected(hscript_Token.TId(ident))
        elif (_hx_local_1 == 7):
            if (ident1 == "package"):
                path = self.parsePath()
                t = self.token()
                if (t != hscript_Token.TSemicolon):
                    self.unexpected(t)
                return hscript_ModuleDecl.DPackage(path)
            elif (ident1 == "typedef"):
                name = self.getIdent()
                params = self.parseParams()
                t = self.token()
                if (not Type.enumEq(t,hscript_Token.TOp("="))):
                    self.unexpected(t)
                t = self.parseType()
                return hscript_ModuleDecl.DTypedef(_hx_AnonObject({'name': name, 'meta': meta, 'params': params, 'isPrivate': isPrivate, 't': t}))
            else:
                self.unexpected(hscript_Token.TId(ident))
        elif (_hx_local_1 == 6):
            if (ident1 == "import"):
                path = [self.getIdent()]
                star = False
                while True:
                    t = self.token()
                    if (t != hscript_Token.TDot):
                        _this = self.tokens
                        _this.head = haxe_ds_GenericCell(t,_this.head)
                        break
                    t = self.token()
                    if (t is None):
                        self.unexpected(t)
                    else:
                        tmp = t.index
                        if (tmp == 2):
                            id = t.params[0]
                            path.append(id)
                        elif (tmp == 3):
                            if (t.params[0] == "*"):
                                star = True
                            else:
                                self.unexpected(t)
                        else:
                            self.unexpected(t)
                t = self.token()
                if (t != hscript_Token.TSemicolon):
                    self.unexpected(t)
                return hscript_ModuleDecl.DImport(path,star)
            else:
                self.unexpected(hscript_Token.TId(ident))
        else:
            self.unexpected(hscript_Token.TId(ident))
        return None

    def parseField(self):
        meta = self.parseMetadata()
        access = []
        while True:
            id = self.getIdent()
            id1 = id
            _hx_local_0 = len(id1)
            if (_hx_local_0 == 5):
                if (id1 == "macro"):
                    access.append(hscript_FieldAccess.AMacro)
                else:
                    self.unexpected(hscript_Token.TId(id))
                    break
            elif (_hx_local_0 == 7):
                if (id1 == "private"):
                    access.append(hscript_FieldAccess.APrivate)
                else:
                    self.unexpected(hscript_Token.TId(id))
                    break
            elif (_hx_local_0 == 3):
                if (id1 == "var"):
                    name1 = self.getIdent()
                    get = None
                    _hx_set = None
                    if self.maybe(hscript_Token.TPOpen):
                        get = self.getIdent()
                        t = self.token()
                        if (t != hscript_Token.TComma):
                            self.unexpected(t)
                        _hx_set = self.getIdent()
                        t1 = self.token()
                        if (t1 != hscript_Token.TPClose):
                            self.unexpected(t1)
                    _hx_type = (self.parseType() if (self.maybe(hscript_Token.TDoubleDot)) else None)
                    expr = (self.parseExpr() if (self.maybe(hscript_Token.TOp("="))) else None)
                    if (expr is not None):
                        if self.isBlock(expr):
                            self.maybe(hscript_Token.TSemicolon)
                        else:
                            t2 = self.token()
                            if (t2 != hscript_Token.TSemicolon):
                                self.unexpected(t2)
                    else:
                        tmp = None
                        if (_hx_type is not None):
                            if (_hx_type is None):
                                tmp = False
                            elif (_hx_type.index == 2):
                                _g = _hx_type.params[0]
                                tmp = True
                            else:
                                tmp = False
                        else:
                            tmp = False
                        if tmp:
                            self.maybe(hscript_Token.TSemicolon)
                        else:
                            t3 = self.token()
                            if (t3 != hscript_Token.TSemicolon):
                                self.unexpected(t3)
                    return _hx_AnonObject({'name': name1, 'meta': meta, 'access': access, 'kind': hscript_FieldKind.KVar(_hx_AnonObject({'get': get, 'set': _hx_set, 'type': _hx_type, 'expr': expr}))})
                else:
                    self.unexpected(hscript_Token.TId(id))
                    break
            elif (_hx_local_0 == 8):
                if (id1 == "function"):
                    name = self.getIdent()
                    inf = self.parseFunctionDecl()
                    return _hx_AnonObject({'name': name, 'meta': meta, 'access': access, 'kind': hscript_FieldKind.KFunction(_hx_AnonObject({'args': inf.args, 'expr': inf.body, 'ret': inf.ret}))})
                elif (id1 == "override"):
                    access.append(hscript_FieldAccess.AOverride)
                else:
                    self.unexpected(hscript_Token.TId(id))
                    break
            elif (_hx_local_0 == 6):
                if (id1 == "inline"):
                    access.append(hscript_FieldAccess.AInline)
                elif (id1 == "public"):
                    access.append(hscript_FieldAccess.APublic)
                elif (id1 == "static"):
                    access.append(hscript_FieldAccess.AStatic)
                else:
                    self.unexpected(hscript_Token.TId(id))
                    break
            else:
                self.unexpected(hscript_Token.TId(id))
                break
        return None

    def readChar(self):
        s = self.input
        index = self.readPos
        self.readPos = (self.readPos + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    def readString(self,until):
        c = 0
        b_b = python_lib_io_StringIO()
        esc = False
        old = self.line
        s = self.input
        while True:
            s = self.input
            index = self.readPos
            self.readPos = (self.readPos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == -1):
                self.line = old
                if (not self.resumeErrors):
                    raise haxe_Exception.thrown(hscript_Error.EUnterminatedString)
                break
            if esc:
                esc = False
                c1 = c
                if (c1 == 47):
                    if self.allowJSON:
                        b_b.write("".join(map(chr,[c])))
                    else:
                        self.invalidChar(c)
                elif (((c1 == 92) or ((c1 == 39))) or ((c1 == 34))):
                    b_b.write("".join(map(chr,[c])))
                elif (c1 == 110):
                    b_b.write("".join(map(chr,[10])))
                elif (c1 == 114):
                    b_b.write("".join(map(chr,[13])))
                elif (c1 == 116):
                    b_b.write("".join(map(chr,[9])))
                elif (c1 == 117):
                    if (not self.allowJSON):
                        self.invalidChar(c)
                    k = 0
                    _g = 0
                    while (_g < 4):
                        i = _g
                        _g = (_g + 1)
                        k = (k << 4)
                        s1 = self.input
                        index1 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                        char1 = char
                        if ((((((((((char1 == 57) or ((char1 == 56))) or ((char1 == 55))) or ((char1 == 54))) or ((char1 == 53))) or ((char1 == 52))) or ((char1 == 51))) or ((char1 == 50))) or ((char1 == 49))) or ((char1 == 48))):
                            k = (k + ((char - 48)))
                        elif ((((((char1 == 70) or ((char1 == 69))) or ((char1 == 68))) or ((char1 == 67))) or ((char1 == 66))) or ((char1 == 65))):
                            k = (k + ((char - 55)))
                        elif ((((((char1 == 102) or ((char1 == 101))) or ((char1 == 100))) or ((char1 == 99))) or ((char1 == 98))) or ((char1 == 97))):
                            k = (k + ((char - 87)))
                        else:
                            if (char == -1):
                                self.line = old
                                if (not self.resumeErrors):
                                    raise haxe_Exception.thrown(hscript_Error.EUnterminatedString)
                            self.invalidChar(char)
                    b_b.write("".join(map(chr,[k])))
                else:
                    self.invalidChar(c)
            elif (c == 92):
                esc = True
            elif (c == until):
                break
            else:
                if (c == 10):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.line
                    _hx_local_4.line = (_hx_local_5 + 1)
                    _hx_local_5
                b_b.write("".join(map(chr,[c])))
        return b_b.getvalue()

    def token(self):
        if (self.tokens.head is not None):
            _this = self.tokens
            k = _this.head
            if (k is None):
                return None
            else:
                _this.head = k.next
                return k.elt
        char = None
        if (self.char < 0):
            s = self.input
            index = self.readPos
            self.readPos = (self.readPos + 1)
            char = (-1 if ((index >= len(s))) else ord(s[index]))
        else:
            char = self.char
            self.char = -1
        while True:
            if (char == -1):
                self.char = char
                return hscript_Token.TEof
            char1 = char
            if (char1 == 0):
                return hscript_Token.TEof
            elif (char1 == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.line
                _hx_local_0.line = (_hx_local_1 + 1)
                _hx_local_1
            elif (((char1 == 32) or ((char1 == 13))) or ((char1 == 9))):
                pass
            elif ((char1 == 39) or ((char1 == 34))):
                return hscript_Token.TConst(hscript_Const.CString(self.readString(char)))
            elif (char1 == 35):
                s = self.input
                index = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index >= len(s))) else ord(s[index]))
                if (self.idents[char] if char >= 0 and char < len(self.idents) else None):
                    id = "".join(map(chr,[char]))
                    while True:
                        s1 = self.input
                        index1 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                        if (not (self.idents[char] if char >= 0 and char < len(self.idents) else None)):
                            self.char = char
                            return self.preprocess(id)
                        id = (("null" if id is None else id) + HxOverrides.stringOrNull("".join(map(chr,[char]))))
                self.invalidChar(char)
            elif (char1 == 40):
                return hscript_Token.TPOpen
            elif (char1 == 41):
                return hscript_Token.TPClose
            elif (char1 == 44):
                return hscript_Token.TComma
            elif (char1 == 46):
                s2 = self.input
                index2 = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index2 >= len(s2))) else ord(s2[index2]))
                char2 = char
                if (char2 == 46):
                    s3 = self.input
                    index3 = self.readPos
                    self.readPos = (self.readPos + 1)
                    char = (-1 if ((index3 >= len(s3))) else ord(s3[index3]))
                    if (char != 46):
                        self.invalidChar(char)
                    return hscript_Token.TOp("...")
                elif ((((((((((char2 == 57) or ((char2 == 56))) or ((char2 == 55))) or ((char2 == 54))) or ((char2 == 53))) or ((char2 == 52))) or ((char2 == 51))) or ((char2 == 50))) or ((char2 == 49))) or ((char2 == 48))):
                    n = (char - 48)
                    exp = 1
                    while True:
                        s4 = self.input
                        index4 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index4 >= len(s4))) else ord(s4[index4]))
                        exp = (exp * 10)
                        char3 = char
                        if ((((((((((char3 == 57) or ((char3 == 56))) or ((char3 == 55))) or ((char3 == 54))) or ((char3 == 53))) or ((char3 == 52))) or ((char3 == 51))) or ((char3 == 50))) or ((char3 == 49))) or ((char3 == 48))):
                            n = ((n * 10) + ((char - 48)))
                        else:
                            self.char = char
                            return hscript_Token.TConst(hscript_Const.CFloat((n / exp)))
                else:
                    self.char = char
                    return hscript_Token.TDot
            elif ((((((((((char1 == 57) or ((char1 == 56))) or ((char1 == 55))) or ((char1 == 54))) or ((char1 == 53))) or ((char1 == 52))) or ((char1 == 51))) or ((char1 == 50))) or ((char1 == 49))) or ((char1 == 48))):
                n1 = (((char - 48)) * 1.0)
                exp1 = 0.
                while True:
                    s5 = self.input
                    index5 = self.readPos
                    self.readPos = (self.readPos + 1)
                    char = (-1 if ((index5 >= len(s5))) else ord(s5[index5]))
                    exp1 = (exp1 * 10)
                    char4 = char
                    if (char4 == 46):
                        if (exp1 > 0):
                            tmp = None
                            if (exp1 == 10):
                                s6 = self.input
                                index6 = self.readPos
                                self.readPos = (self.readPos + 1)
                                tmp = (((-1 if ((index6 >= len(s6))) else ord(s6[index6]))) == 46)
                            else:
                                tmp = False
                            if tmp:
                                _this = self.tokens
                                _this.head = haxe_ds_GenericCell(hscript_Token.TOp("..."),_this.head)
                                i = None
                                try:
                                    i = int(n1)
                                except BaseException as _g:
                                    None
                                    i = None
                                i1 = i
                                return hscript_Token.TConst((hscript_Const.CInt(i1) if ((i1 == n1)) else hscript_Const.CFloat(n1)))
                            self.invalidChar(char)
                        exp1 = 1.
                    elif ((((((((((char4 == 57) or ((char4 == 56))) or ((char4 == 55))) or ((char4 == 54))) or ((char4 == 53))) or ((char4 == 52))) or ((char4 == 51))) or ((char4 == 50))) or ((char4 == 49))) or ((char4 == 48))):
                        n1 = ((n1 * 10) + ((char - 48)))
                    elif ((char4 == 101) or ((char4 == 69))):
                        tk = self.token()
                        pow = None
                        if (tk is None):
                            _this1 = self.tokens
                            _this1.head = haxe_ds_GenericCell(tk,_this1.head)
                        else:
                            tmp1 = tk.index
                            if (tmp1 == 1):
                                _g1 = tk.params[0]
                                if (_g1.index == 0):
                                    e = _g1.params[0]
                                    pow = e
                                else:
                                    _this2 = self.tokens
                                    _this2.head = haxe_ds_GenericCell(tk,_this2.head)
                            elif (tmp1 == 3):
                                if (tk.params[0] == "-"):
                                    tk = self.token()
                                    if (tk is None):
                                        _this3 = self.tokens
                                        _this3.head = haxe_ds_GenericCell(tk,_this3.head)
                                    elif (tk.index == 1):
                                        _g2 = tk.params[0]
                                        if (_g2.index == 0):
                                            e1 = _g2.params[0]
                                            pow = -e1
                                        else:
                                            _this4 = self.tokens
                                            _this4.head = haxe_ds_GenericCell(tk,_this4.head)
                                    else:
                                        _this5 = self.tokens
                                        _this5.head = haxe_ds_GenericCell(tk,_this5.head)
                                else:
                                    _this6 = self.tokens
                                    _this6.head = haxe_ds_GenericCell(tk,_this6.head)
                            else:
                                _this7 = self.tokens
                                _this7.head = haxe_ds_GenericCell(tk,_this7.head)
                        if (pow is None):
                            self.invalidChar(char)
                        return hscript_Token.TConst(hscript_Const.CFloat((((Math.pow(10,pow) / exp1) * n1) * 10)))
                    elif (char4 == 120):
                        if ((n1 > 0) or ((exp1 > 0))):
                            self.invalidChar(char)
                        n2 = 0
                        while True:
                            s7 = self.input
                            index7 = self.readPos
                            self.readPos = (self.readPos + 1)
                            char = (-1 if ((index7 >= len(s7))) else ord(s7[index7]))
                            char5 = char
                            if ((((((((((char5 == 57) or ((char5 == 56))) or ((char5 == 55))) or ((char5 == 54))) or ((char5 == 53))) or ((char5 == 52))) or ((char5 == 51))) or ((char5 == 50))) or ((char5 == 49))) or ((char5 == 48))):
                                n2 = ((((n2 << 4)) + char) - 48)
                            elif ((((((char5 == 70) or ((char5 == 69))) or ((char5 == 68))) or ((char5 == 67))) or ((char5 == 66))) or ((char5 == 65))):
                                n2 = (((n2 << 4)) + ((char - 55)))
                            elif ((((((char5 == 102) or ((char5 == 101))) or ((char5 == 100))) or ((char5 == 99))) or ((char5 == 98))) or ((char5 == 97))):
                                n2 = (((n2 << 4)) + ((char - 87)))
                            else:
                                self.char = char
                                return hscript_Token.TConst(hscript_Const.CInt(n2))
                    else:
                        self.char = char
                        i2 = None
                        try:
                            i2 = int(n1)
                        except BaseException as _g3:
                            None
                            i2 = None
                        i3 = i2
                        return hscript_Token.TConst((hscript_Const.CFloat(((n1 * 10) / exp1)) if ((exp1 > 0)) else (hscript_Const.CInt(i3) if ((i3 == n1)) else hscript_Const.CFloat(n1))))
            elif (char1 == 58):
                return hscript_Token.TDoubleDot
            elif (char1 == 59):
                return hscript_Token.TSemicolon
            elif (char1 == 61):
                s8 = self.input
                index8 = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index8 >= len(s8))) else ord(s8[index8]))
                if (char == 61):
                    return hscript_Token.TOp("==")
                elif (char == 62):
                    return hscript_Token.TOp("=>")
                self.char = char
                return hscript_Token.TOp("=")
            elif (char1 == 63):
                return hscript_Token.TQuestion
            elif (char1 == 64):
                s9 = self.input
                index9 = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index9 >= len(s9))) else ord(s9[index9]))
                if ((self.idents[char] if char >= 0 and char < len(self.idents) else None) or ((char == 58))):
                    id1 = "".join(map(chr,[char]))
                    while True:
                        s10 = self.input
                        index10 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index10 >= len(s10))) else ord(s10[index10]))
                        if (not (self.idents[char] if char >= 0 and char < len(self.idents) else None)):
                            self.char = char
                            return hscript_Token.TMeta(id1)
                        id1 = (("null" if id1 is None else id1) + HxOverrides.stringOrNull("".join(map(chr,[char]))))
                self.invalidChar(char)
            elif (char1 == 91):
                return hscript_Token.TBkOpen
            elif (char1 == 93):
                return hscript_Token.TBkClose
            elif (char1 == 123):
                return hscript_Token.TBrOpen
            elif (char1 == 125):
                return hscript_Token.TBrClose
            else:
                if (self.ops[char] if char >= 0 and char < len(self.ops) else None):
                    op = "".join(map(chr,[char]))
                    while True:
                        s11 = self.input
                        index11 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index11 >= len(s11))) else ord(s11[index11]))
                        if (char == -1):
                            char = 0
                        if (not (self.ops[char] if char >= 0 and char < len(self.ops) else None)):
                            self.char = char
                            return hscript_Token.TOp(op)
                        pop = op
                        op = (("null" if op is None else op) + HxOverrides.stringOrNull("".join(map(chr,[char]))))
                        if ((not (op in self.opPriority.h)) and (pop in self.opPriority.h)):
                            if ((op == "//") or ((op == "/*"))):
                                return self.tokenComment(op,char)
                            self.char = char
                            return hscript_Token.TOp(pop)
                if (self.idents[char] if char >= 0 and char < len(self.idents) else None):
                    id2 = "".join(map(chr,[char]))
                    while True:
                        s12 = self.input
                        index12 = self.readPos
                        self.readPos = (self.readPos + 1)
                        char = (-1 if ((index12 >= len(s12))) else ord(s12[index12]))
                        if (char == -1):
                            char = 0
                        if (not (self.idents[char] if char >= 0 and char < len(self.idents) else None)):
                            self.char = char
                            return hscript_Token.TId(id2)
                        id2 = (("null" if id2 is None else id2) + HxOverrides.stringOrNull("".join(map(chr,[char]))))
                self.invalidChar(char)
            s13 = self.input
            index13 = self.readPos
            self.readPos = (self.readPos + 1)
            char = (-1 if ((index13 >= len(s13))) else ord(s13[index13]))

    def preprocValue(self,id):
        return self.preprocesorValues.h.get(id,None)

    def parsePreproCond(self):
        tk = self.token()
        if (tk is None):
            return self.unexpected(tk)
        else:
            tmp = tk.index
            if (tmp == 2):
                id = tk.params[0]
                return hscript_Expr.EIdent(id)
            elif (tmp == 3):
                if (tk.params[0] == "!"):
                    return hscript_Expr.EUnop("!",True,self.parsePreproCond())
                else:
                    return self.unexpected(tk)
            elif (tmp == 4):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(hscript_Token.TPOpen,_this.head)
                return self.parseExpr()
            else:
                return self.unexpected(tk)

    def evalPreproCond(self,e):
        tmp = e.index
        if (tmp == 1):
            id = e.params[0]
            return (self.preprocValue(id) is not None)
        elif (tmp == 3):
            e1 = e.params[0]
            return self.evalPreproCond(e1)
        elif (tmp == 6):
            _g = e.params[1]
            _g1 = e.params[2]
            _g2 = e.params[0]
            if (_g2 == "&&"):
                e1 = _g
                e2 = _g1
                if self.evalPreproCond(e1):
                    return self.evalPreproCond(e2)
                else:
                    return False
            elif (_g2 == "||"):
                e1 = _g
                e2 = _g1
                if (not self.evalPreproCond(e1)):
                    return self.evalPreproCond(e2)
                else:
                    return True
            else:
                if (not self.resumeErrors):
                    raise haxe_Exception.thrown(hscript_Error.EInvalidPreprocessor(("Can't eval " + HxOverrides.stringOrNull(e.tag))))
                return False
        elif (tmp == 7):
            _g = e.params[1]
            if (e.params[0] == "!"):
                e1 = e.params[2]
                return (not self.evalPreproCond(e1))
            else:
                if (not self.resumeErrors):
                    raise haxe_Exception.thrown(hscript_Error.EInvalidPreprocessor(("Can't eval " + HxOverrides.stringOrNull(e.tag))))
                return False
        else:
            if (not self.resumeErrors):
                raise haxe_Exception.thrown(hscript_Error.EInvalidPreprocessor(("Can't eval " + HxOverrides.stringOrNull(e.tag))))
            return False

    def preprocess(self,id):
        id1 = id
        _hx_local_0 = len(id1)
        if (_hx_local_0 == 4):
            if (id1 == "else"):
                if (len(self.preprocStack) > 0):
                    if python_internal_ArrayImpl._get(self.preprocStack, (len(self.preprocStack) - 1)).r:
                        python_internal_ArrayImpl._get(self.preprocStack, (len(self.preprocStack) - 1)).r = False
                        self.skipTokens()
                        return self.token()
                    elif (id == "else"):
                        _this = self.preprocStack
                        if (len(_this) != 0):
                            _this.pop()
                        _this = self.preprocStack
                        _this.append(_hx_AnonObject({'r': True}))
                        return self.token()
                    else:
                        _this = self.preprocStack
                        if (len(_this) != 0):
                            _this.pop()
                        return self.preprocess("if")
                else:
                    return hscript_Token.TPrepro(id)
            else:
                return hscript_Token.TPrepro(id)
        elif (_hx_local_0 == 3):
            if (id1 == "end"):
                if (len(self.preprocStack) > 0):
                    _this = self.preprocStack
                    if (len(_this) != 0):
                        _this.pop()
                    return self.token()
                else:
                    return hscript_Token.TPrepro(id)
            else:
                return hscript_Token.TPrepro(id)
        elif (_hx_local_0 == 6):
            if (id1 == "elseif"):
                if (len(self.preprocStack) > 0):
                    if python_internal_ArrayImpl._get(self.preprocStack, (len(self.preprocStack) - 1)).r:
                        python_internal_ArrayImpl._get(self.preprocStack, (len(self.preprocStack) - 1)).r = False
                        self.skipTokens()
                        return self.token()
                    elif (id == "else"):
                        _this = self.preprocStack
                        if (len(_this) != 0):
                            _this.pop()
                        _this = self.preprocStack
                        _this.append(_hx_AnonObject({'r': True}))
                        return self.token()
                    else:
                        _this = self.preprocStack
                        if (len(_this) != 0):
                            _this.pop()
                        return self.preprocess("if")
                else:
                    return hscript_Token.TPrepro(id)
            else:
                return hscript_Token.TPrepro(id)
        elif (_hx_local_0 == 2):
            if (id1 == "if"):
                e = self.parsePreproCond()
                if self.evalPreproCond(e):
                    _this = self.preprocStack
                    _this.append(_hx_AnonObject({'r': True}))
                    return self.token()
                _this = self.preprocStack
                _this.append(_hx_AnonObject({'r': False}))
                self.skipTokens()
                return self.token()
            else:
                return hscript_Token.TPrepro(id)
        else:
            return hscript_Token.TPrepro(id)

    def skipTokens(self):
        spos = (len(self.preprocStack) - 1)
        obj = (self.preprocStack[spos] if spos >= 0 and spos < len(self.preprocStack) else None)
        pos = self.readPos
        while True:
            tk = self.token()
            if (tk == hscript_Token.TEof):
                if (not self.resumeErrors):
                    raise haxe_Exception.thrown(hscript_Error.EInvalidPreprocessor("Unclosed"))
            if ((self.preprocStack[spos] if spos >= 0 and spos < len(self.preprocStack) else None) != obj):
                _this = self.tokens
                _this.head = haxe_ds_GenericCell(tk,_this.head)
                break

    def tokenComment(self,op,char):
        c = HxString.charCodeAt(op,1)
        s = self.input
        if (c == 47):
            while ((char != 13) and ((char != 10))):
                s = self.input
                index = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index >= len(s))) else ord(s[index]))
                if (char == -1):
                    break
            self.char = char
            return self.token()
        if (c == 42):
            old = self.line
            if (op == "/**/"):
                self.char = char
                return self.token()
            while True:
                while (char != 42):
                    if (char == 10):
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.line
                        _hx_local_0.line = (_hx_local_1 + 1)
                        _hx_local_1
                    s = self.input
                    index = self.readPos
                    self.readPos = (self.readPos + 1)
                    char = (-1 if ((index >= len(s))) else ord(s[index]))
                    if (char == -1):
                        self.line = old
                        if (not self.resumeErrors):
                            raise haxe_Exception.thrown(hscript_Error.EUnterminatedComment)
                        break
                s1 = self.input
                index1 = self.readPos
                self.readPos = (self.readPos + 1)
                char = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                if (char == -1):
                    self.line = old
                    if (not self.resumeErrors):
                        raise haxe_Exception.thrown(hscript_Error.EUnterminatedComment)
                    break
                if (not ((char != 47))):
                    break
            return self.token()
        self.char = char
        return hscript_Token.TOp(op)

    def constString(self,c):
        tmp = c.index
        if (tmp == 0):
            v = c.params[0]
            return Std.string(v)
        elif (tmp == 1):
            f = c.params[0]
            return Std.string(f)
        elif (tmp == 2):
            s = c.params[0]
            return s
        else:
            pass

    def tokenString(self,t):
        tmp = t.index
        if (tmp == 0):
            return "<eof>"
        elif (tmp == 1):
            c = t.params[0]
            return self.constString(c)
        elif (tmp == 2):
            s = t.params[0]
            return s
        elif (tmp == 3):
            s = t.params[0]
            return s
        elif (tmp == 4):
            return "("
        elif (tmp == 5):
            return ")"
        elif (tmp == 6):
            return "{"
        elif (tmp == 7):
            return "}"
        elif (tmp == 8):
            return "."
        elif (tmp == 9):
            return ","
        elif (tmp == 10):
            return ";"
        elif (tmp == 11):
            return "["
        elif (tmp == 12):
            return "]"
        elif (tmp == 13):
            return "?"
        elif (tmp == 14):
            return ":"
        elif (tmp == 15):
            id = t.params[0]
            return ("@" + ("null" if id is None else id))
        elif (tmp == 16):
            id = t.params[0]
            return ("#" + ("null" if id is None else id))
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.line = None
        _hx_o.opChars = None
        _hx_o.identChars = None
        _hx_o.opPriority = None
        _hx_o.opRightAssoc = None
        _hx_o.preprocesorValues = None
        _hx_o.allowJSON = None
        _hx_o.allowTypes = None
        _hx_o.allowMetadata = None
        _hx_o.resumeErrors = None
        _hx_o.input = None
        _hx_o.readPos = None
        _hx_o.char = None
        _hx_o.ops = None
        _hx_o.idents = None
        _hx_o.uid = None
        _hx_o.tokens = None
        _hx_o.preprocStack = None
hscript_Parser._hx_class = hscript_Parser
_hx_classes["hscript.Parser"] = hscript_Parser


class hscript_Tools:
    _hx_class_name = "hscript.Tools"
    __slots__ = ()
    _hx_statics = ["iter", "map", "expr", "mk"]

    @staticmethod
    def iter(e,f):
        tmp = e.index
        if (tmp == 0):
            _g = e.params[0]
        elif (tmp == 1):
            _g = e.params[0]
        elif (tmp == 2):
            _g = e.params[0]
            _g = e.params[1]
            e1 = e.params[2]
            if (e1 is not None):
                f(e1)
        elif (tmp == 3):
            e1 = e.params[0]
            f(e1)
        elif (tmp == 4):
            el = e.params[0]
            _g = 0
            while (_g < len(el)):
                e1 = (el[_g] if _g >= 0 and _g < len(el) else None)
                _g = (_g + 1)
                f(e1)
        elif (tmp == 5):
            _g = e.params[1]
            e1 = e.params[0]
            f(e1)
        elif (tmp == 6):
            _g = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            f(e1)
            f(e2)
        elif (tmp == 7):
            _g = e.params[0]
            _g = e.params[1]
            e1 = e.params[2]
            f(e1)
        elif (tmp == 8):
            e1 = e.params[0]
            args = e.params[1]
            f(e1)
            _g = 0
            while (_g < len(args)):
                a = (args[_g] if _g >= 0 and _g < len(args) else None)
                _g = (_g + 1)
                f(a)
        elif (tmp == 9):
            c = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            f(c)
            f(e1)
            if (e2 is not None):
                f(e2)
        elif (tmp == 10):
            c = e.params[0]
            e1 = e.params[1]
            f(c)
            f(e1)
        elif (tmp == 11):
            _g = e.params[0]
            it = e.params[1]
            e1 = e.params[2]
            f(it)
            f(e1)
        elif ((tmp == 13) or ((tmp == 12))):
            pass
        elif (tmp == 14):
            _g = e.params[0]
            _g = e.params[2]
            _g = e.params[3]
            e1 = e.params[1]
            f(e1)
        elif (tmp == 15):
            e1 = e.params[0]
            if (e1 is not None):
                f(e1)
        elif (tmp == 16):
            e1 = e.params[0]
            i = e.params[1]
            f(e1)
            f(i)
        elif (tmp == 17):
            el = e.params[0]
            _g = 0
            while (_g < len(el)):
                e1 = (el[_g] if _g >= 0 and _g < len(el) else None)
                _g = (_g + 1)
                f(e1)
        elif (tmp == 18):
            _g = e.params[0]
            el = e.params[1]
            _g = 0
            while (_g < len(el)):
                e1 = (el[_g] if _g >= 0 and _g < len(el) else None)
                _g = (_g + 1)
                f(e1)
        elif (tmp == 19):
            e1 = e.params[0]
            f(e1)
        elif (tmp == 20):
            _g = e.params[1]
            _g = e.params[2]
            e1 = e.params[0]
            c = e.params[3]
            f(e1)
            f(c)
        elif (tmp == 21):
            fl = e.params[0]
            _g = 0
            while (_g < len(fl)):
                fi = (fl[_g] if _g >= 0 and _g < len(fl) else None)
                _g = (_g + 1)
                f(fi.e)
        elif (tmp == 22):
            c = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            f(c)
            f(e1)
            f(e2)
        elif (tmp == 23):
            e1 = e.params[0]
            cases = e.params[1]
            _hx_def = e.params[2]
            f(e1)
            _g = 0
            while (_g < len(cases)):
                c = (cases[_g] if _g >= 0 and _g < len(cases) else None)
                _g = (_g + 1)
                _g1 = 0
                _g2 = c.values
                while (_g1 < len(_g2)):
                    v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    f(v)
                f(c.expr)
            if (_hx_def is not None):
                f(_hx_def)
        elif (tmp == 24):
            c = e.params[0]
            e1 = e.params[1]
            f(c)
            f(e1)
        elif (tmp == 25):
            name = e.params[0]
            args = e.params[1]
            e1 = e.params[2]
            if (args is not None):
                _g = 0
                while (_g < len(args)):
                    a = (args[_g] if _g >= 0 and _g < len(args) else None)
                    _g = (_g + 1)
                    f(a)
            f(e1)
        elif (tmp == 26):
            _g = e.params[1]
            e1 = e.params[0]
            f(e1)
        else:
            pass

    @staticmethod
    def map(e,f):
        edef = None
        edef1 = e.index
        if (edef1 == 0):
            _g = e.params[0]
            edef = e
        elif (edef1 == 1):
            _g = e.params[0]
            edef = e
        elif (edef1 == 2):
            n = e.params[0]
            t = e.params[1]
            e1 = e.params[2]
            edef = hscript_Expr.EVar(n,t,(f(e1) if ((e1 is not None)) else None))
        elif (edef1 == 3):
            e1 = e.params[0]
            edef = hscript_Expr.EParent(f(e1))
        elif (edef1 == 4):
            el = e.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                x = f(e1)
                _g.append(x)
            edef = hscript_Expr.EBlock(_g)
        elif (edef1 == 5):
            e1 = e.params[0]
            fi = e.params[1]
            edef = hscript_Expr.EField(f(e1),fi)
        elif (edef1 == 6):
            op = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            edef = hscript_Expr.EBinop(op,f(e1),f(e2))
        elif (edef1 == 7):
            op = e.params[0]
            pre = e.params[1]
            e1 = e.params[2]
            edef = hscript_Expr.EUnop(op,pre,f(e1))
        elif (edef1 == 8):
            e1 = e.params[0]
            args = e.params[1]
            edef1 = f(e1)
            _g = []
            _g1 = 0
            while (_g1 < len(args)):
                a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                _g1 = (_g1 + 1)
                x = f(a)
                _g.append(x)
            edef = hscript_Expr.ECall(edef1,_g)
        elif (edef1 == 9):
            c = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            edef = hscript_Expr.EIf(f(c),f(e1),(f(e2) if ((e2 is not None)) else None))
        elif (edef1 == 10):
            c = e.params[0]
            e1 = e.params[1]
            edef = hscript_Expr.EWhile(f(c),f(e1))
        elif (edef1 == 11):
            v = e.params[0]
            it = e.params[1]
            e1 = e.params[2]
            edef = hscript_Expr.EFor(v,f(it),f(e1))
        elif ((edef1 == 13) or ((edef1 == 12))):
            edef = e
        elif (edef1 == 14):
            args = e.params[0]
            e1 = e.params[1]
            name = e.params[2]
            t = e.params[3]
            edef = hscript_Expr.EFunction(args,f(e1),name,t)
        elif (edef1 == 15):
            e1 = e.params[0]
            edef = hscript_Expr.EReturn((f(e1) if ((e1 is not None)) else None))
        elif (edef1 == 16):
            e1 = e.params[0]
            i = e.params[1]
            edef = hscript_Expr.EArray(f(e1),f(i))
        elif (edef1 == 17):
            el = e.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                x = f(e1)
                _g.append(x)
            edef = hscript_Expr.EArrayDecl(_g)
        elif (edef1 == 18):
            cl = e.params[0]
            el = e.params[1]
            _g = []
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                x = f(e1)
                _g.append(x)
            edef = hscript_Expr.ENew(cl,_g)
        elif (edef1 == 19):
            e1 = e.params[0]
            edef = hscript_Expr.EThrow(f(e1))
        elif (edef1 == 20):
            e1 = e.params[0]
            v = e.params[1]
            t = e.params[2]
            c = e.params[3]
            edef = hscript_Expr.ETry(f(e1),v,t,f(c))
        elif (edef1 == 21):
            fl = e.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(fl)):
                fi = (fl[_g1] if _g1 >= 0 and _g1 < len(fl) else None)
                _g1 = (_g1 + 1)
                x = _hx_AnonObject({'name': fi.name, 'e': f(fi.e)})
                _g.append(x)
            edef = hscript_Expr.EObject(_g)
        elif (edef1 == 22):
            c = e.params[0]
            e1 = e.params[1]
            e2 = e.params[2]
            edef = hscript_Expr.ETernary(f(c),f(e1),f(e2))
        elif (edef1 == 23):
            e1 = e.params[0]
            cases = e.params[1]
            _hx_def = e.params[2]
            edef1 = f(e1)
            _g = []
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _g2 = []
                _g3 = 0
                _g4 = c.values
                while (_g3 < len(_g4)):
                    v = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = f(v)
                    _g2.append(x)
                x1 = _hx_AnonObject({'values': _g2, 'expr': f(c.expr)})
                _g.append(x1)
            edef = hscript_Expr.ESwitch(edef1,_g,(None if ((_hx_def is None)) else f(_hx_def)))
        elif (edef1 == 24):
            c = e.params[0]
            e1 = e.params[1]
            edef = hscript_Expr.EDoWhile(f(c),f(e1))
        elif (edef1 == 25):
            name = e.params[0]
            args = e.params[1]
            e1 = e.params[2]
            edef1 = None
            if (args is None):
                edef1 = None
            else:
                _g = []
                _g1 = 0
                while (_g1 < len(args)):
                    a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                    _g1 = (_g1 + 1)
                    x = f(a)
                    _g.append(x)
                edef1 = _g
            edef = hscript_Expr.EMeta(name,edef1,f(e1))
        elif (edef1 == 26):
            e1 = e.params[0]
            t = e.params[1]
            edef = hscript_Expr.ECheckType(f(e1),t)
        else:
            pass
        return edef

    @staticmethod
    def expr(e):
        return e

    @staticmethod
    def mk(e,p):
        return e
hscript_Tools._hx_class = hscript_Tools
_hx_classes["hscript.Tools"] = hscript_Tools


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "toUpperCase", "length", "rshift", "modf", "mod", "arrayGet", "arraySet", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def toUpperCase(x):
        if isinstance(x,str):
            return x.upper()
        return x.toUpperCase()

    @staticmethod
    def length(x):
        if isinstance(x,str):
            return len(x)
        elif isinstance(x,list):
            return len(x)
        return x.length

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def arraySet(a,i,v):
        if isinstance(a,list):
            x = a
            v1 = v
            l = len(x)
            while (l < i):
                x.append(None)
                l = (l + 1)
            if (l == i):
                x.append(v1)
            else:
                x[i] = v1
            return v1
        else:
            a[i] = v
            return v

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides
_hx_classes["HxOverrides"] = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()
sys_io_File._hx_class = sys_io_File
_hx_classes["sys.io.File"] = sys_io_File


class sys_thread__EventLoop_RegularEvent:
    _hx_class_name = "sys.thread._EventLoop.RegularEvent"
    __slots__ = ("nextRunTime", "interval", "run", "next", "cancelled")
    _hx_fields = ["nextRunTime", "interval", "run", "next", "cancelled"]

    def __init__(self,run,nextRunTime,interval):
        self.next = None
        self.cancelled = False
        self.run = run
        self.nextRunTime = nextRunTime
        self.interval = interval

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nextRunTime = None
        _hx_o.interval = None
        _hx_o.run = None
        _hx_o.next = None
        _hx_o.cancelled = None
sys_thread__EventLoop_RegularEvent._hx_class = sys_thread__EventLoop_RegularEvent
_hx_classes["sys.thread._EventLoop.RegularEvent"] = sys_thread__EventLoop_RegularEvent


class sys_thread_Lock:
    _hx_class_name = "sys.thread.Lock"
    __slots__ = ("semaphore",)
    _hx_fields = ["semaphore"]

    def __init__(self):
        self.semaphore = python_lib_threading_Semaphore(0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.semaphore = None
sys_thread_Lock._hx_class = sys_thread_Lock
_hx_classes["sys.thread.Lock"] = sys_thread_Lock


class sys_thread__Thread_Thread_Impl_:
    _hx_class_name = "sys.thread._Thread.Thread_Impl_"
    __slots__ = ()
    _hx_statics = ["processEvents"]

    @staticmethod
    def processEvents():
        sys_thread__Thread_HxThread.current().events.loop()
sys_thread__Thread_Thread_Impl_._hx_class = sys_thread__Thread_Thread_Impl_
_hx_classes["sys.thread._Thread.Thread_Impl_"] = sys_thread__Thread_Thread_Impl_


class yutautil_ChanceSelector:
    _hx_class_name = "yutautil.ChanceSelector"
    __slots__ = ()
    _hx_statics = ["selectOption", "fromArray", "fromMap", "chanceArrays", "selectFromOptions", "selectFromMap", "executeChanceFunction", "chanceFunction"]

    @staticmethod
    def selectOption(options,strict = None,downsize = None,allowNull = None):
        if (strict is None):
            strict = False
        if (downsize is None):
            downsize = True
        if (allowNull is None):
            allowNull = False
        totalChance = 0
        _g = 0
        while (_g < len(options)):
            o = (options[_g] if _g >= 0 and _g < len(options) else None)
            _g = (_g + 1)
            if (Reflect.field(o,"condition") is not None):
                if (not Reflect.field(o,"condition")):
                    python_internal_ArrayImpl.remove(options,o)
                    continue
            if ((o.chance < 0) or ((o.chance > 100))):
                raise haxe_Exception.thrown("Chance must be between 0 and 100")
            totalChance = (totalChance + o.chance)
        if ((totalChance > 100) and strict):
            raise haxe_Exception.thrown("Total chance exceeds 100%")
        if (downsize and ((totalChance > 100))):
            scaleFactor = (100 / totalChance)
            scaledOptions = []
            _g = 0
            while (_g < len(options)):
                o = (options[_g] if _g >= 0 and _g < len(options) else None)
                _g = (_g + 1)
                x = _hx_AnonObject({'item': o.item, 'chance': (o.chance * scaleFactor)})
                scaledOptions.append(x)
            options = scaledOptions
            totalChance = 100
        weightedList = []
        _g = 0
        while (_g < len(options)):
            o = (options[_g] if _g >= 0 and _g < len(options) else None)
            _g = (_g + 1)
            itemCount = Math.floor((o.chance + 0.5))
            _g1 = 0
            _g2 = itemCount
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = o.item
                weightedList.append(x)
        potentialList = []
        _g = 0
        while (_g < len(options)):
            o = (options[_g] if _g >= 0 and _g < len(options) else None)
            _g = (_g + 1)
            potential = (o.chance / totalChance)
            x = _hx_AnonObject({'item': o.item, 'potential': potential})
            potentialList.append(x)
        haxe_Log.trace(("Potential list: " + Std.string(potentialList)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 58, 'className': "yutautil.ChanceSelector", 'methodName': "selectOption"}))
        if (len(weightedList) == 0):
            if allowNull:
                return None
            raise haxe_Exception.thrown("No valid options to select from")
        x = len(weightedList)
        randomIndex = (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))
        selectedOption = (weightedList[randomIndex] if randomIndex >= 0 and randomIndex < len(weightedList) else None)
        if ((selectedOption is None) and (not allowNull)):
            raise haxe_Exception.thrown("Selected option is null")
        haxe_Log.trace(("Selected option: " + ("null" if selectedOption is None else selectedOption)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 74, 'className': "yutautil.ChanceSelector", 'methodName': "selectOption"}))
        return selectedOption

    @staticmethod
    def fromArray(items):
        haxe_Log.trace("Entering fromArray function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 80, 'className': "yutautil.ChanceSelector", 'methodName': "fromArray"}))
        haxe_Log.trace(("Input items: " + Std.string(items)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 81, 'className': "yutautil.ChanceSelector", 'methodName': "fromArray"}))
        options = []
        chancePerItem = (100 / len(items))
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            options.append(_hx_AnonObject({'item': item, 'chance': chancePerItem}))
        haxe_Log.trace(("Output options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 88, 'className': "yutautil.ChanceSelector", 'methodName': "fromArray"}))
        return options

    @staticmethod
    def fromMap(_hx_map):
        haxe_Log.trace("Entering fromMap function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 94, 'className': "yutautil.ChanceSelector", 'methodName': "fromMap"}))
        haxe_Log.trace(("Input map: " + HxOverrides.stringOrNull((("null" if ((_hx_map is None)) else _hx_map.toString())))),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 95, 'className': "yutautil.ChanceSelector", 'methodName': "fromMap"}))
        options = []
        totalChance = 0
        item = _hx_map.keys()
        while item.hasNext():
            item1 = item.next()
            chance = _hx_map.h.get(item1,None)
            options.append(_hx_AnonObject({'item': item1, 'chance': chance}))
            totalChance = (totalChance + chance)
        if (totalChance > 100):
            scaleFactor = (100 / totalChance)
            _g = 0
            while (_g < len(options)):
                o = (options[_g] if _g >= 0 and _g < len(options) else None)
                _g = (_g + 1)
                o.chance = (o.chance * scaleFactor)
        haxe_Log.trace(("Output options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 112, 'className': "yutautil.ChanceSelector", 'methodName': "fromMap"}))
        return options

    @staticmethod
    def chanceArrays(items,chances = None):
        haxe_Log.trace("Entering chanceArrays function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 118, 'className': "yutautil.ChanceSelector", 'methodName': "chanceArrays"}))
        haxe_Log.trace(("Input items:" + Std.string(items)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 119, 'className': "yutautil.ChanceSelector", 'methodName': "chanceArrays"}))
        haxe_Log.trace(("Input chances: " + Std.string(chances)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 120, 'className': "yutautil.ChanceSelector", 'methodName': "chanceArrays"}))
        if ((chances is not None) and ((len(items) != len(chances)))):
            raise haxe_Exception.thrown("Items and chances arrays must be of the same length")
        options = []
        if (chances is None):
            equalChance = (100 / len(items))
            _g = 0
            while (_g < len(items)):
                item = (items[_g] if _g >= 0 and _g < len(items) else None)
                _g = (_g + 1)
                options.append(_hx_AnonObject({'item': item, 'chance': equalChance}))
        else:
            _g = 0
            _g1 = len(items)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                options.append(_hx_AnonObject({'item': (items[i] if i >= 0 and i < len(items) else None), 'chance': (chances[i] if i >= 0 and i < len(chances) else None)}))
        haxe_Log.trace(("Output options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 139, 'className': "yutautil.ChanceSelector", 'methodName': "chanceArrays"}))
        selectedOption = yutautil_ChanceSelector.selectOption(options)
        haxe_Log.trace(("Selected option: " + ("null" if selectedOption is None else selectedOption)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 142, 'className': "yutautil.ChanceSelector", 'methodName': "chanceArrays"}))
        return selectedOption

    @staticmethod
    def selectFromOptions(options):
        haxe_Log.trace("Entering selectFromOptions function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 149, 'className': "yutautil.ChanceSelector", 'methodName': "selectFromOptions"}))
        haxe_Log.trace(("Input options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 150, 'className': "yutautil.ChanceSelector", 'methodName': "selectFromOptions"}))
        selectedOption = yutautil_ChanceSelector.selectOption(options)
        haxe_Log.trace(("Selected option: " + ("null" if selectedOption is None else selectedOption)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 153, 'className': "yutautil.ChanceSelector", 'methodName': "selectFromOptions"}))
        return selectedOption

    @staticmethod
    def selectFromMap(itemChancesMap):
        options = []
        item = itemChancesMap.keys()
        while item.hasNext():
            item1 = item.next()
            chance = itemChancesMap.h.get(item1,None)
            options.append(_hx_AnonObject({'item': item1, 'chance': chance}))
        selectedOption = yutautil_ChanceSelector.selectOption(options)
        return selectedOption

    @staticmethod
    def executeChanceFunction(chanceFunc):
        randomNumber = (python_lib_Random.random() * 100)
        if ((randomNumber <= chanceFunc.chance) and (((Reflect.field(chanceFunc,"condition") is None) or Reflect.field(chanceFunc,"condition")))):
            return chanceFunc.func()
        return None

    @staticmethod
    def chanceFunction(func,chance):
        chanceFunc = _hx_AnonObject({'func': func, 'chance': chance})
        yutautil_ChanceSelector.executeChanceFunction(chanceFunc)
yutautil_ChanceSelector._hx_class = yutautil_ChanceSelector
_hx_classes["yutautil.ChanceSelector"] = yutautil_ChanceSelector


class yutautil_ChanceExtensions:
    _hx_class_name = "yutautil.ChanceExtensions"
    __slots__ = ()
    _hx_statics = ["isChance", "chanceArray", "chanceMap", "chanceDynamicMap", "chanceBool", "TrueFalse", "chanceInt", "chanceFloat", "selectMultiple", "createMultipleCopies"]

    @staticmethod
    def isChance(item):
        if (python_Boot.hasField(item,"item") and python_Boot.hasField(item,"chance")):
            return Std.isOfType(Reflect.field(item,"chance"),Float)
        else:
            return False

    @staticmethod
    def chanceArray(array):
        haxe_Log.trace("Entering chanceArray function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 207, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceArray"}))
        haxe_Log.trace(("Input array: " + Std.string(array)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 208, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceArray"}))
        options = yutautil_ChanceSelector.fromArray(array)
        haxe_Log.trace(("Options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 211, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceArray"}))
        selectedOption = yutautil_ChanceSelector.selectOption(options)
        haxe_Log.trace(("Selected option: " + ("null" if selectedOption is None else selectedOption)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 214, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceArray"}))
        return selectedOption

    @staticmethod
    def chanceMap(_hx_map):
        selectedOption = yutautil_ChanceSelector.selectFromMap(_hx_map)
        return selectedOption

    @staticmethod
    def chanceDynamicMap(_hx_map,returnKey = None):
        if (returnKey is None):
            returnKey = True
        haxe_Log.trace("Entering chanceDynamicMap function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 231, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceDynamicMap"}))
        haxe_Log.trace(("Input map: " + HxOverrides.stringOrNull((("null" if ((_hx_map is None)) else _hx_map.toString())))),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 232, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceDynamicMap"}))
        haxe_Log.trace(("Input returnKey: " + Std.string(returnKey)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 233, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceDynamicMap"}))
        array = []
        item = _hx_map.keys()
        while item.hasNext():
            item1 = item.next()
            array.append(item1)
        options = yutautil_ChanceSelector.fromArray(array)
        haxe_Log.trace(("Options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 241, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceDynamicMap"}))
        selectedOption = yutautil_ChanceSelector.selectOption(options)
        haxe_Log.trace(("Selected option: " + ("null" if selectedOption is None else selectedOption)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 244, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceDynamicMap"}))
        if returnKey:
            return selectedOption
        else:
            return _hx_map.h.get(selectedOption,None)

    @staticmethod
    def chanceBool(value,chance):
        haxe_Log.trace("Entering chanceBool function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 255, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceBool"}))
        haxe_Log.trace(("Input value: " + Std.string(value)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 256, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceBool"}))
        haxe_Log.trace(("Input chance: " + Std.string(chance)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 257, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceBool"}))
        oppositeValueChance = (100 - chance)
        options = [_hx_AnonObject({'item': value, 'chance': chance}), _hx_AnonObject({'item': (not value), 'chance': oppositeValueChance})]
        haxe_Log.trace(("Options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 264, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceBool"}))
        selectedOption = yutautil_ChanceSelector.selectFromOptions(options)
        haxe_Log.trace("Selected option: ",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 267, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceBool", 'customParams': [selectedOption]}))
        return selectedOption

    @staticmethod
    def TrueFalse(trueChance,falseChance):
        haxe_Log.trace("Entering TrueFalse function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 274, 'className': "yutautil.ChanceExtensions", 'methodName': "TrueFalse"}))
        haxe_Log.trace(("Input trueChance: " + Std.string(trueChance)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 275, 'className': "yutautil.ChanceExtensions", 'methodName': "TrueFalse"}))
        haxe_Log.trace(("Input falseChance: " + Std.string(falseChance)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 276, 'className': "yutautil.ChanceExtensions", 'methodName': "TrueFalse"}))
        options = [_hx_AnonObject({'item': True, 'chance': trueChance}), _hx_AnonObject({'item': False, 'chance': falseChance})]
        haxe_Log.trace(("Options: " + Std.string(options)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 282, 'className': "yutautil.ChanceExtensions", 'methodName': "TrueFalse"}))
        selectedOption = yutautil_ChanceSelector.selectFromOptions(options)
        haxe_Log.trace("Selected option: ",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 285, 'className': "yutautil.ChanceExtensions", 'methodName': "TrueFalse", 'customParams': [selectedOption]}))
        return selectedOption

    @staticmethod
    def chanceInt(_hx_min,_hx_max):
        haxe_Log.trace("Entering chanceInt function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 292, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceInt"}))
        haxe_Log.trace(("Input min: " + Std.string(_hx_min)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 293, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceInt"}))
        haxe_Log.trace(("Input max: " + Std.string(_hx_max)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 294, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceInt"}))
        options = []
        _g = _hx_min
        _g1 = (_hx_max + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            options.append(_hx_AnonObject({'item': i, 'chance': 100}))
        selectedOption = yutautil_ChanceSelector.selectFromOptions(options)
        haxe_Log.trace("Selected option: ",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 303, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceInt", 'customParams': [selectedOption]}))
        return selectedOption

    @staticmethod
    def chanceFloat(_hx_min,_hx_max,floatingPoint):
        haxe_Log.trace("Entering chanceFloat function",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 309, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceFloat"}))
        haxe_Log.trace(("Input min: " + Std.string(_hx_min)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 310, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceFloat"}))
        haxe_Log.trace(("Input max: " + Std.string(_hx_max)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 311, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceFloat"}))
        haxe_Log.trace(("Input floatingPoint: " + Std.string(floatingPoint)),_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 312, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceFloat"}))
        factor = Math.pow(10,floatingPoint)
        options = []
        _g = 0
        _g1 = (Math.floor(((((_hx_max - _hx_min)) * factor) + 0.5)) + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            value = (_hx_min + ((i / factor)))
            options.append(_hx_AnonObject({'item': value, 'chance': 100}))
        selectedOption = yutautil_ChanceSelector.selectFromOptions(options)
        haxe_Log.trace("Selected option: ",_hx_AnonObject({'fileName': "src/yutautil/ChanceSelector.hx", 'lineNumber': 323, 'className': "yutautil.ChanceExtensions", 'methodName': "chanceFloat", 'customParams': [selectedOption]}))
        return selectedOption

    @staticmethod
    def selectMultiple(items,count,allowDuplicates = None):
        if (allowDuplicates is None):
            allowDuplicates = False
        selectedItems = []
        availableItems = list(items)
        if ((not allowDuplicates) and ((count > len(availableItems)))):
            raise haxe_Exception.thrown("Count cannot be greater than the number of unique items when duplicates are not allowed.")
        while (len(selectedItems) < count):
            selectedItem = yutautil_ChanceSelector.chanceArrays(availableItems)
            if (not allowDuplicates):
                index = python_internal_ArrayImpl.indexOf(availableItems,selectedItem,None)
                if (index != -1):
                    pos = index
                    if (pos < 0):
                        pos = (len(availableItems) + pos)
                    if (pos < 0):
                        pos = 0
                    res = availableItems[pos:(pos + 1)]
                    del availableItems[pos:(pos + 1)]
            selectedItems.append(selectedItem)
        return selectedItems

    @staticmethod
    def createMultipleCopies(item,count):
        copies = []
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            copies.append(item)
        return copies
yutautil_ChanceExtensions._hx_class = yutautil_ChanceExtensions
_hx_classes["yutautil.ChanceExtensions"] = yutautil_ChanceExtensions


class yutautil_CollectionUtils:
    _hx_class_name = "yutautil.CollectionUtils"
    __slots__ = ()
    _hx_statics = ["isIterable", "isMap", "isIterableOfType", "list", "funcAndReturn", "toList", "toArray", "getInfinity", "pushMulti", "concatMulti", "concatPush", "maybePush", "pushUnique", "listIndexOf", "listIndex", "mapIndexOf", "mapIndex", "mapKYIndexOf", "mapKYIndex", "callOnGeneric", "callFromGeneric", "callOn", "mapT", "filterT", "mapToObject", "enumToObj", "forEachT", "defaultOf", "toIterable", "asCallable", "asVoidCallable", "asVoidCallableWithArgs", "asTypedCallable", "toCallable", "forEachIf", "mapTIf", "mapIfBreak", "CForLoop", "forEachIfElse", "forEachIfElseTree", "mapTIfElse", "mapTIfElseTree", "generateRandomString", "generateRandomNumber", "isEmpty", "isNotEmpty", "lengthTo", "createTestData"]

    @staticmethod
    def isIterable(input):
        if (not ((Std.isOfType(input,list) or Std.isOfType(input,haxe_IMap)))):
            if (not python_Boot.hasField(input,"iterator")):
                if python_Boot.hasField(input,"hasNext"):
                    return python_Boot.hasField(input,"next")
                else:
                    return False
            else:
                return True
        else:
            return True

    @staticmethod
    def isMap(input):
        return Std.isOfType(input,haxe_IMap)

    @staticmethod
    def isIterableOfType(input,_hx_type):
        if (not (((Std.isOfType(input,list) and ((len(input) > 0))) or ((Std.isOfType(input,haxe_IMap) and input.keys().hasNext()))))):
            if (not python_Boot.hasField(input,"iterator")):
                if python_Boot.hasField(input,"hasNext"):
                    return python_Boot.hasField(input,"next")
                else:
                    return False
            else:
                return True
        else:
            return True

    @staticmethod
    def list(l):
        return l

    @staticmethod
    def funcAndReturn(func,item):
        func(item)
        return item

    @staticmethod
    def toList(input):
        if Std.isOfType(input,list):
            _hx_list = haxe_ds_List()
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_list.add(item)
            return _hx_list
        elif Std.isOfType(input,haxe_IMap):
            _hx_list = haxe_ds_List()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                _hx_list.add(_hx_AnonObject({'key': key1, 'value': Reflect.field(input,"get")(key1)}))
            return _hx_list
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            _hx_list = haxe_ds_List()
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                _hx_list.add(item1)
            return _hx_list
        else:
            l = haxe_ds_List()
            l.add(input)
            return l

    @staticmethod
    def toArray(input,_hx_type = None):
        if Std.isOfType(input,list):
            return input
        elif Std.isOfType(input,haxe_IMap):
            result = []
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                x = _hx_AnonObject({'key': key1, 'value': Reflect.field(input,"get")(key1)})
                result.append(x)
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                result.append(item1)
            return result
        else:
            return [input]

    @staticmethod
    def getInfinity(t,positive = None):
        if (positive is None):
            positive = True
        if Std.isOfType(t,Float):
            if positive:
                return Math.POSITIVE_INFINITY
            else:
                return Math.NEGATIVE_INFINITY
        elif Std.isOfType(t,Int):
            POSITIVE_INFINITY_INT = 2147483647
            NEGATIVE_INFINITY_INT = -2147483648
            if positive:
                return POSITIVE_INFINITY_INT
            else:
                return NEGATIVE_INFINITY_INT
        else:
            raise haxe_Exception.thrown("Unsupported type for infinity")

    @staticmethod
    def pushMulti(a,items):
        indices = []
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            a.append(item)
            x = (len(a) - 1)
            indices.append(x)
        return _hx_AnonObject({'indices': indices, 'length': len(a)})

    @staticmethod
    def concatMulti(a,items):
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            (a + item)
        return a

    @staticmethod
    def concatPush(a,items):
        _g = 0
        while (_g < len(items)):
            array = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            indices = []
            _g1 = 0
            while (_g1 < len(array)):
                item = (array[_g1] if _g1 >= 0 and _g1 < len(array) else None)
                _g1 = (_g1 + 1)
                a.append(item)
                x = (len(a) - 1)
                indices.append(x)
        return a

    @staticmethod
    def maybePush(a,item,chance):
        if yutautil_ChanceExtensions.chanceBool(True,chance):
            a.append(item)
            return True
        return False

    @staticmethod
    def pushUnique(a,item):
        if (python_internal_ArrayImpl.indexOf(a,item,None) == -1):
            a.append(item)
            return True
        return False

    @staticmethod
    def listIndexOf(_hx_list,item):
        index = 0
        _g_head = _hx_list.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            current = val
            if HxOverrides.eq(current,item):
                return index
            index = (index + 1)
        return -1

    @staticmethod
    def listIndex(_hx_list,index):
        i = 0
        _g_head = _hx_list.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            item = val
            if (i == index):
                return item
            i = (i + 1)
        return None

    @staticmethod
    def mapIndexOf(_hx_map,item):
        key = _hx_map.keys()
        while key.hasNext():
            key1 = key.next()
            if HxOverrides.eq(_hx_map.h.get(key1,None),item):
                return key1
        return None

    @staticmethod
    def mapIndex(_hx_map,index):
        i = 0
        key = _hx_map.keys()
        while key.hasNext():
            key1 = key.next()
            if (i == index):
                return key1
            i = (i + 1)
        return None

    @staticmethod
    def mapKYIndexOf(_hx_map,key,value):
        index = 0
        k = _hx_map.keys()
        while k.hasNext():
            k1 = k.next()
            if (HxOverrides.eq(k1,key) and (HxOverrides.eq(_hx_map.get(k1),value))):
                return index
            index = (index + 1)
        return -1

    @staticmethod
    def mapKYIndex(_hx_map,index):
        i = 0
        key = _hx_map.keys()
        while key.hasNext():
            key1 = key.next()
            if (i == index):
                return _hx_AnonObject({'key': key1, 'value': _hx_map.get(key1)})
            i = (i + 1)
        return None

    @staticmethod
    def callOnGeneric(CLASS,func):
        return func(Type.createEmptyInstance(CLASS))

    @staticmethod
    def callFromGeneric(CLASS,func):
        return func(Type.createEmptyInstance(CLASS))

    @staticmethod
    def callOn(item,func):
        return func(item)

    @staticmethod
    def mapT(input,func):
        if Std.isOfType(input,list):
            return list(map(func,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = func(Reflect.field(input,"get")(key1))
                result.h[key1] = value
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                x = func(item1)
                result.append(x)
            return result
        else:
            return func(input)

    @staticmethod
    def filterT(input,func):
        if Std.isOfType(input,list):
            return list(filter(func,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if func(value):
                    result.h[key1] = value
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if func(item1):
                    result.append(item1)
            return result
        elif func(input):
            return input
        else:
            return None

    @staticmethod
    def mapToObject(In):
        if Std.isOfType(In,list):
            out = _hx_AnonObject({})
            _g = 0
            _g1 = len(In)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                field = Std.string(i)
                setattr(out,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),HxOverrides.arrayGet(In, i))
            return out
        elif Std.isOfType(In,haxe_IMap):
            out = _hx_AnonObject({})
            key = In.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(In,"get")(key1)
                setattr(out,(("_hx_" + key1) if ((key1 in python_Boot.keywords)) else (("_hx_" + key1) if (((((len(key1) > 2) and ((ord(key1[0]) == 95))) and ((ord(key1[1]) == 95))) and ((ord(key1[(len(key1) - 1)]) != 95)))) else key1)),value)
            return out
        elif (python_Boot.hasField(In,"iterator") or ((python_Boot.hasField(In,"hasNext") and python_Boot.hasField(In,"next")))):
            out = _hx_AnonObject({})
            i = 0
            item = HxOverrides.iterator(In)
            while item.hasNext():
                item1 = item.next()
                field = Std.string(i)
                setattr(out,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),item1)
                i = (i + 1)
            return out
        else:
            return In

    @staticmethod
    def enumToObj(In):
        out = _hx_AnonObject({})
        _g = 0
        _g1 = Type.getEnumConstructs(Type.getEnum(In))
        while (_g < len(_g1)):
            field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Type.createEnum(Type.getEnum(In),field)
            setattr(out,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)
        return out

    @staticmethod
    def forEachT(input,func):
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                func(item)
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                func(Reflect.field(input,"get")(key1))
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                func(item1)
        else:
            func(input)

    @staticmethod
    def defaultOf(CLASS):
        return Type.createEmptyInstance(CLASS)

    @staticmethod
    def toIterable(input):
        if Std.isOfType(input,list):
            return input
        elif Std.isOfType(input,haxe_IMap):
            result = []
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                x = Reflect.field(input,"get")(key1)
                result.append(x)
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            return input
        else:
            return [input]

    @staticmethod
    def asCallable(func):
        def _hx_local_0():
            func(None)
        return _hx_local_0

    @staticmethod
    def asVoidCallable(func):
        def _hx_local_0():
            return func()
        return _hx_local_0

    @staticmethod
    def asVoidCallableWithArgs(func):
        def _hx_local_0(arg):
            return func()
        return _hx_local_0

    @staticmethod
    def asTypedCallable(func):
        return func

    @staticmethod
    def toCallable(item):
        def _hx_local_0():
            return item
        return _hx_local_0

    @staticmethod
    def forEachIf(input,predicate,func):
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if predicate(item):
                    func(item)
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if predicate(value):
                    func(value)
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if predicate(item1):
                    func(item1)
        elif predicate(input):
            func(input)

    @staticmethod
    def mapTIf(input,predicate,func):
        if Std.isOfType(input,list):
            def _hx_local_1():
                def _hx_local_0(item):
                    if predicate(item):
                        return func(item)
                    else:
                        return item
                return list(map(_hx_local_0,input))
            return _hx_local_1()
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                value1 = (func(value) if (predicate(value)) else value)
                result.h[key1] = value1
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                x = (func(item1) if (predicate(item1)) else item1)
                result.append(x)
            return result
        elif predicate(input):
            return func(input)
        else:
            return input

    @staticmethod
    def mapIfBreak(input,predicate,func):
        if Std.isOfType(input,list):
            result = []
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if predicate(item):
                    x = func(item)
                    result.append(x)
                    break
            return result
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if predicate(value):
                    value1 = func(value)
                    result.h[key1] = value1
                    break
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if predicate(item1):
                    x = func(item1)
                    result.append(x)
                    break
            return result
        elif predicate(input):
            return func(input)
        else:
            return input

    @staticmethod
    def CForLoop(i,condition,increment,func):
        i1 = i
        while condition(i1):
            func(i1)
            i1 = increment(i1)

    @staticmethod
    def forEachIfElse(input,predicate,ifFunc,elseFunc):
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if predicate(item):
                    ifFunc(item)
                else:
                    elseFunc(item)
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if predicate(value):
                    ifFunc(value)
                else:
                    elseFunc(value)
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if predicate(item1):
                    ifFunc(item1)
                else:
                    elseFunc(item1)
        elif predicate(input):
            ifFunc(input)
        else:
            elseFunc(input)

    @staticmethod
    def forEachIfElseTree(input,conditions,elseFunc):
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                matched = False
                predicate = conditions.keys()
                while predicate.hasNext():
                    predicate1 = predicate.next()
                    if predicate1(item):
                        conditions.get(predicate1)(item)
                        matched = True
                        break
                if (not matched):
                    elseFunc(item)
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                matched = False
                predicate = conditions.keys()
                while predicate.hasNext():
                    predicate1 = predicate.next()
                    if predicate1(value):
                        conditions.get(predicate1)(value)
                        matched = True
                        break
                if (not matched):
                    elseFunc(value)
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                matched = False
                predicate = conditions.keys()
                while predicate.hasNext():
                    predicate1 = predicate.next()
                    if predicate1(item1):
                        conditions.get(predicate1)(item1)
                        matched = True
                        break
                if (not matched):
                    elseFunc(item1)
        else:
            matched = False
            predicate = conditions.keys()
            while predicate.hasNext():
                predicate1 = predicate.next()
                if predicate1(input):
                    conditions.get(predicate1)(input)
                    matched = True
                    break
            if (not matched):
                elseFunc(input)

    @staticmethod
    def mapTIfElse(input,predicate,ifFunc,elseFunc):
        if Std.isOfType(input,list):
            def _hx_local_1():
                def _hx_local_0(item):
                    if predicate(item):
                        return ifFunc(item)
                    else:
                        return elseFunc(item)
                return list(map(_hx_local_0,input))
            return _hx_local_1()
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                value1 = (ifFunc(value) if (predicate(value)) else elseFunc(value))
                result.h[key1] = value1
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                x = (ifFunc(item1) if (predicate(item1)) else elseFunc(item1))
                result.append(x)
            return result
        elif predicate(input):
            return ifFunc(input)
        else:
            return elseFunc(input)

    @staticmethod
    def mapTIfElseTree(input,conditions,elseFunc):
        if Std.isOfType(input,list):
            def _hx_local_1():
                def _hx_local_0(item):
                    predicate = conditions.keys()
                    while predicate.hasNext():
                        predicate1 = predicate.next()
                        if predicate1(item):
                            return conditions.get(predicate1)(item)
                    return elseFunc(item)
                return list(map(_hx_local_0,input))
            return _hx_local_1()
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                predicate = conditions.keys()
                while predicate.hasNext():
                    predicate1 = predicate.next()
                    if predicate1(value):
                        value1 = conditions.get(predicate1)(value)
                        result.h[key1] = value1
                        break
                if (not (key1 in result.h)):
                    value2 = elseFunc(value)
                    result.h[key1] = value2
            return result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                predicate = conditions.keys()
                while predicate.hasNext():
                    predicate1 = predicate.next()
                    if predicate1(item1):
                        x = conditions.get(predicate1)(item1)
                        result.append(x)
                        break
                if (len(result) == 0):
                    x1 = elseFunc(item1)
                    result.append(x1)
            return result
        else:
            predicate = conditions.keys()
            while predicate.hasNext():
                predicate1 = predicate.next()
                if predicate1(input):
                    return conditions.get(predicate1)(input)
            return elseFunc(input)

    @staticmethod
    def generateRandomString(length):
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        _hx_str = ""
        _g = 0
        _g1 = length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = len(chars)
            index = (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(("" if (((index < 0) or ((index >= len(chars))))) else chars[index])))
        return _hx_str

    @staticmethod
    def generateRandomNumber():
        return (python_lib_Random.random() * 1000000)

    @staticmethod
    def isEmpty(input):
        if Std.isOfType(input,list):
            return (len(input) == 0)
        elif Std.isOfType(input,haxe_IMap):
            return (not input.keys().hasNext())
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            return (not HxOverrides.iterator(input).hasNext())
        elif Std.isOfType(input,str):
            return (len(StringTools.trim(input)) == 0)
        else:
            return (input is None)

    @staticmethod
    def isNotEmpty(input):
        return (not (((len(input) == 0) if (Std.isOfType(input,list)) else ((not input.keys().hasNext()) if (Std.isOfType(input,haxe_IMap)) else ((not HxOverrides.iterator(input).hasNext()) if ((python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next"))))) else ((len(StringTools.trim(input)) == 0) if (Std.isOfType(input,str)) else (input is None)))))))

    @staticmethod
    def lengthTo(input):
        if Std.isOfType(input,list):
            return len(input)
        elif Std.isOfType(input,haxe_IMap):
            input1 = input
            tmp = None
            if Std.isOfType(input1,list):
                tmp = input1
            elif Std.isOfType(input1,haxe_IMap):
                result = []
                key = input1.keys()
                while key.hasNext():
                    key1 = key.next()
                    x = _hx_AnonObject({'key': key1, 'value': Reflect.field(input1,"get")(key1)})
                    result.append(x)
                tmp = result
            elif (python_Boot.hasField(input1,"iterator") or ((python_Boot.hasField(input1,"hasNext") and python_Boot.hasField(input1,"next")))):
                result = []
                item = HxOverrides.iterator(input1)
                while item.hasNext():
                    item1 = item.next()
                    result.append(item1)
                tmp = result
            else:
                tmp = [input1]
            return len(tmp)
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            length = 0
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                length = (length + 1)
            return length
        elif Std.isOfType(input,str):
            return Reflect.field(input,"length")
        else:
            return 1

    @staticmethod
    def createTestData():
        stringArray = []
        numberArray = []
        stringMap = haxe_ds_StringMap()
        numberMap = haxe_ds_StringMap()
        _g = 0
        while (_g < 1000):
            i = _g
            _g = (_g + 1)
            chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
            _hx_str = ""
            _g1 = 0
            _g2 = 100
            while (_g1 < _g2):
                i1 = _g1
                _g1 = (_g1 + 1)
                x = len(chars)
                index = (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))
                _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(("" if (((index < 0) or ((index >= len(chars))))) else chars[index])))
            randomString = _hx_str
            randomNumber = (python_lib_Random.random() * 1000000)
            stringArray.append(randomString)
            numberArray.append(randomNumber)
            stringMap.h[("key" + Std.string(i))] = randomString
            numberMap.h[("key" + Std.string(i))] = randomNumber
        haxe_Log.trace("Testing mapT function:",_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1172, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringArray
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_1(s):
                return HxOverrides.toUpperCase(s)
            tmp = list(map(_hx_local_1,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = HxOverrides.toUpperCase(Reflect.field(input,"get")(key1))
                result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                x = HxOverrides.toUpperCase(item1)
                result.append(x)
            tmp = result
        else:
            tmp = HxOverrides.toUpperCase(input)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1173, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberArray
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_2(n):
                return (n * 2)
            tmp = list(map(_hx_local_2,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = (Reflect.field(input,"get")(key1) * 2)
                result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                result.append((item1 * 2))
            tmp = result
        else:
            tmp = (input * 2)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1174, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringMap
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_3(s):
                return HxOverrides.toUpperCase(s)
            tmp = list(map(_hx_local_3,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = HxOverrides.toUpperCase(Reflect.field(input,"get")(key1))
                result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                x = HxOverrides.toUpperCase(item1)
                result.append(x)
            tmp = result
        else:
            tmp = HxOverrides.toUpperCase(input)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1175, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberMap
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_4(n):
                return (n * 2)
            tmp = list(map(_hx_local_4,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = (Reflect.field(input,"get")(key1) * 2)
                result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                result.append((item1 * 2))
            tmp = result
        else:
            tmp = (input * 2)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1176, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        haxe_Log.trace("Testing filterT function:",_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1179, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringArray
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_5(s):
                return (HxOverrides.length(s) > 50)
            tmp = list(filter(_hx_local_5,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if (HxOverrides.length(value) > 50):
                    result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if (HxOverrides.length(item1) > 50):
                    result.append(item1)
            tmp = result
        else:
            tmp = (input if ((HxOverrides.length(input) > 50)) else None)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1180, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberArray
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_6(n):
                return (n > 500000)
            tmp = list(filter(_hx_local_6,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if (value > 500000):
                    result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if (item1 > 500000):
                    result.append(item1)
            tmp = result
        else:
            tmp = (input if ((input > 500000)) else None)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1181, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringMap
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_7(s):
                return (HxOverrides.length(s) > 50)
            tmp = list(filter(_hx_local_7,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if (HxOverrides.length(value) > 50):
                    result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if (HxOverrides.length(item1) > 50):
                    result.append(item1)
            tmp = result
        else:
            tmp = (input if ((HxOverrides.length(input) > 50)) else None)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1182, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberMap
        tmp = None
        if Std.isOfType(input,list):
            def _hx_local_8(n):
                return (n > 500000)
            tmp = list(filter(_hx_local_8,input))
        elif Std.isOfType(input,haxe_IMap):
            result = haxe_ds_StringMap()
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                value = Reflect.field(input,"get")(key1)
                if (value > 500000):
                    result.h[key1] = value
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                if (item1 > 500000):
                    result.append(item1)
            tmp = result
        else:
            tmp = (input if ((input > 500000)) else None)
        haxe_Log.trace(tmp,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1183, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        haxe_Log.trace("Testing forEachT function:",_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1186, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringArray
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                haxe_Log.trace(item,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1187, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                haxe_Log.trace(Reflect.field(input,"get")(key1),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1187, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                haxe_Log.trace(item1,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1187, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        else:
            haxe_Log.trace(input,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1187, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberArray
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                haxe_Log.trace(item,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1188, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                haxe_Log.trace(Reflect.field(input,"get")(key1),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1188, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                haxe_Log.trace(item1,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1188, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        else:
            haxe_Log.trace(input,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1188, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = stringMap
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                haxe_Log.trace(item,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1189, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                haxe_Log.trace(Reflect.field(input,"get")(key1),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1189, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                haxe_Log.trace(item1,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1189, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        else:
            haxe_Log.trace(input,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1189, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        input = numberMap
        if Std.isOfType(input,list):
            _g = 0
            _g1 = input
            while (_g < len(_g1)):
                item = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                haxe_Log.trace(item,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1190, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif Std.isOfType(input,haxe_IMap):
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                haxe_Log.trace(Reflect.field(input,"get")(key1),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1190, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                haxe_Log.trace(item1,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1190, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        else:
            haxe_Log.trace(input,_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1190, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        haxe_Log.trace("Testing ChanceSelector functions:",_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1193, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        stringChances = yutautil_ChanceSelector.fromArray(stringArray)
        haxe_Log.trace(("String chances: " + Std.string(stringChances)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1197, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        selectedString = yutautil_ChanceSelector.selectOption(stringChances)
        haxe_Log.trace(("Selected string: " + ("null" if selectedString is None else selectedString)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1201, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        numberChances = yutautil_ChanceSelector.fromArray(numberArray)
        haxe_Log.trace(("Number chances: " + Std.string(numberChances)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1205, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        selectedNumber = yutautil_ChanceSelector.selectOption(numberChances)
        haxe_Log.trace(("Selected number: " + ("null" if selectedNumber is None else selectedNumber)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1209, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        stringMapChances = yutautil_ChanceExtensions.chanceDynamicMap(stringMap)
        haxe_Log.trace(("String map chances: " + ("null" if stringMapChances is None else stringMapChances)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1213, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
        numberMapChances = yutautil_ChanceExtensions.chanceDynamicMap(numberMap)
        haxe_Log.trace(("Number map chances: " + ("null" if numberMapChances is None else numberMapChances)),_hx_AnonObject({'fileName': "src/yutautil/CollectionUtils.hx", 'lineNumber': 1220, 'className': "yutautil.CollectionUtils", 'methodName': "createTestData"}))
yutautil_CollectionUtils._hx_class = yutautil_CollectionUtils
_hx_classes["yutautil.CollectionUtils"] = yutautil_CollectionUtils

class yutautil_Month(Enum):
    __slots__ = ()
    _hx_class_name = "yutautil.Month"
    _hx_constructs = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
yutautil_Month.January = yutautil_Month("January", 0, ())
yutautil_Month.February = yutautil_Month("February", 1, ())
yutautil_Month.March = yutautil_Month("March", 2, ())
yutautil_Month.April = yutautil_Month("April", 3, ())
yutautil_Month.May = yutautil_Month("May", 4, ())
yutautil_Month.June = yutautil_Month("June", 5, ())
yutautil_Month.July = yutautil_Month("July", 6, ())
yutautil_Month.August = yutautil_Month("August", 7, ())
yutautil_Month.September = yutautil_Month("September", 8, ())
yutautil_Month.October = yutautil_Month("October", 9, ())
yutautil_Month.November = yutautil_Month("November", 10, ())
yutautil_Month.December = yutautil_Month("December", 11, ())
yutautil_Month._hx_class = yutautil_Month
_hx_classes["yutautil.Month"] = yutautil_Month

class yutautil_Day(Enum):
    __slots__ = ()
    _hx_class_name = "yutautil.Day"
    _hx_constructs = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
yutautil_Day.Sunday = yutautil_Day("Sunday", 0, ())
yutautil_Day.Monday = yutautil_Day("Monday", 1, ())
yutautil_Day.Tuesday = yutautil_Day("Tuesday", 2, ())
yutautil_Day.Wednesday = yutautil_Day("Wednesday", 3, ())
yutautil_Day.Thursday = yutautil_Day("Thursday", 4, ())
yutautil_Day.Friday = yutautil_Day("Friday", 5, ())
yutautil_Day.Saturday = yutautil_Day("Saturday", 6, ())
yutautil_Day._hx_class = yutautil_Day
_hx_classes["yutautil.Day"] = yutautil_Day


class yutautil_save_FuncEmbed:
    _hx_class_name = "yutautil.save.FuncEmbed"
    __slots__ = ()
    _hx_statics = ["runFunctionFromString", "testForErrors"]

    @staticmethod
    def runFunctionFromString(funcStr,context,run = None):
        if (run is None):
            run = False
        parser = hscript_Parser()
        interp = hscript_Interp()
        interp.variables.h["context"] = context
        hscriptExprStr = funcStr
        hscriptExprStr = (("null" if hscriptExprStr is None else hscriptExprStr) + HxOverrides.stringOrNull(("()" if (((run and (not hscriptExprStr.endswith(";"))) and (not hscriptExprStr.endswith("()")))) else "")))
        expr = parser.parseString(hscriptExprStr)
        try:
            return interp.execute(expr)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            errorMsg = StringTools.replace(StringTools.replace(Std.string(e),"hscript:","Line -"),":"," -")
            haxe_Log.trace(("Error executing function: " + ("null" if errorMsg is None else errorMsg)),_hx_AnonObject({'fileName': "src/yutautil/save/FuncEmbed.hx", 'lineNumber': 86, 'className': "yutautil.save.FuncEmbed", 'methodName': "runFunctionFromString"}))
            haxe_Log.trace(("The Expression was: \n" + ("null" if hscriptExprStr is None else hscriptExprStr)),_hx_AnonObject({'fileName': "src/yutautil/save/FuncEmbed.hx", 'lineNumber': 87, 'className': "yutautil.save.FuncEmbed", 'methodName': "runFunctionFromString"}))
            return None

    @staticmethod
    def testForErrors(f):
        expr = haxe_macro_ExprTools.toString(f)
        parser = hscript_Parser()
        interp = hscript_Interp()
        hscriptExprStr = expr
        try:
            expr = parser.parseString(hscriptExprStr)
            interp.execute(expr)
            return _hx_AnonObject({'success': True})
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            errorMsg = StringTools.replace(Std.string(e),"hscript:1: ","")
            haxe_Log.trace(((("Error parsing function: " + ("null" if errorMsg is None else errorMsg)) + "\n") + ("null" if hscriptExprStr is None else hscriptExprStr)),_hx_AnonObject({'fileName': "src/yutautil/save/FuncEmbed.hx", 'lineNumber': 113, 'className': "yutautil.save.FuncEmbed", 'methodName': "testForErrors"}))
            return _hx_AnonObject({'success': False, 'error': e})
yutautil_save_FuncEmbed._hx_class = yutautil_save_FuncEmbed
_hx_classes["yutautil.save.FuncEmbed"] = yutautil_save_FuncEmbed


class yutautil_save_MixSave:
    _hx_class_name = "yutautil.save.MixSave"
    __slots__ = ("content", "customBehaviors")
    _hx_fields = ["content", "customBehaviors"]
    _hx_methods = ["addContent", "addContentWithBehavior", "getContent", "registerBehavior", "saveContent", "loadContent"]

    def __init__(self):
        self.content = haxe_ds_StringMap()
        self.customBehaviors = haxe_ds_StringMap()

    def addContent(self,key,value):
        self.content.h[key] = value

    def addContentWithBehavior(self,key,value,saveFunc,loadFunc):
        self.content.h[key] = value
        self.customBehaviors.h[key] = _hx_AnonObject({'save': saveFunc, 'load': loadFunc})

    def getContent(self,key):
        return self.content.h.get(key,None)

    def registerBehavior(self,key,saveFunc,loadFunc):
        self.customBehaviors.h[key] = _hx_AnonObject({'save': saveFunc, 'load': loadFunc})
        if (not (key in self.content.h)):
            self.content.h[key] = None

    def saveContent(self,key):
        if (key in self.customBehaviors.h):
            tmp = self.customBehaviors.h.get(key,None)
            tmp1 = self.content.h.get(key,None)
            return tmp.save(tmp1)
        else:
            return haxe_format_JsonPrinter.print(self.content.h.get(key,None),None,None)

    def loadContent(self,key,data):
        if (key in self.customBehaviors.h):
            this1 = self.content
            value = self.customBehaviors.h.get(key,None).load(data)
            this1.h[key] = value
        else:
            this1 = self.content
            value = python_lib_Json.loads(data,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
            this1.h[key] = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.content = None
        _hx_o.customBehaviors = None
yutautil_save_MixSave._hx_class = yutautil_save_MixSave
_hx_classes["yutautil.save.MixSave"] = yutautil_save_MixSave

class yutautil_save_OutputType(Enum):
    __slots__ = ()
    _hx_class_name = "yutautil.save.OutputType"
    _hx_constructs = ["MixSaveWrapperType", "MixSaveType", "MapType", "DynamicType"]
yutautil_save_OutputType.MixSaveWrapperType = yutautil_save_OutputType("MixSaveWrapperType", 0, ())
yutautil_save_OutputType.MixSaveType = yutautil_save_OutputType("MixSaveType", 1, ())
yutautil_save_OutputType.MapType = yutautil_save_OutputType("MapType", 2, ())
yutautil_save_OutputType.DynamicType = yutautil_save_OutputType("DynamicType", 3, ())
yutautil_save_OutputType._hx_class = yutautil_save_OutputType
_hx_classes["yutautil.save.OutputType"] = yutautil_save_OutputType


class yutautil_save_MixSaveWrapper:
    _hx_class_name = "yutautil.save.MixSaveWrapper"
    __slots__ = ("mixSave", "filePath", "fancyFormat")
    _hx_fields = ["mixSave", "filePath", "fancyFormat"]
    _hx_methods = ["save", "saveContent", "addItem", "getItem", "removeItem", "hasItem", "editItem", "clear", "load", "addObject", "isEmpty", "toString", "toMap", "toDynamic"]
    _hx_statics = ["saveObjectToFile", "loadObjectFromFile", "loadMixFile", "newWithData", "newMix", "newMixWithData"]

    def __init__(self,mixSave = None,filePath = None,autoLoad = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        if (autoLoad is None):
            autoLoad = True
        self.fancyFormat = False
        self.mixSave = (mixSave if ((mixSave is not None)) else yutautil_save_MixSave())
        self.filePath = filePath
        if (not filePath.endswith(".json")):
            filePath = (("null" if filePath is None else filePath) + ".json")
            self.filePath = filePath
        if (sys_FileSystem.exists(filePath) and autoLoad):
            self.load()

    def save(self):
        fileContent = haxe_ds_StringMap()
        key = self.mixSave.content.keys()
        while key.hasNext():
            key1 = key.next()
            value = self.mixSave.saveContent(key1)
            fileContent.h[key1] = value
        if (not sys_FileSystem.exists(haxe_io_Path.directory(self.filePath))):
            sys_FileSystem.createDirectory(haxe_io_Path.directory(self.filePath))
        jsonString = haxe_format_JsonPrinter.print(fileContent,None,("\t" if (self.fancyFormat) else None))
        sys_io_File.saveContent(self.filePath,jsonString)

    def saveContent(self,key):
        return self.mixSave.saveContent(key)

    def addItem(self,key,value):
        self.mixSave.addContent(key,value)

    def getItem(self,key):
        return self.mixSave.getContent(key)

    def removeItem(self,key):
        self.mixSave.content.remove(key)

    def hasItem(self,key):
        return (key in self.mixSave.content.h)

    def editItem(self,key,value):
        self.mixSave.content.h[key] = value

    def clear(self):
        self.mixSave.content = haxe_ds_StringMap()

    def load(self):
        if sys_FileSystem.exists(self.filePath):
            jsonContent = sys_io_File.getContent(self.filePath)
            parsedContent = python_lib_Json.loads(jsonContent,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
            fileContent = haxe_ds_StringMap()
            _g = 0
            _g1 = python_Boot.fields(parsedContent)
            while (_g < len(_g1)):
                key = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                value = Reflect.field(parsedContent,key)
                fileContent.h[key] = value
            key = fileContent.keys()
            while key.hasNext():
                key1 = key.next()
                self.mixSave.loadContent(key1,fileContent.h.get(key1,None))

    def addObject(self,thing):
        _g = 0
        _g1 = python_Boot.fields(thing)
        while (_g < len(_g1)):
            field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(thing,field)
            self.mixSave.content.h[field] = value

    def isEmpty(self):
        input = self.mixSave.content
        tmp = None
        if Std.isOfType(input,list):
            tmp = input
        elif Std.isOfType(input,haxe_IMap):
            result = []
            key = input.keys()
            while key.hasNext():
                key1 = key.next()
                x = _hx_AnonObject({'key': key1, 'value': Reflect.field(input,"get")(key1)})
                result.append(x)
            tmp = result
        elif (python_Boot.hasField(input,"iterator") or ((python_Boot.hasField(input,"hasNext") and python_Boot.hasField(input,"next")))):
            result = []
            item = HxOverrides.iterator(input)
            while item.hasNext():
                item1 = item.next()
                result.append(item1)
            tmp = result
        else:
            tmp = [input]
        return (len(tmp) <= 0)

    def toString(self):
        return self.mixSave.content.toString()

    def toMap(self):
        return self.mixSave.content

    def toDynamic(self):
        result = _hx_AnonObject({})
        field = self.mixSave.content.keys()
        while field.hasNext():
            field1 = field.next()
            value = self.mixSave.content.h.get(field1,None)
            setattr(result,(("_hx_" + field1) if ((field1 in python_Boot.keywords)) else (("_hx_" + field1) if (((((len(field1) > 2) and ((ord(field1[0]) == 95))) and ((ord(field1[1]) == 95))) and ((ord(field1[(len(field1) - 1)]) != 95)))) else field1)),value)
        return result

    @staticmethod
    def saveObjectToFile(thing,filePath = None,fancy = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        if (fancy is None):
            fancy = False
        wrapper = yutautil_save_MixSaveWrapper(yutautil_save_MixSave(),filePath)
        wrapper.addObject(thing)
        wrapper.fancyFormat = fancy
        wrapper.save()

    @staticmethod
    def loadObjectFromFile(thing,filePath = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        wrapper = yutautil_save_MixSaveWrapper(yutautil_save_MixSave(),filePath)
        wrapper.load()
        _g = 0
        _g1 = python_Boot.fields(thing)
        while (_g < len(_g1)):
            field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (field in wrapper.mixSave.content.h):
                value = wrapper.mixSave.content.h.get(field,None)
                setattr(thing,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def loadMixFile(filePath = None,outputType = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        wrapper = yutautil_save_MixSaveWrapper(yutautil_save_MixSave(),filePath)
        tmp = outputType.index
        if (tmp == 0):
            return wrapper
        elif (tmp == 1):
            return wrapper.mixSave
        elif (tmp == 2):
            return wrapper.mixSave.content
        elif (tmp == 3):
            result = _hx_AnonObject({})
            field = wrapper.mixSave.content.keys()
            while field.hasNext():
                field1 = field.next()
                value = wrapper.mixSave.content.h.get(field1,None)
                setattr(result,(("_hx_" + field1) if ((field1 in python_Boot.keywords)) else (("_hx_" + field1) if (((((len(field1) > 2) and ((ord(field1[0]) == 95))) and ((ord(field1[1]) == 95))) and ((ord(field1[(len(field1) - 1)]) != 95)))) else field1)),value)
            return result
        else:
            pass

    @staticmethod
    def newWithData(mixSave,data,filePath = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        wrapper = yutautil_save_MixSaveWrapper(mixSave,filePath)
        wrapper.mixSave.content = data
        return wrapper

    @staticmethod
    def newMix(filePath = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        return yutautil_save_MixSaveWrapper(yutautil_save_MixSave(),filePath)

    @staticmethod
    def newMixWithData(data,filePath = None):
        if (filePath is None):
            filePath = "save/mixsave.json"
        return yutautil_save_MixSaveWrapper.newWithData(yutautil_save_MixSave(),data,filePath)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mixSave = None
        _hx_o.filePath = None
        _hx_o.fancyFormat = None
yutautil_save_MixSaveWrapper._hx_class = yutautil_save_MixSaveWrapper
_hx_classes["yutautil.save.MixSaveWrapper"] = yutautil_save_MixSaveWrapper


class yutautil_save_ActiveSave(yutautil_save_MixSaveWrapper):
    _hx_class_name = "yutautil.save.ActiveSave"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["addObject", "save", "load"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = yutautil_save_MixSaveWrapper


    def __init__(self,mixSave = None,filePath = None):
        if (filePath is None):
            filePath = "save/activesave.json"
        super().__init__(mixSave,filePath)

    def addObject(self,thing):
        super().addObject(thing)
        self.save()

    def save(self):
        super().save()

    def load(self):
        super().load()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
yutautil_save_ActiveSave._hx_class = yutautil_save_ActiveSave
_hx_classes["yutautil.save.ActiveSave"] = yutautil_save_ActiveSave

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi
sys_thread__Thread_HxThread.threads = haxe_ds_ObjectMap()
sys_thread__Thread_HxThread.threadsMutex = sys_thread_Mutex()
sys_thread__Thread_HxThread.mainThread = sys_thread__Thread_HxThread(python_lib_Threading.current_thread())
sys_thread__Thread_HxThread.mainThread.events = sys_thread_EventLoop()

python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
YutaUtil.date = yutautil_ExtendedDate.newDate()
YutaUtil.services = yutautil_CatagorizedMap(["Var", "Func", "Class", "Thread", "Date", "Map", "Save", "Chance"],True)
backend_Threader.specialThreads = []
backend_Threader.quietThreads = []
backend_Threader.usedthreads = False
backend_Threader.generatedThreads = []
backend_Threader.bakedThreads = []
backend_modules_EventFunc.instances = []
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
hscript_Parser.p1 = 0
hscript_Parser.tokenMin = 0
hscript_Parser.tokenMax = 0

YutaUtil.main()
sys_thread__Thread_Thread_Impl_.processEvents()
